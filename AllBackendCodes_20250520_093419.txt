ğŸ“‚ KODTRÃ„D
==========
â”œâ”€â”€ bookings
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ getavailableslots
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ meeting_types
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ refreshCalendarOrigins
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ refreshTravelTimes
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ calendar
â”‚   â”‚   â”œâ”€â”€ appleCalendar.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ calendar
â”‚   â”‚   â”œâ”€â”€ getMsToken.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ calendar
â”‚   â”‚   â”œâ”€â”€ msGraph.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ calendar
â”‚   â”‚   â”œâ”€â”€ resolveOrigin.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ config
â”‚   â”‚   â”œâ”€â”€ settingsLoader.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ config
â”‚   â”‚   â”œâ”€â”€ verifySettings.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ db
â”‚   â”‚   â”œâ”€â”€ pgPool.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ maps
â”‚   â”‚   â”œâ”€â”€ appleMaps.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ maps
â”‚   â”‚   â”œâ”€â”€ returnTravelVerifier.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ maps
â”‚   â”‚   â”œâ”€â”€ travelTimeResolver.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ slots
â”‚   â”‚   â”œâ”€â”€ slotEngine.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ utils
â”‚   â”‚   â”œâ”€â”€ debugLogger.js
â”œâ”€â”€ validate_contact
â”‚   â”œâ”€â”€ index.js
==========

====================
ğŸ“„ Fil: index.js
ğŸ“… Senast Ã¤ndrad: 2025-05-19 09:56:12
ğŸ“ Antal rader: 66
ğŸ§© Antal funktioner: 2
ğŸ’¬ KommentarstÃ¤ckning: 1 rader (1.5%)
ğŸ“¥ Imports: 1 â€“ ["const { Pool } = require('pg');"]
ğŸ” LÃ¤ngsta funktion: 7 rader
ğŸ§  KomplexitetspoÃ¤ng: 5
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const { Pool } = require('pg');

const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: { rejectUnauthorized: false }
});

module.exports = async function (context, req) {
  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.log.error(`Missing environment variable: ${key}`);
      context.res = {
        status: 500,
        body: { error: `Missing environment variable: ${key}` }
      };
      return;
    }
  }

  try {
    const settingsRes = await pool.query(
      "select key, value from booking_settings where key in ('meeting_types', 'default_meeting_length_atclient', 'default_meeting_length_atoffice', 'default_meeting_length_digital')"
    );

    const settings = {};
    for (const row of settingsRes.rows) {
      try {
        settings[row.key] = JSON.parse(row.value);
      } catch {
        settings[row.key] = row.value;
      }
    }

    const rawTypes = settings['meeting_types'];
    const meetingTypes = Array.isArray(rawTypes) ? rawTypes.map(t => t.toLowerCase()) : [];
    const lengths = {
      zoom: settings['default_meeting_length_digital'],
      facetime: settings['default_meeting_length_digital'],
      teams: settings['default_meeting_length_digital'],
      atclient: settings['default_meeting_length_atclient'],
      atoffice: settings['default_meeting_length_atoffice']
    };

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        types: meetingTypes,
        lengths
      })
    };
  } catch (error) {
    context.log.error('Database query failed:', error);
    context.res = {
      status: 500,
      body: { error: error.message }
    };
  } finally {
    // pool.end() tas bort â€“ vi Ã¥teranvÃ¤nder en delad pool mellan anrop
  }
};
END: index.js

====================
ğŸ“„ Fil: index.js
ğŸ“… Senast Ã¤ndrad: 2025-05-15 10:15:41
ğŸ“ Antal rader: 128
ğŸ§© Antal funktioner: 2
ğŸ’¬ KommentarstÃ¤ckning: 1 rader (0.8%)
ğŸ“¥ Imports: 2 â€“ ["const { Pool } = require('pg');", "const { v4: uuidv4 } = require('uuid');"]
ğŸ” LÃ¤ngsta funktion: 7 rader
ğŸ§  KomplexitetspoÃ¤ng: 14
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const { Pool } = require('pg');
const { v4: uuidv4 } = require('uuid');
const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: { rejectUnauthorized: false }
});

module.exports = async function (context, req) {
  try {
    const email = req.body?.email || req.query?.email;
    const meeting_type = req.body?.meeting_type || req.query?.meeting_type;
    context.log.info('ğŸ“¥ validate_contact triggered with:', { email, meeting_type });

    if (!email || !meeting_type) {
      context.res = { status: 400, body: { error: "email and meeting_type are required" } };
      return;
    }

    const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
    for (const key of requiredEnv) {
      if (!process.env[key]) throw new Error(`Missing environment variable: ${key}`);
    }

    const contactRes = await pool.query('SELECT * FROM contact WHERE booking_email = $1', [email]);
    const contact = contactRes.rows[0];
    let metadata = contact?.metadata || {};

    if (typeof metadata === 'string') {
      try {
        metadata = JSON.parse(metadata);
      } catch {
        metadata = {};
      }
    }

    if (typeof metadata !== 'object' || metadata === null) metadata = {};

    const settingsRes = await pool.query('SELECT value FROM booking_settings WHERE key = $1', ['meeting_digital']);
    const raw = settingsRes.rows[0]?.value;
    const digitalTypes = Array.isArray(raw) ? raw : JSON.parse(raw || '[]');
    const isDigital = digitalTypes.map(t => t.toLowerCase()).includes(meeting_type.toLowerCase()) || meeting_type === 'atoffice';

    const alwaysRequired = ['first_name', 'last_name', 'phone', 'company'];
    const addressRequired = ['address', 'postal_code', 'city', 'country'];
    const requiredFields = [...alwaysRequired, ...(isDigital ? [] : addressRequired)];
    const missingFields = requiredFields.filter(
      field => !metadata[field] || typeof metadata[field] !== 'string' || metadata[field].trim() === ''
    );

    if ((req.body?.write_if_valid || req.query?.write_if_valid) && missingFields.length > 0) {
      let metadataFromClient = req.body?.metadata;
      if (typeof metadataFromClient === 'string') {
        try {
          metadataFromClient = JSON.parse(metadataFromClient);
        } catch {
          metadataFromClient = {};
        }
      }
      if (typeof metadataFromClient === 'object' && metadataFromClient !== null) {
        if (!contact) {
          const newId = uuidv4();
          await pool.query(
            `INSERT INTO contact (id, booking_email, metadata, created_at) VALUES ($1, $2, $3, NOW())`,
            [newId, email, metadataFromClient]
          );
          context.log.info('âœ… Ny kontakt skapad via validate_contact');

          context.res = {
            status: 200,
            body: {
              status: "created",
              contact_id: newId
            }
          };
          return;
        } else {
          await pool.query(
            `UPDATE contact SET metadata = $1, updated_at = NOW() WHERE booking_email = $2`,
            [metadataFromClient, email]
          );
          context.log.info('âœï¸ Befintlig kontakt uppdaterad via validate_contact');
        }
      }
    }

    if (!contact) {
      context.res = {
        status: 200,
        body: {
          status: "new_customer",
          missing_fields: missingFields
        }
      };
    } else if (missingFields.length > 0) {
      context.res = {
        status: 200,
        body: {
          status: "incomplete",
          missing_fields: missingFields
        }
      };
    } else {
      context.res = {
        status: 200,
        body: {
          status: "existing_customer",
          contact_id: contact.id
        }
      };
    }

  } catch (error) {
    context.log.error('âŒ Error during validate_contact:', {
      message: error.message,
      stack: error.stack
    });
    context.res = {
      status: 500,
      body: { error: error.message, stack: error.stack }
    };
  } finally {
    // Poolen Ã¤r delad och Ã¥teranvÃ¤nds â€“ vi stÃ¤nger den inte hÃ¤r
  }
};
END: index.js

====================
ğŸ“„ Fil: index.js
ğŸ“… Senast Ã¤ndrad: 2025-05-20 08:55:37
ğŸ“ Antal rader: 242
ğŸ§© Antal funktioner: 5
ğŸ’¬ KommentarstÃ¤ckning: 16 rader (6.6%)
ğŸ“¥ Imports: 11 â€“ ["const { generateSlotChunks } = require('../shared/slots/slotEngine');", "const { DateTime } = require('luxon');", "const pool = require('../shared/db/pgPool');", "const loadSettings = require('../shared/config/settingsLoader');", "const graphClient = require('../shared/calendar/msGraph')();", "const appleClient = require('../shared/calendar/appleCalendar')();", "const verifyBookingSettings = require('../shared/config/verifySettings');", "const { createDebugLogger } = require('../shared/utils/debugLogger');", "const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');", "const getMsToken = require('../shared/calendar/getMsToken');", "const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');"]
ğŸ” LÃ¤ngsta funktion: 16 rader
ğŸ§  KomplexitetspoÃ¤ng: 19
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
// SQL: GRANT USAGE, SELECT ON SEQUENCE calendar_origin_cache_id_seq TO <user>;
const { generateSlotChunks } = require('../shared/slots/slotEngine');
const { DateTime } = require('luxon');
const pool = require('../shared/db/pgPool');
const loadSettings = require('../shared/config/settingsLoader');
const graphClient = require('../shared/calendar/msGraph')();
const appleClient = require('../shared/calendar/appleCalendar')();
const verifyBookingSettings = require('../shared/config/verifySettings');

const { createDebugLogger } = require('../shared/utils/debugLogger');

module.exports = async function (context, req) {
  const startTimeMs = Date.now();
  context.log(`ğŸ“¥ Request mottagen: ${JSON.stringify(req.body || {}, null, 2)}`);
  let msGraphAccessToken = null;
  const isDebug = process.env.DEBUG === 'true';
  const { debugLog, skipReasons, getSkipSummary } = createDebugLogger(context);
  if (req.method === 'OPTIONS') {
    context.res = {
      status: 204,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type'
      }
    };
    return;
  }

  if (req.method !== 'POST') {
    context.res = {
      status: 405,
      body: { message: 'Method Not Allowed' }
    };
    return;
  }

  try {
    // Pool Ã¥teranvÃ¤nds frÃ¥n global instans
    // Import cache-driven origin resolution logic
    const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');
    if (typeof graphClient?.setToken !== 'function') {
      throw new Error('graphClient saknar setToken-metod');
    }
    if (typeof appleClient?.setContext !== 'function') {
      throw new Error('appleClient saknar setContext-metod');
    }
    context.log('ğŸ“¦ graphClient keys:', Object.keys(graphClient || {}));
    context.log('ğŸ“¦ appleClient keys:', Object.keys(appleClient || {}));
    // HÃ¤mta MS Graph-token en gÃ¥ng
    const getMsToken = require('../shared/calendar/getMsToken');
    msGraphAccessToken = await getMsToken(context);
    graphClient.setToken(msGraphAccessToken);
    appleClient.setContext(context);
    debugLog('ğŸ BÃ¶rjar getavailableslots');
    const t0 = Date.now();
    const travelCache = new Map(); // key: from|to|hour
    // Flyttad slot-chunk och slot-generation till hjÃ¤lpfunktion
    // Anropa generateSlotChunks direkt efter travelCache
    // (chunk-loop och slot-generation Ã¤r nu flyttad)

    const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
    for (const key of requiredEnv) {
      if (!process.env[key]) {
        throw new Error(`Missing environment variable: ${key}`);
      }
    }
    debugLog('ğŸ” Environment variables verified');
    debugLog('âœ… PostgreSQL pool created');
    debugLog('â±ï¸ Efter env och pool: ' + (Date.now() - t0) + ' ms');

    const { email, contact_id, meeting_type: rawMeetingType, meeting_length } = req.body || {};
    const meeting_type = (rawMeetingType || '').toLowerCase();
    debugLog(`ğŸ“¨ BegÃ¤ran mottagen med meeting_type: ${meeting_type}, meeting_length: ${meeting_length}, contact_id: ${contact_id}, email: ${email}`);

    const db = await pool.connect();


  const contactRes = await db.query('SELECT * FROM contact WHERE id = $1', [contact_id]);
  const contact = contactRes.rows[0];
  debugLog(`ğŸ‘¤ Kontakt hittad: ${contact?.id || 'ej funnen'}`);
    const t1 = Date.now();
    debugLog('â±ï¸ Efter kontakt: ' + (Date.now() - t0) + ' ms');

    const settings = await loadSettings(db, context);
    debugLog(`âš™ï¸ InstÃ¤llningar laddade: ${Object.keys(settings).join(', ')}`);
    verifyBookingSettings(settings, context);
    debugLog('âš™ï¸ InstÃ¤llningar klara');
    const timezone = settings.timezone || 'Europe/Stockholm';
    const t2 = Date.now();
    debugLog('â±ï¸ Efter settings: ' + (Date.now() - t0) + ' ms');

    const bookingsByDay = {};

    const maxDays = settings.max_days_in_advance || 14;
    const today = new Date();
    const endDate = new Date(today);
    endDate.setDate(today.getDate() + maxDays);
    const totalDays = maxDays;
    const days = Array.from({ length: totalDays }, (_, i) => {
      const date = new Date(today);
      date.setDate(today.getDate() + i);
      return date;
    });
    debugLog(`ğŸ“† Antal dagar att bearbeta: ${days.length}`);
    debugLog('ğŸ“… Dagar genererade fÃ¶r bearbetning');

    // --- Ladda alla bokningar fÃ¶r hela intervallet i ett slag ---
    const startDateStr = days[0].toISOString().split('T')[0];
    const endDateStr = days[days.length - 1].toISOString().split('T')[0];
    const allBookingsRes = await db.query(
      'SELECT start_time, end_time, meeting_type FROM bookings WHERE start_time::date >= $1 AND start_time::date <= $2',
      [startDateStr, endDateStr]
    );
    context.log("ğŸ”¢ Mapping allBookings rows:", allBookingsRes.rows.length);
    const allBookings = allBookingsRes.rows.map(b => ({
      start: new Date(b.start_time).getTime(),
      end: new Date(b.end_time).getTime(),
      date: new Date(b.start_time).toISOString().split('T')[0],
      meeting_type: b.meeting_type
    }));
    context.log("ğŸ“Š allBookings parsed:", allBookings.map(b => b.start));
    const bookingCount = allBookings.length;
    context.log(`ğŸ“Š Antal bokningar i intervall: ${bookingCount}`);
    context.log(`ğŸ‘¤ Kund: ${contact?.first_name || ''} ${contact?.last_name || ''}, Typ: ${meeting_type}`);
    for (const booking of allBookings) {
      if (!bookingsByDay[booking.date]) bookingsByDay[booking.date] = [];
      bookingsByDay[booking.date].push({ start: booking.start, end: booking.end });
    }
    // --- Summera bokade minuter per vecka & mÃ¶testyp ---
    const weeklyMinutesByType = {};
    const weekKey = (date) => {
      const start = new Date(date);
      start.setUTCHours(0, 0, 0, 0);
      start.setUTCDate(start.getUTCDate() - start.getUTCDay());
      return start.toISOString().split('T')[0];
    };
    for (const b of allBookings) {
      const type = b.meeting_type || 'unknown';
      const week = weekKey(b.start);
      weeklyMinutesByType[type] = weeklyMinutesByType[type] || {};
      weeklyMinutesByType[type][week] = (weeklyMinutesByType[type][week] || 0) + (b.end - b.start) / 60000;
    }

    if (!contact_id || !meeting_type || !meeting_length) {
      context.res = {
        status: 400,
        body: { error: 'Missing one or more required fields: contact_id, meeting_type, meeting_length' }
      };
      return;
    }

    // Restidslogik (travelTimeMin) hanteras nu av resolveTravelTime i slotRules/generateSlotChunks

    const windowStartHour = DateTime.fromISO(`${days[0].toISOString().split('T')[0]}T${settings.travel_time_window_start || '06:00'}`, { zone: timezone }).toUTC().hour;
    const windowEndHour = DateTime.fromISO(`${days[0].toISOString().split('T')[0]}T${settings.travel_time_window_end || '23:00'}`, { zone: timezone }).toUTC().hour;

    // HÃ¤mta Apple Maps-token en gÃ¥ng tidigt
    const accessToken = await getAppleMapsAccessToken(context);
    if (!accessToken && isDebug) {
      context.log('âš ï¸ Apple Maps-token saknas â€“ vissa slots kan anvÃ¤nda fallback');
    }
    const t3 = Date.now();
    debugLog('â±ï¸ Efter Apple Maps token: ' + (Date.now() - t0) + ' ms');

    // Parallellisera dag-loop i chunkar om 7
    // --- Ny slot-generation via generateSlotChunks ---
    const { chosenSlots, slotMapResult, slotLogSummary } = await generateSlotChunks({
      days,
      context,
      contact,
      contact_id,
      meeting_type,
      meeting_length,
      bookingsByDay,
      weeklyMinutesByType,
      settings,
      graphClient,
      appleClient,
      travelCache,
      accessToken,
      timezone,
      debugHelper: { debugLog, skipReasons }
    });
    const slotMap = slotMapResult;
    const chosen = chosenSlots;
    const slotCount = chosen.length;

    // Scan for fallback travel time usage
    const fallbackSlots = chosen.filter(s => s.origin && s.travel_time_min && s.is_fallback === true);
    if (fallbackSlots.length > 0) {
      context.log(`ğŸŸ¡ ${fallbackSlots.length} slots anvÃ¤nder fallback-restid â€“ Ã¶vervÃ¤g att uppdatera cache`);
      // Optional: add logic to trigger refreshTravelTimes for those routes
    }

    const elapsedMs = Date.now() - t0;
    context.log(`â±ï¸ Total exekveringstid: ${elapsedMs} ms`);

    debugLog(`âœ… getavailableslots klar med ${chosen.length} slots`);
    // --- Summerad loggning av varfÃ¶r slots har avvisats (om isDebug) ---
    if (isDebug) {
      for (const [reason, count] of Object.entries(getSkipSummary())) {
        context.log(`ğŸ“‰ ${reason}: ${count} st`);
      }
      context.log(`ğŸ“ˆ Totalt tillagda slots: ${slotCount}`);
    }
    if (chosen.length < 2) {
      context.log(`âš ï¸ Endast ${chosen.length} slot(s) genererade â€“ kontrollera regler eller data`);
    }
    if (!chosen.length) {
      context.log(`âš ï¸ Inga tillgÃ¤ngliga slots kunde genereras â€“ returnerar tom lista`);
      context.res = {
        status: 200,
        headers: { 'Access-Control-Allow-Origin': '*' },
        body: { slots: [] }
      };
      return;
    }
    context.res = {
      status: 200,
      headers: {
        'Access-Control-Allow-Origin': '*'
      },
      body: {
        slots: chosen
      }
    };
    const totalDurationMs = Date.now() - startTimeMs;
    context.log(`â±ï¸ getavailableslots fÃ¤rdig â€“ total tid: ${totalDurationMs} ms`);
    return;
  } catch (error) {
    debugLog(`ğŸ’¥ Fel uppstod: ${error.message}`);
    context.log('ğŸ”¥ FEL:', error.message);
    context.log(error.stack);
    context.res = {
      status: 500,
      body: { error: error.message, stack: error.stack }
    };
  }
};

const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');

END: index.js

====================
ğŸ“„ Fil: index.js
ğŸ“… Senast Ã¤ndrad: 2025-05-19 15:57:39
ğŸ“ Antal rader: 35
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 4 â€“ ["const { DateTime } = require('luxon');", "const pool = require('../shared/db/pgPool');", "const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');", "const settingsLoader = require('../shared/config/settingsLoader');"]
ğŸ” LÃ¤ngsta funktion: 4 rader
ğŸ§  KomplexitetspoÃ¤ng: 1
ğŸ§ª TODO/FIXME: 0
====================
START: index.js


const { DateTime } = require('luxon');
const pool = require('../shared/db/pgPool');
const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');
const settingsLoader = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const today = new Date();
  const settings = await settingsLoader(pool, context);
  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const date = new Date();
    date.setDate(today.getDate() + i);
    return date;
  });

  context.log(`ğŸ” KÃ¶r refreshCalendarOrigins fÃ¶r ${days.length} dagar`);

  for (const date of days) {
    const slotTime = DateTime.fromJSDate(date).set({ hour: 10, minute: 0 }).toJSDate();
    const travelStart = new Date(slotTime.getTime() - (settings.fallback_travel_time_minutes || 20) * 60000);

    await resolveOriginAddress({
      eventId: slotTime.toISOString(),
      calendarId: 'system-refresh',
      pool,
      context,
      fallbackOrigin: settings.default_home_address,
      settings
    });
  }

  context.log('âœ… refreshCalendarOrigins fÃ¤rdig');
};
END: index.js

====================
ğŸ“„ Fil: index.js
ğŸ“… Senast Ã¤ndrad: 2025-05-19 15:56:23
ğŸ“ Antal rader: 112
ğŸ§© Antal funktioner: 4
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 6 â€“ ["const { DateTime } = require('luxon');", "const fetch = require('node-fetch');", "const pool = require('../shared/db/pgPool');", "const loadSettings = require('../shared/config/settingsLoader');", "const jwt = require('jsonwebtoken');", "const fs = require('fs');"]
ğŸ” LÃ¤ngsta funktion: 10 rader
ğŸ§  KomplexitetspoÃ¤ng: 8
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const { DateTime } = require('luxon');
const fetch = require('node-fetch');
const pool = require('../shared/db/pgPool');
const loadSettings = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const settings = await loadSettings(pool, context);
  const fallbackTravelTime = settings.fallback_travel_time_minutes || 20;
  const today = new Date();
  const timezone = settings.timezone || 'Europe/Stockholm';

  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const d = new Date(today);
    d.setDate(today.getDate() + i);
    return d;
  });

  const destinations = [settings.default_office_address];
  const origins = [settings.default_home_address];

  for (const day of days) {
    for (const hour of [10, 14]) {
      const slotTime = DateTime.fromJSDate(day).set({ hour, minute: 0 }).toJSDate();

      for (const from of origins) {
        for (const to of destinations) {
          const hourKey = slotTime.getUTCHours();
          const key = `${from}|${to}|${hourKey}`;

          const res = await pool.query(
            `SELECT 1 FROM travel_time_cache
             WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
            [from, to, hourKey]
          );

          if (res.rows.length > 0) {
            context.log(`âš¡ Redan i cache: ${key}`);
            continue;
          }

          context.log(`â³ BerÃ¤knar restid: ${key}`);
          try {
            const token = await getAppleMapsAccessToken(context);
            if (!token) throw new Error('Apple Maps-token saknas');

            const url = new URL('https://maps-api.apple.com/v1/directions');
            url.searchParams.append('origin', from);
            url.searchParams.append('destination', to);
            url.searchParams.append('transportType', 'automobile');
            url.searchParams.append('departureTime', slotTime.toISOString());

            const response = await fetch(url.toString(), {
              headers: { Authorization: `Bearer ${token}` }
            });
            const data = await response.json();

            const minutes = Math.round((data.routes?.[0]?.durationSeconds || fallbackTravelTime * 60) / 60);
            await pool.query(
              `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
               VALUES ($1, $2, $3, $4)
               ON CONFLICT (from_address, to_address, hour)
               DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes`,
              [from, to, hourKey, minutes]
            );
            context.log(`âœ… Sparad restid: ${minutes} min (${key})`);
          } catch (err) {
            context.log(`âš ï¸ Misslyckades hÃ¤mta/spara restid fÃ¶r ${key}: ${err.message}`);
          }
        }
      }
    }
  }

  context.log('âœ… refreshTravelTimes fÃ¤rdig');
};

async function getAppleMapsAccessToken(context) {
  try {
    const jwt = require('jsonwebtoken');
    const fs = require('fs');

    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n') ||
                       fs.readFileSync(process.env.APPLE_MAPS_KEY_PATH, 'utf8');

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context.log('âš ï¸ Misslyckades hÃ¤mta Apple Maps token:', err.message);
    return null;
  }
}
END: index.js

====================
ğŸ“„ Fil: appleCalendar.js
ğŸ“… Senast Ã¤ndrad: 2025-05-20 08:20:35
ğŸ“ Antal rader: 75
ğŸ§© Antal funktioner: 2
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ['const fetch = require("node-fetch");', 'const xml2js = require("xml2js");']
ğŸ” LÃ¤ngsta funktion: 14 rader
ğŸ§  KomplexitetspoÃ¤ng: 7
ğŸ§ª TODO/FIXME: 0
====================
START: appleCalendar.js
const fetch = require("node-fetch");
const xml2js = require("xml2js");

function createAppleClient(context) {
  return {
    async getEvent(calendarId, eventId) {
      const caldavUrl = process.env.CALDAV_CALENDAR_URL;
      const username = process.env.CALDAV_USER;
      const password = process.env.CALDAV_PASSWORD;

      if (!caldavUrl || !username || !password) {
        context.log("âš ï¸ Missing CalDAV credentials");
        return null;
      }

      try {
        const res = await fetch(caldavUrl, {
          method: "PROPFIND",
          headers: {
            "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64"),
            "Content-Type": "application/xml",
            "Depth": "1"
          },
          body: `<?xml version="1.0"?>
            <d:propfind xmlns:d="DAV:">
              <d:prop>
                <d:getetag/>
                <d:calendar-data xmlns="urn:ietf:params:xml:ns:caldav"/>
              </d:prop>
            </d:propfind>`
        });

        if (!res.ok) {
          context.log("âš ï¸ CalDAV fetch failed:", res.statusText);
          return null;
        }

        const xml = await res.text();
        const parsed = await xml2js.parseStringPromise(xml, { explicitArray: false });
        const responses = parsed['d:multistatus']?.['d:response'];
        let calendarData;

        if (Array.isArray(responses)) {
          for (const response of responses) {
            const data = response['d:propstat']?.['d:prop']?.['cal:calendar-data'];
            if (data) {
              calendarData = data;
              break;
            }
          }
        } else {
          calendarData = responses?.['d:propstat']?.['d:prop']?.['cal:calendar-data'];
        }

        if (!calendarData) {
          context.log("âš ï¸ No calendar-data found in CalDAV response.");
          return null;
        }

        const locationMatch = calendarData.match(/LOCATION:(.*)/);
        const endTimeMatch = calendarData.match(/DTEND(?:;[^:]*)?:(.*)/);

        const location = locationMatch ? locationMatch[1].trim() : null;
        const endTime = endTimeMatch ? endTimeMatch[1].trim() : null;

        return { location, endTime };
      } catch (err) {
        context.log("âš ï¸ Error parsing CalDAV response:", err.message);
        return null;
      }
    }
  };
}

module.exports = createAppleClient;
END: appleCalendar.js

====================
ğŸ“„ Fil: getMsToken.js
ğŸ“… Senast Ã¤ndrad: 2025-05-19 18:32:38
ğŸ“ Antal rader: 31
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 1 â€“ ["const fetch = require('node-fetch');"]
ğŸ” LÃ¤ngsta funktion: 4 rader
ğŸ§  KomplexitetspoÃ¤ng: 2
ğŸ§ª TODO/FIXME: 0
====================
START: getMsToken.js


const fetch = require('node-fetch');

module.exports = async function getMsToken(context) {
  try {
    const tokenEndpoint = `https://login.microsoftonline.com/${process.env.MS365_TENANT_ID}/oauth2/v2.0/token`;
    const params = new URLSearchParams();
    params.append('client_id', process.env.MS365_CLIENT_ID);
    params.append('client_secret', process.env.MS365_CLIENT_SECRET);
    params.append('scope', 'https://graph.microsoft.com/.default');
    params.append('grant_type', 'client_credentials');

    const res = await fetch(tokenEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params
    });

    if (!res.ok) {
      context.log(`âš ï¸ TokenhÃ¤mtning misslyckades: ${res.statusText}`);
      return null;
    }

    const data = await res.json();
    return data.access_token;
  } catch (err) {
    context.log(`âš ï¸ TokenhÃ¤mtning fel: ${err.message}`);
    return null;
  }
};
END: getMsToken.js

====================
ğŸ“„ Fil: msGraph.js
ğŸ“… Senast Ã¤ndrad: 2025-05-20 08:21:17
ğŸ“ Antal rader: 64
ğŸ§© Antal funktioner: 3
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 3 â€“ ['const { Client } = require("@microsoft/microsoft-graph-client");', 'require("isomorphic-fetch");', 'const fetch = require("node-fetch");']
ğŸ” LÃ¤ngsta funktion: 3 rader
ğŸ§  KomplexitetspoÃ¤ng: 3
ğŸ§ª TODO/FIXME: 0
====================
START: msGraph.js
const { Client } = require("@microsoft/microsoft-graph-client");
require("isomorphic-fetch");
const fetch = require("node-fetch");

function createMsGraphClient() {
  let token = null;

  async function getAccessToken() {
    const tenantId = process.env.MS365_TENANT_ID;
    const clientId = process.env.MS365_CLIENT_ID;
    const clientSecret = process.env.MS365_CLIENT_SECRET;

    const tokenEndpoint = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`;
    const params = new URLSearchParams();
    params.append("client_id", clientId);
    params.append("client_secret", clientSecret);
    params.append("scope", "https://graph.microsoft.com/.default");
    params.append("grant_type", "client_credentials");

    const res = await fetch(tokenEndpoint, {
      method: "POST",
      body: params
    });

    if (!res.ok) {
      console.error(`âš ï¸ Token fetch failed: ${res.statusText}`);
      throw new Error(`Token fetch failed: ${res.statusText}`);
    }
    const data = await res.json();
    token = data.access_token;
    return token;
  }

  async function getEvent(calendarId, eventId) {
    try {
      if (!calendarId || !eventId) {
        console.warn("âŒ getEvent missing calendarId or eventId (Graph)");
        return null;
      }

      const authToken = token || await getAccessToken();
      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const result = await client
        .api(`/users/${calendarId}/events/${encodeURIComponent(eventId)}`)
        .select("location,end")
        .get();

      const location = result.location?.displayName || null;
      const endTime = result.end?.dateTime || null;

      return { location, endTime };
    } catch (err) {
      console.error("âš ï¸ getEvent error (Graph):", err.message);
      return null;
    }
  }

  return { getEvent };
}

module.exports = createMsGraphClient;
END: msGraph.js

====================
ğŸ“„ Fil: resolveOrigin.js
ğŸ“… Senast Ã¤ndrad: 2025-05-20 08:56:59
ğŸ“ Antal rader: 133
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 6 rader (4.5%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 2 rader
ğŸ§  KomplexitetspoÃ¤ng: 21
ğŸ§ª TODO/FIXME: 0
====================
START: resolveOrigin.js
const memoryCache = {};

async function resolveOriginAddress({ eventId, calendarId, pool, context, graphClient, appleClient, fallbackOrigin, settings }) {
  const cacheKey = `${calendarId}:${eventId}`;
  const debugLog = (msg) => {
    if (process.env.DEBUG === 'true' && context?.log) context.log(msg);
  };
  debugLog(`ğŸ” resolveOriginAddress â†’ calendarId: ${calendarId}, eventId: ${eventId}`);
  const eventDateOnly = eventId.split('T')[0];
  if (memoryCache[cacheKey]) {
    // Provide originEndTime as well
    let originEndTime = null;
    if (memoryCache[cacheKey].originSource === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = memoryCache[cacheKey].originEndTime || null;
    }
    debugLog(`âœ… Hittade origin frÃ¥n cache: ${memoryCache[cacheKey].origin}`);
    return {
      origin: memoryCache[cacheKey].origin,
      originSource: memoryCache[cacheKey].originSource,
      originEndTime
    };
  }


  // Try database cache first
  let dbRes;
  try {
    dbRes = await pool.query(
      'SELECT address, source, end_time FROM calendar_origin_cache WHERE event_date = $1',
      [eventDateOnly]
    );
    debugLog(`ğŸ“‚ DB-kontroll: Hittade ${dbRes?.rows?.length || 0} rader fÃ¶r ${eventDateOnly}`);
  } catch (err) {
    context.log(`âš ï¸ DB error in resolveOriginAddress: ${err.message}`);
  }
  if (dbRes && dbRes.rows && dbRes.rows.length > 0) {
    let originEndTime = null;
    if (dbRes.rows[0].source === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = dbRes.rows[0].end_time || null;
    }
    memoryCache[cacheKey] = {
      origin: dbRes.rows[0].address,
      originSource: dbRes.rows[0].source,
      originEndTime: originEndTime
    };
    debugLog(`âœ… Hittade origin frÃ¥n DB: ${dbRes.rows[0].address}`);
    return {
      origin: dbRes.rows[0].address,
      originSource: dbRes.rows[0].source,
      originEndTime
    };
  }
  debugLog(`ğŸ•³ï¸ Inget cachetrÃ¤ff i DB fÃ¶r ${eventDateOnly}`);

  // Try fetching from MS Graph
  let latestOrigin;
  let originSource = 'unknown';
  if (graphClient && typeof graphClient.getEvent === 'function') {
    try {
      const msEvent = await graphClient.getEvent(calendarId, eventId);
      if (msEvent && msEvent.location) {
        latestOrigin = msEvent.location;
        originSource = 'msgraph';
        debugLog(`âœ… Hittade origin frÃ¥n MS Graph: ${latestOrigin}`);
      }
    } catch (err) {
      context.log(`âš ï¸ MS Graph error in resolveOriginAddress: ${err.message}`);
    }
  } else if (graphClient) {
    context.log(`âš ï¸ graphClient saknar getEvent-metod eller Ã¤r null`);
  }

  // Try fetching from Apple calendar if not found
  if (!latestOrigin && appleClient && typeof appleClient.getEvent === 'function') {
    try {
      const appleEvent = await appleClient.getEvent(calendarId, eventId);
      if (appleEvent && appleEvent.location) {
        latestOrigin = appleEvent.location;
        originSource = 'apple';
        debugLog(`âœ… Hittade origin frÃ¥n Apple: ${latestOrigin}`);
      }
    } catch (err) {
      context.log(`âš ï¸ Apple error in resolveOriginAddress: ${err.message}`);
    }
  } else if (!latestOrigin && appleClient) {
    context.log(`âš ï¸ appleClient saknar getEvent-metod eller Ã¤r null`);
  }

  // Fallback if not found
  if (!latestOrigin) {
    debugLog(`ğŸš¨ Ingen trÃ¤ff i varken cache, DB, Graph eller Apple â€“ anvÃ¤nder fallback`);
    latestOrigin = fallbackOrigin || '';
    originSource = 'fallback';
    debugLog(`âš ï¸ Fallback anvÃ¤nds som origin: ${latestOrigin}`);
  }

  // Write to DB cache unless fallback
  let originEndTime = null;
  if (originSource === 'fallback') {
    originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
  }
  if (originSource !== 'fallback') {
    try {
      await pool.query(
        `INSERT INTO calendar_origin_cache (event_date, source, address, end_time)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT DO NOTHING`,
        [eventDateOnly, originSource, latestOrigin, originEndTime]
      );
    } catch (err) {
      context.log(`âš ï¸ DB write error in resolveOriginAddress: ${err.message}`);
    }
  }

  memoryCache[cacheKey] = {
    origin: latestOrigin,
    originSource,
    originEndTime
  };
  debugLog(`ğŸ§  resolveOriginAddress resultat: ${latestOrigin} (kÃ¤lla: ${originSource})`);
  context.log(`ğŸ“¤ resolveOriginAddress return: ${latestOrigin} (kÃ¤lla: ${originSource}, endTime: ${originEndTime?.toISOString?.() || 'null'})`);
  return { origin: latestOrigin, originSource, originEndTime };
}

module.exports = { resolveOriginAddress };

if (process.env.NODE_ENV === 'test') {
  module.exports._test = { memoryCache };
}
END: resolveOrigin.js

====================
ğŸ“„ Fil: settingsLoader.js
ğŸ“… Senast Ã¤ndrad: 2025-05-19 17:13:05
ğŸ“ Antal rader: 39
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 4 rader
ğŸ§  KomplexitetspoÃ¤ng: 8
ğŸ§ª TODO/FIXME: 0
====================
START: settingsLoader.js
module.exports = async function loadSettings(pool, context) {
  try {
    const settings = {};
    const isDebug = process.env.DEBUG === 'true';
    const debugLog = (msg) => {
      if (isDebug && context && context.log) {
        context.log(msg);
      }
    };
    debugLog('âš™ï¸ BÃ¶rjar lÃ¤sa booking_settings...');
    const settingsRes = await pool.query('SELECT key, value, value_type FROM booking_settings');
    debugLog(`ğŸ“¦ ${settingsRes.rows.length} instÃ¤llningar hÃ¤mtade`);
    for (const row of settingsRes.rows) {
      debugLog(`ğŸ”‘ ${row.key} = ${row.value} (${row.value_type})`);
      if (
        row.value_type === 'json' ||
        row.value_type === 'array' ||
        (typeof row.value_type === 'string' && /\[\]$/.test(row.value_type))
      ) {
        try {
          settings[row.key] = JSON.parse(typeof row.value === 'string' ? row.value : JSON.stringify(row.value));
        } catch (_) {}
      } else if (row.value_type === 'int') {
        settings[row.key] = parseInt(row.value);
      } else if (row.value_type === 'bool') {
        settings[row.key] = row.value === 'true' || row.value === true;
      } else if (row.value_type === 'string') {
        settings[row.key] = String(row.value).replace(/^"(.*)"$/, '$1');
      } else {
        settings[row.key] = row.value;
      }
    }
    debugLog('âœ… Alla instÃ¤llningar tolkade och klara');
    return settings;
  } catch (err) {
    context.log(`âš ï¸ Fel vid laddning av booking_settings: ${err.message}`);
    throw err;
  }
};
END: settingsLoader.js

====================
ğŸ“„ Fil: verifySettings.js
ğŸ“… Senast Ã¤ndrad: 2025-05-19 19:18:11
ğŸ“ Antal rader: 53
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 24 rader
ğŸ§  KomplexitetspoÃ¤ng: 8
ğŸ§ª TODO/FIXME: 0
====================
START: verifySettings.js


function verifyBookingSettings(settings, context) {
  const expected = {
    default_office_address: 'string',
    default_home_address: 'string',
    fallback_travel_time_minutes: 'number',
    buffer_between_meetings: 'number',
    default_meeting_length_atoffice: 'array',
    default_meeting_length_atclient: 'array',
    default_meeting_length_digital: 'array',
    meeting_types: 'array',
    block_weekends: 'boolean',
    open_time: 'string',
    close_time: 'string',
    lunch_start: 'string',
    lunch_end: 'string',
    travel_time_window_start: 'string',
    travel_time_window_end: 'string',
    require_approval: 'boolean',
    max_days_in_advance: 'number',
    max_weekly_booking_minutes: 'number',
    cache_ttl_minutes: 'number',
    allowed_atclient_meeting_days: 'array',
    timezone: 'string'
  };

  const issues = [];
  for (const [key, type] of Object.entries(expected)) {
    const val = settings[key];
    if (val === undefined || val === null || (key === 'timezone' && String(val).trim() === '')) {
      issues.push(`âŒ Saknar instÃ¤llning: ${key}`);
    } else if (key === 'allowed_atclient_meeting_days') {
      if (!Array.isArray(val) || !val.every(v => typeof v === 'string')) {
        issues.push(`âš ï¸ Typfel fÃ¶r ${key}: ska vara array av strÃ¤ngar`);
      }
    } else if (key === 'require_approval') {
      if (typeof val !== 'boolean') {
        issues.push(`âš ï¸ Typfel fÃ¶r ${key}: ska vara boolean`);
      }
    } else if (type === 'array' ? !Array.isArray(val) : typeof val !== type) {
      issues.push(`âš ï¸ Typfel fÃ¶r ${key}: har ${typeof val}, fÃ¶rvÃ¤ntade ${type}`);
    }
  }

  if (issues.length > 0) {
    const message = 'ğŸ›‘ Problem med booking_settings:\n' + issues.join('\n');
    context.log.warn(message);
    throw new Error(message);
  }
}

module.exports = verifyBookingSettings;
END: verifySettings.js

====================
ğŸ“„ Fil: pgPool.js
ğŸ“… Senast Ã¤ndrad: 2025-05-19 13:26:26
ğŸ“ Antal rader: 12
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 1 â€“ ["const { Pool } = require('pg');"]
ğŸ” LÃ¤ngsta funktion: 7 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: pgPool.js
const { Pool } = require('pg');

const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: { rejectUnauthorized: false }
});

module.exports = pool;
END: pgPool.js

====================
ğŸ“„ Fil: appleMaps.js
ğŸ“… Senast Ã¤ndrad: 2025-05-20 09:33:55
ğŸ“ Antal rader: 120
ğŸ§© Antal funktioner: 5
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ["const jwt = require('jsonwebtoken');", "const fetch = require('node-fetch');"]
ğŸ” LÃ¤ngsta funktion: 10 rader
ğŸ§  KomplexitetspoÃ¤ng: 9
ğŸ§ª TODO/FIXME: 0
====================
START: appleMaps.js
const jwt = require('jsonwebtoken');
const fetch = require('node-fetch');

async function getAppleMapsAccessToken(context) {
  try {
    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n');

    if (!privateKey) {
      throw new Error('Apple Maps private key saknas â€“ kontrollera APPLE_MAPS_PRIVATE_KEY');
    }

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context?.log?.('âš ï¸ Misslyckades hÃ¤mta Apple Maps token:', err.message);
    if (err.code === 'EAI_AGAIN') {
      context?.log?.('ğŸŒ DNS-fel (EAI_AGAIN) â€“ kunde inte nÃ¥ servern:', err.message);
    }
    return null;
  }
}


async function getTravelTimeInMinutes(origin, destination, departureTime, accessToken, context) {
  try {
    const url = `https://maps-api.apple.com/v1/directions?origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&departureTime=${encodeURIComponent(departureTime)}&transportType=automobile&includeTravelTimeBreakdown=true`;

    const res = await fetch(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });

    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`âŒ Apple Maps-directions misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const travelTimeSeconds = data.routes?.[0]?.expectedTravelTime;
    return travelTimeSeconds ? Math.ceil(travelTimeSeconds / 60) : null;
  } catch (err) {
    context?.log?.(`âŒ Fel vid directions-anrop: ${err.message}`);
    return null;
  }
}

async function getTravelTime(origin, destination, departureTime, context) {
  try {
    const token = await getAppleMapsAccessToken(context);
    if (!token) {
      context?.log?.('âš ï¸ Kunde inte hÃ¤mta Apple Maps-token');
      return null;
    }
    return await getTravelTimeInMinutes(origin, destination, departureTime, token, context);
  } catch (err) {
    context?.log?.(`âŒ Fel i getTravelTime: ${err.message}`);
    return null;
  }
}

async function safeGetTravelTime(origin, destination, departureTime, accessToken, context) {
  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', origin);
    url.searchParams.append('destination', destination);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', departureTime);

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 8000); // max 8s

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` },
      signal: controller.signal
    });

    clearTimeout(timeout);
    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`âŒ Apple Maps misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const seconds = data.routes?.[0]?.durationSeconds || data.routes?.[0]?.expectedTravelTime;
    return seconds ? Math.round(seconds / 60) : null;
  } catch (err) {
    context?.log?.(`âš ï¸ safeGetTravelTime error: ${err.message}`);
    return null;
  }
}

module.exports = {
  getAppleMapsAccessToken,
  getTravelTimeInMinutes,
  getTravelTime,
  safeGetTravelTime
};
END: appleMaps.js

====================
ğŸ“„ Fil: returnTravelVerifier.js
ğŸ“… Senast Ã¤ndrad: 2025-05-19 19:09:10
ğŸ“ Antal rader: 67
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 1 rader (1.5%)
ğŸ“¥ Imports: 1 â€“ ["const { URL } = require('url');"]
ğŸ” LÃ¤ngsta funktion: 2 rader
ğŸ§  KomplexitetspoÃ¤ng: 4
ğŸ§ª TODO/FIXME: 0
====================
START: returnTravelVerifier.js


const { URL } = require('url');

async function verifyReturnTravelFeasibility({
  previousBooking,
  contact,
  slotTime,
  settings,
  accessToken,
  db,
  context,
  travelCache
}) {
  const from = previousBooking.address || settings.default_office_address;
  const to = `${contact.metadata.address} ${contact.metadata.postal_code} ${contact.metadata.city}`;
  const prevEnd = new Date(previousBooking.end);

  if (from === to) {
    context.log(`ğŸ’¾ Returrestid Ã¤r 0 min (${from} â†’ ${to}) â€“ ingen cache behÃ¶vs`);
    return { isFeasible: true };
  }

  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', from);
    url.searchParams.append('destination', to);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', prevEnd.toISOString());

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` }
    });

    const data = await res.json();
    const returnMinutes = Math.round((data.routes?.[0]?.durationSeconds || 0) / 60);
    const arrivalTime = new Date(prevEnd.getTime() + returnMinutes * 60000);

    // Cache return time in memory and DB
    const hour = prevEnd.getUTCHours();
    const returnCacheKey = `${from}|${to}|${hour}`;
    travelCache.set(returnCacheKey, returnMinutes);
    if (from && to) {
      await db.query(`
        INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (from_address, to_address, hour)
        DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes
      `, [from, to, hour, returnMinutes]);
      context.log(`ğŸ’¾ Returrestid sparad: ${returnMinutes} min (${from} â†’ ${to} @ ${hour}:00)`);
    } else {
      context.log(`âš ï¸ Hoppar caching av retur â€“ saknar from_address (${from}) eller to_address (${to})`);
    }

    if (arrivalTime > slotTime) {
      context.log(`â›” Slot ${slotTime.toISOString()} avvisad â€“ retur frÃ¥n tidigare mÃ¶te hinner inte fram i tid (ankomst ${arrivalTime.toISOString()})`);
      return { isFeasible: false, reason: 'retur hinner inte fram', arrivalTime };
    }

    return { isFeasible: true };
  } catch (err) {
    context.log(`âš ï¸ Kunde inte verifiera returrestid frÃ¥n tidigare mÃ¶te: ${err.message}`);
    return { isFeasible: true }; // fail open
  }
}

module.exports = { verifyReturnTravelFeasibility };
END: returnTravelVerifier.js

====================
ğŸ“„ Fil: travelTimeResolver.js
ğŸ“… Senast Ã¤ndrad: 2025-05-20 08:25:28
ğŸ“ Antal rader: 61
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 2 rader
ğŸ§  KomplexitetspoÃ¤ng: 6
ğŸ§ª TODO/FIXME: 0
====================
START: travelTimeResolver.js
async function resolveTravelTime({ origin, destination, hour, db, accessToken, context }) {
  let travelTimeMin = 20;
  const cacheKey = `${origin}|${destination}|${hour}`;
  let cacheHit = false;
  let isFallback = false;

  if (!origin || !destination) {
    context.log(`âš ï¸ Kan inte berÃ¤kna restid â€“ origin eller destination saknas`);
    return { travelTimeMin, cacheHit: false, isFallback };
  }

  try {
    const cacheRes = await db.query(
      `SELECT travel_minutes, is_fallback FROM travel_time_cache WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
      [origin, destination, hour]
    );
    if (cacheRes.rows.length > 0) {
      travelTimeMin = cacheRes.rows[0].travel_minutes;
      isFallback = cacheRes.rows[0].is_fallback === true;
      cacheHit = true;
      context.log(`âš¡ Cache hit (db): ${origin} â†’ ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
    }
  } catch (err) {
    context.log(`âš ï¸ Kunde inte lÃ¤sa frÃ¥n travel_time_cache: ${err.message}`);
  }

  if (!cacheHit && accessToken) {
    try {
      const url = new URL('https://maps-api.apple.com/v1/directions');
      url.searchParams.append('origin', origin);
      url.searchParams.append('destination', destination);
      url.searchParams.append('transportType', 'automobile');
      url.searchParams.append('departureTime', new Date().toISOString());

      const res = await fetch(url.toString(), {
        headers: { Authorization: `Bearer ${accessToken}` }
      });
      const data = await res.json();
      const travelSeconds = data.routes?.[0]?.durationSeconds;
      if (travelSeconds) {
        travelTimeMin = Math.round(travelSeconds / 60);
        await db.query(
          `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes, is_fallback)
           VALUES ($1, $2, $3, $4, false)
           ON CONFLICT (from_address, to_address, hour)
           DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes, is_fallback = false`,
          [origin, destination, hour, travelTimeMin]
        );
        context.log(`ğŸ’¾ Sparade Apple Maps-restid i cache: ${origin} â†’ ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
      } else {
        context.log(`âš ï¸ Apple Maps-data saknas â€“ anvÃ¤nder fallback`);
      }
    } catch (err) {
      context.log(`âš ï¸ Fel vid Apple Maps-anrop: ${err.message}`);
    }
  }

  return { travelTimeMin, cacheHit, isFallback };
}

module.exports = { resolveTravelTime };
END: travelTimeResolver.js

====================
ğŸ“„ Fil: index.js
ğŸ“… Senast Ã¤ndrad: 2025-05-19 09:53:06
ğŸ“ Antal rader: 233
ğŸ§© Antal funktioner: 5
ğŸ’¬ KommentarstÃ¤ckning: 6 rader (2.6%)
ğŸ“¥ Imports: 3 â€“ ["const { Pool } = require('pg');", "const { v4: uuidv4 } = require('uuid');", "const fetch = require('node-fetch');"]
ğŸ” LÃ¤ngsta funktion: 8 rader
ğŸ§  KomplexitetspoÃ¤ng: 19
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const { Pool } = require('pg');
const { v4: uuidv4 } = require('uuid');

module.exports = async function (context, req) {
  const requiredFields = ['meeting_type', 'meeting_length', 'slot_iso'];
  const missing = requiredFields.filter(k => !req.body?.[k]);

  if (missing.length > 0) {
    context.res = { status: 400, body: { error: `Missing fields: ${missing.join(', ')}` } };
    return;
  }

  const { email, meeting_type, meeting_length, slot_iso, metadata = {} } = req.body;

  const parsedLength = parseInt(meeting_length, 10);
  if (isNaN(parsedLength) || parsedLength <= 0) {
    context.res = { status: 400, body: { error: "Invalid meeting_length" } };
    return;
  }

  const parsedStart = new Date(slot_iso);
  if (isNaN(parsedStart.getTime())) {
    context.res = { status: 400, body: { error: "Invalid slot_iso datetime" } };
    return;
  }

  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.res = { status: 500, body: { error: `Missing environment variable: ${key}` } };
      return;
    }
  }

  const pool = new Pool({
    user: process.env.PGUSER,
    host: process.env.PGHOST,
    database: process.env.PGDATABASE,
    password: process.env.PGPASSWORD,
    port: parseInt(process.env.PGPORT || '5432', 10),
    ssl: { rejectUnauthorized: false }
  });

  const db = await pool.connect();
  try {
    // LÃ¤s in booking_settings
    const settingsRes = await db.query('SELECT key, value, value_type FROM booking_settings');
    const settings = {};
    for (const row of settingsRes.rows) {
      let val = row.value;
      if (row.value_type === 'int') {
        val = parseInt(val);
      } else if (row.value_type === 'bool') {
        val = val === 'true' || val === true;
      } else if (row.value_type === 'json' || row.value_type === 'array') {
        try {
          val = JSON.parse(typeof val === 'string' ? val : JSON.stringify(val));
        } catch (_) {}
      } else if (typeof val === 'string') {
        val = val.replace(/^"(.*)"$/, '$1'); // trimma citattecken
      }
      settings[row.key] = val;
    }

    const id = uuidv4();
    // Kontrollera om en bokning redan finns
    const existing = await db.query(
      'SELECT id FROM bookings WHERE contact_id = $1 AND start_time = $2',
      [metadata.contact_id || null, parsedStart.toISOString()]
    );
    if (existing.rowCount > 0) {
      context.res = {
        status: 409,
        body: { error: 'Booking already exists for this time.' }
      };
      return;
    }
    const startTime = parsedStart;
    const endTime = new Date(startTime.getTime() + parsedLength * 60000);
    const created_at = new Date();
    const updated_at = created_at;

    // Bygg meeting_link dynamiskt
    let meeting_link = null;
    if (meeting_type.toLowerCase() === 'teams') {
      meeting_link = 'https://teams.microsoft.com/l/meetup-join/...'; // placeholder
    } else if (meeting_type.toLowerCase() === 'zoom') {
      meeting_link = 'https://zoom.us/j/1234567890'; // placeholder
    } else if (meeting_type.toLowerCase() === 'facetime' && metadata.phone) {
      meeting_link = `facetime:${metadata.phone}`;
    }

    const fields = {
      id,
      start_time: startTime.toISOString(),
      end_time: endTime.toISOString(),
      meeting_type,
      metadata: JSON.stringify(metadata),
      created_at,
      updated_at,
      contact_id: metadata.contact_id || null,
      booking_email: email || null
    };

    const query = `
      INSERT INTO bookings (
        id, start_time, end_time, meeting_type,
        metadata, created_at, updated_at,
        contact_id, booking_email
      ) VALUES (
        $1, $2, $3, $4,
        $5, $6, $7,
        $8, $9
      )
    `;

    const values = Object.values(fields);
    await db.query(query, values);
    // Logga pending change fÃ¶r denna bokning
    await db.query(
      `INSERT INTO pending_changes (id, table_name, record_id, change_type, direction, processed, created_at, booking_id)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        uuidv4(),
        'bookings',
        id,
        'INSERT',
        'cloud_to_local',
        false,
        new Date(),
        id
      ]
    );
    // Simulera att kalendern synkades fÃ¶r denna demo
    fields.synced_to_calendar = true;
    await db.query(
      'INSERT INTO event_log (event_type, booking_id) VALUES ($1, $2)',
      ['booking_created', id]
    );

    context.res = {
      status: 200,
      body: {
        status: 'booked',
        booking_id: id,
        calendar_invite_sent: false // kan uppdateras om Graph-mail lÃ¤ggs in hÃ¤r
      }
    };
  } catch (err) {
    context.res = {
      status: 500,
      body: { error: err.message }
    };
  } finally {
    db.release();
  }
};

// --- Send confirmation email via Microsoft Graph ---
const fetch = require('node-fetch');

async function sendConfirmationEmail({ to, startTime, endTime, meeting_type, meeting_link, first_name, sender_email }) {
  const token = await getGraphAccessToken();

  const subject = `Din bokning Ã¤r bekrÃ¤ftad â€“ ${meeting_type}`;
  const content = `
    <p>Hej ${first_name || ''},</p>
    <p>Din bokning den ${startTime.toLocaleDateString()} kl ${startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} Ã¤r nu bekrÃ¤ftad.</p>
    <p><strong>MÃ¶testyp:</strong> ${meeting_type}</p>
    <p><strong>LÃ¤nk:</strong> <a href="${meeting_link}">${meeting_link}</a></p>
    <p>Vi ser fram emot att ses!</p>
    <p>VÃ¤nligen,<br/>Daniel</p>
  `;

  const body = {
    message: {
      subject,
      body: {
        contentType: 'HTML',
        content
      },
      toRecipients: [
        {
          emailAddress: {
            address: to
          }
        }
      ]
    },
    saveToSentItems: true
  };

  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 8000); // max 8s

  const response = await fetch(`https://graph.microsoft.com/v1.0/users/${encodeURIComponent(sender_email)}/sendMail`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body),
    signal: controller.signal
  });

  clearTimeout(timeout);

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`E-postmisslyckande: ${err}`);
  }
}

async function getGraphAccessToken() {
  const params = new URLSearchParams();
  params.append('client_id', process.env.GRAPH_CLIENT_ID);
  params.append('client_secret', process.env.GRAPH_CLIENT_SECRET);
  params.append('scope', 'https://graph.microsoft.com/.default');
  params.append('grant_type', 'client_credentials');
  const response = await fetch(`https://login.microsoftonline.com/${process.env.GRAPH_TENANT_ID}/oauth2/v2.0/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: params
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`Misslyckad tokenhÃ¤mtning: ${err}`);
  }

  const data = await response.json();
  return data.access_token;
}
END: index.js

====================
ğŸ“„ Fil: debugLogger.js
ğŸ“… Senast Ã¤ndrad: 2025-05-20 07:58:57
ğŸ“ Antal rader: 23
ğŸ§© Antal funktioner: 2
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 8 rader
ğŸ§  KomplexitetspoÃ¤ng: 2
ğŸ§ª TODO/FIXME: 0
====================
START: debugLogger.js


function createDebugLogger(context) {
  const isDebug = process.env.DEBUG === 'true';
  const skipReasons = {};

  const debugLog = (msg) => {
    if (msg.startsWith('â›”') || msg.startsWith('ğŸ½ï¸') || msg.startsWith('ğŸ“›')) {
      const reason = msg.split(' â€“ ')[0];
      skipReasons[reason] = (skipReasons[reason] || 0) + 1;
    }
    if (isDebug && context?.log) {
      context.log(msg);
    }
  };

  return {
    debugLog,
    getSkipSummary: () => skipReasons
  };
}

module.exports = { createDebugLogger };
END: debugLogger.js

====================
ğŸ“„ Fil: slotEngine.js
ğŸ“… Senast Ã¤ndrad: 2025-05-20 08:58:06
ğŸ“ Antal rader: 149
ğŸ§© Antal funktioner: 4
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 6 â€“ ["const pool = require('../db/pgPool');", 'const { DateTime } = require("luxon");', 'const { resolveOriginAddress } = require("../calendar/resolveOrigin");', 'const { resolveTravelTime } = require("../maps/travelTimeResolver");', 'const msGraph = require("../calendar/msGraph");', 'const appleCalendar = require("../calendar/appleCalendar");']
ğŸ” LÃ¤ngsta funktion: 9 rader
ğŸ§  KomplexitetspoÃ¤ng: 11
ğŸ§ª TODO/FIXME: 0
====================
START: slotEngine.js


const pool = require('../db/pgPool');

const { DateTime } = require("luxon");
const { resolveOriginAddress } = require("../calendar/resolveOrigin");
const { resolveTravelTime } = require("../maps/travelTimeResolver");
const msGraph = require("../calendar/msGraph");
const appleCalendar = require("../calendar/appleCalendar");

async function generateSlotCandidates({ day, settings, contact, pool, context }) {
  const timezone = settings.timezone || "Europe/Stockholm";
  const hoursToTry = [10, 14];
  const slots = [];

  for (const hour of hoursToTry) {
    const eventId = `${day}T${hour.toString().padStart(2, "0")}:00:00.000Z`;
    const dateObj = new Date(eventId);
    const weekday = dateObj.toLocaleDateString("en-US", { weekday: "long", timeZone: timezone }).toLowerCase();
    const slot_part = hour < 12 ? "fm" : "em";

    const originInfo = await resolveOriginAddress({
      eventId,
      calendarId: contact.contact_id,
      pool,
      context,
      graphClient: msGraph,
      appleClient: appleCalendar,
      fallbackOrigin: settings.default_home_address,
      settings
    });

    if (!originInfo?.origin) {
      context.log(`âš ï¸ Kunde inte faststÃ¤lla origin fÃ¶r ${eventId}`);
      continue;
    }

    const destination = settings.default_office_address;
    const { travelTimeMin } = await resolveTravelTime({
      origin: originInfo.origin,
      destination,
      hour,
      db: pool,
      accessToken: context.accessToken || null,
      context
    });

    if (!travelTimeMin || typeof travelTimeMin !== "number") {
      context.log.warn(`âš ï¸ Ogiltig restid, hoppar slot: ${eventId}`);
      continue;
    }

    slots.push({
      slot_iso: eventId,
      slot_local: DateTime.fromJSDate(dateObj).setZone(timezone).toISO(),
      travel_time_min: travelTimeMin,
      origin: originInfo.origin,
      originEndTime: originInfo.originEndTime,
      source: originInfo.originSource,
      require_approval: settings.require_approval,
      meeting_length: settings.default_meeting_length_digital?.[0] || 20,
      weekday,
      slot_part
    });
  }

  return slots;
}


async function generateSlotChunks({
  days,
  context,
  contact,
  contact_id,
  meeting_type,
  meeting_length,
  bookingsByDay,
  weeklyMinutesByType,
  settings,
  graphClient,
  appleClient,
  travelCache,
  accessToken,
  timezone,
  debugHelper
}) {
  const { debugLog, skipReasons } = debugHelper || {};
  const slotMap = {};
  const chosen = [];

  if (days.length === 0) {
    const fallbackDate = new Date().toISOString().split('T')[0];
    const { rows } = await pool.query(
      'SELECT slots FROM slot_cache WHERE slot_day = $1 LIMIT 1',
      [fallbackDate]
    );
    if (rows.length > 0) {
      context.log(`ğŸŸ¡ AnvÃ¤nder slot_cache som fallback (${fallbackDate})`);
      return {
        chosenSlots: rows[0].slots || [],
        slotMapResult: {},
        slotLogSummary: { 'fallback_used': 1 }
      };
    }
  }

  for (const day of days) {
    const dayStr = day.toISOString().split("T")[0];
    const slotCandidates = await generateSlotCandidates({
      day: dayStr,
      settings,
      contact,
      pool: context.db || context.pool,
      context
    });

    for (const slot of slotCandidates) {
      const key = `${dayStr}_${slot.slot_part}`;
      if (!slotMap[key]) slotMap[key] = [];
      slotMap[key].push(slot);
    }
  }

  for (const [key, candidates] of Object.entries(slotMap)) {
    if (candidates.length === 0) continue;

    const alreadyPicked = slotGroupPicked[key];
    if (alreadyPicked) {
      debugLog?.(`ğŸŸ¡ Slotgrupp '${key}' redan vald tidigare â€“ hoppar`);
      continue;
    }

    const best = candidates.sort((a, b) => (b.score || 0) - (a.score || 0))[0] || candidates[0];
    slotGroupPicked[key] = true;
    chosen.push(best);
  }

  return {
    chosenSlots: chosen.sort((a, b) => new Date(a.slot_iso) - new Date(b.slot_iso)),
    slotMapResult: slotMap,
    slotLogSummary: skipReasons
  };
}

module.exports = {
  generateSlotCandidates,
  generateSlotChunks
};
END: slotEngine.js

ğŸ“ JSON-KONFIGURATIONER (function.json / host.json)
====================================

- bookings/function.json
- getavailableslots/function.json
- host.json
- meeting_types/function.json
- refreshCalendarOrigins/function.json
- refreshTravelTimes/function.json
- validate_contact/function.json

ğŸ“Š MOLNDATABAS (Azure) â€“ STRUKTUR & INNEHÃ…LL
====================================

ğŸ“ Tabell: available_slots_cache
  â€¢ id (uuid)
  â€¢ travel_time_min (integer)
  â€¢ generated_at (timestamp without time zone)
  â€¢ expires_at (timestamp without time zone)
  â€¢ meeting_length (integer)
  â€¢ slot_day (date)
  â€¢ slot_score (integer)
  â€¢ meeting_type (text)
  â€¢ slot_part (text)
  â€¢ slot_iso (text)
  ğŸ”‘ [p] available_slots_cache_pkey: PRIMARY KEY (id)

ğŸ“ Tabell: slot_cache
  â€¢ created_at (timestamp without time zone)
  â€¢ slot_day (date)
  â€¢ slots (jsonb)
  â€¢ id (uuid)
  â€¢ meeting_length (integer)
  â€¢ booking_email (text)
  â€¢ meeting_type (text)
  â€¢ slot_part (text)
  ğŸ”‘ [p] slot_cache_pkey: PRIMARY KEY (id)

ğŸ“ Tabell: calendar_origin_cache
  â€¢ created_at (timestamp without time zone)
  â€¢ timestamp (timestamp with time zone)
  â€¢ event_date (date)
  â€¢ id (integer)
  â€¢ end_time (timestamp without time zone)
  â€¢ address (text)
  â€¢ source (text)
  ğŸ”‘ [c] calendar_origin_cache_source_check: CHECK ((source = ANY (ARRAY['Apple Calendar'::text, 'Microsoft 365'::text])))
  ğŸ”‘ [p] calendar_origin_cache_pkey: PRIMARY KEY (id)

ğŸ“ Tabell: travel_time_cache
  â€¢ hour (integer)
  â€¢ travel_minutes (integer)
  â€¢ created_at (timestamp with time zone)
  â€¢ updated_at (timestamp with time zone)
  â€¢ from_address (text)
  â€¢ to_address (text)
  ğŸ”‘ [u] unique_travel_key: UNIQUE (from_address, to_address, hour)
  ğŸ§ª Topp 5 rader:
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=12, travel_minutes=20, created_at=2025-05-19 08:35:30.341217+00:00, updated_at=2025-05-19 08:35:30.341217+00:00
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=8, travel_minutes=22, created_at=2025-05-19 08:51:46.047719+00:00, updated_at=2025-05-19 08:51:46.047719+00:00
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=10, travel_minutes=23, created_at=2025-05-19 12:00:01.057723+00:00, updated_at=2025-05-19 12:00:01.057723+00:00
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=14, travel_minutes=23, created_at=2025-05-19 12:00:01.639717+00:00, updated_at=2025-05-19 12:00:01.639717+00:00

ğŸ“ Tabell: event_log
  â€¢ received_at (timestamp with time zone)
  â€¢ record_id (uuid)
  â€¢ timestamp (timestamp with time zone)
  â€¢ booking_id (uuid)
  â€¢ id (uuid)
  â€¢ payload (jsonb)
  â€¢ action (text)
  â€¢ event_type (text)
  â€¢ source (text)
  â€¢ table_name (text)
  ğŸ”‘ [p] event_log_pkey: PRIMARY KEY (id)
  ğŸ§ª Topp 5 rader:
    - source=None, event_type=None, payload=None, received_at=2025-05-16 09:40:53.307336+00:00, id=903c2758-e7e6-4f11-9a31-1871596e195c, action=INSERT, table_name=contact, record_id=c4e2d9dd-545e-4e05-99fe-16d377a87698, timestamp=2025-05-16 09:40:53.307336+00:00, booking_id=None
    - source=None, event_type=booking_created, payload=None, received_at=2025-05-18 11:56:16.897217+00:00, id=fb33d0d1-ff78-4506-82dd-026fd86cd781, action=None, table_name=None, record_id=None, timestamp=2025-05-18 11:56:16.897217+00:00, booking_id=fb6b2112-8dbf-4bed-aba4-c2882989db21
    - source=None, event_type=booking_created, payload=None, received_at=2025-05-18 12:06:54.686150+00:00, id=89690767-0414-4c48-b61d-8f9d350718e5, action=None, table_name=None, record_id=None, timestamp=2025-05-18 12:06:54.686150+00:00, booking_id=3ecff74d-cb9c-4e9f-9db5-b0a7b12666ee
    - source=None, event_type=None, payload=None, received_at=2025-05-18 12:32:42.290134+00:00, id=420ca821-9117-46b4-b9cb-6eedef51f4cb, action=INSERT, table_name=contact, record_id=14e1bef9-2833-40d5-b4fe-7576f7cffd6c, timestamp=2025-05-18 12:32:42.290134+00:00, booking_id=None
    - source=None, event_type=None, payload=None, received_at=2025-05-18 12:37:08.028330+00:00, id=931849cb-3a69-4861-83ba-258fe1de5e98, action=UPDATE, table_name=contact, record_id=14e1bef9-2833-40d5-b4fe-7576f7cffd6c, timestamp=2025-05-18 12:37:08.028330+00:00, booking_id=None

ğŸ“ Tabell: bookings
  â€¢ start_time (timestamp with time zone)
  â€¢ end_time (timestamp with time zone)
  â€¢ id (uuid)
  â€¢ updated_at (timestamp with time zone)
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp with time zone)
  â€¢ contact_id (uuid)
  â€¢ meeting_type (text)
  â€¢ booking_email (text)
  ğŸ”‘ [p] bookings_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] fk_bookings_contact: FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE SET NULL
  ğŸ§ª Topp 5 rader:
    - start_time=2025-05-20 08:00:00+00:00, end_time=2025-05-20 08:20:00+00:00, meeting_type=facetime, metadata={}, created_at=2025-05-18 10:48:56.390000+00:00, contact_id=None, id=378a6541-8e61-465d-a37d-6242ba770dc7, updated_at=2025-05-18 10:48:56.390000+00:00, booking_email=None
    - start_time=2025-05-20 12:00:00+00:00, end_time=2025-05-20 12:20:00+00:00, meeting_type=facetime, metadata={}, created_at=2025-05-18 11:12:10.769000+00:00, contact_id=None, id=f861a2c5-f1ca-4f00-91af-276bac7f326d, updated_at=2025-05-18 11:12:10.769000+00:00, booking_email=None
    - start_time=2025-05-20 12:00:00+00:00, end_time=2025-05-20 12:20:00+00:00, meeting_type=facetime, metadata={}, created_at=2025-05-18 11:13:04.323000+00:00, contact_id=None, id=feccbea8-6a8f-44d8-9f9d-cf468b55bc0c, updated_at=2025-05-18 11:13:04.323000+00:00, booking_email=None
    - start_time=2025-05-20 12:00:00+00:00, end_time=2025-05-20 12:20:00+00:00, meeting_type=facetime, metadata={}, created_at=2025-05-18 11:13:07.009000+00:00, contact_id=None, id=40f2b6ab-51ba-4c50-844c-6d9ff3db52d2, updated_at=2025-05-18 11:13:07.009000+00:00, booking_email=None
    - start_time=2025-05-21 08:00:00+00:00, end_time=2025-05-21 08:20:00+00:00, meeting_type=facetime, metadata={}, created_at=2025-05-18 11:29:28.739000+00:00, contact_id=None, id=4c0d2868-f99d-4156-b92e-4e7a97fd1153, updated_at=2025-05-18 11:29:28.739000+00:00, booking_email=None

ğŸ“ Tabell: pending_changes
  â€¢ booking_id (uuid)
  â€¢ processed (boolean)
  â€¢ created_at (timestamp with time zone)
  â€¢ payload (jsonb)
  â€¢ id (uuid)
  â€¢ record_id (uuid)
  â€¢ table_name (text)
  â€¢ operation (text)
  â€¢ change_type (text)
  â€¢ direction (text)
  ğŸ”‘ [p] pending_changes_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] fk_pending_changes_booking_id: FOREIGN KEY (booking_id) REFERENCES bookings(id) ON DELETE CASCADE
  ğŸ§ª Topp 5 rader:
    - id=7d417b09-6288-490b-a73c-3f3b2792817e, table_name=contact, record_id=c4e2d9dd-545e-4e05-99fe-16d377a87698, change_type=INSERT, direction=out, processed=False, created_at=2025-05-16 09:40:53.307336+00:00, operation=INSERT, payload={'id': 'c4e2d9dd-545e-4e05-99fe-16d377a87698', 'email': None, 'metadata': {'city': '', 'phone': '0709561480', 'address': '', 'company': 'AnyNode', 'country': '', 'last_name': 'KÃ¤llberg', 'first_name': 'Daniel', 'postal_code': ''}, 'created_at': '2025-05-16T09:40:53.307336+00:00', 'updated_at': '2025-05-16T09:40:53.307336+00:00', 'booking_email': 'daniel@anynode.se'}, booking_id=None
    - id=6463cae5-e1e8-4899-903b-feccaf981229, table_name=bookings, record_id=378a6541-8e61-465d-a37d-6242ba770dc7, change_type=INSERT, direction=out, processed=False, created_at=2025-05-18 10:48:56.394310+00:00, operation=INSERT, payload={'id': '378a6541-8e61-465d-a37d-6242ba770dc7', 'end_time': '2025-05-20T08:20:00+00:00', 'metadata': {}, 'contact_id': None, 'created_at': '2025-05-18T10:48:56.39+00:00', 'start_time': '2025-05-20T08:00:00+00:00', 'updated_at': '2025-05-18T10:48:56.39+00:00', 'meeting_type': 'facetime', 'booking_email': None}, booking_id=378a6541-8e61-465d-a37d-6242ba770dc7
    - id=62176d8e-90ff-48d9-bfe6-9375995dede3, table_name=bookings, record_id=378a6541-8e61-465d-a37d-6242ba770dc7, change_type=INSERT, direction=cloud_to_local, processed=False, created_at=2025-05-18 10:48:56.440000+00:00, operation=None, payload=None, booking_id=378a6541-8e61-465d-a37d-6242ba770dc7
    - id=c6553a94-29ae-4721-b381-898f78f0d67c, table_name=bookings, record_id=f861a2c5-f1ca-4f00-91af-276bac7f326d, change_type=INSERT, direction=out, processed=False, created_at=2025-05-18 11:12:10.772513+00:00, operation=INSERT, payload={'id': 'f861a2c5-f1ca-4f00-91af-276bac7f326d', 'end_time': '2025-05-20T12:20:00+00:00', 'metadata': {}, 'contact_id': None, 'created_at': '2025-05-18T11:12:10.769+00:00', 'start_time': '2025-05-20T12:00:00+00:00', 'updated_at': '2025-05-18T11:12:10.769+00:00', 'meeting_type': 'facetime', 'booking_email': None}, booking_id=f861a2c5-f1ca-4f00-91af-276bac7f326d
    - id=4d1006a6-2ff8-4c60-a573-e2091d5d3917, table_name=bookings, record_id=f861a2c5-f1ca-4f00-91af-276bac7f326d, change_type=INSERT, direction=cloud_to_local, processed=False, created_at=2025-05-18 11:12:10.803000+00:00, operation=None, payload=None, booking_id=f861a2c5-f1ca-4f00-91af-276bac7f326d

ğŸ“ Tabell: contact
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp with time zone)
  â€¢ id (uuid)
  â€¢ updated_at (timestamp with time zone)
  â€¢ booking_email (text)
  â€¢ email (text)
  ğŸ”‘ [p] contact_pkey: PRIMARY KEY (id)
  ğŸ§ª Topp 5 rader:
    - metadata={'city': '', 'phone': '0709561480', 'address': '', 'company': 'AnyNode', 'country': '', 'last_name': 'KÃ¤llberg', 'first_name': 'Daniel', 'postal_code': ''}, created_at=2025-05-16 09:40:53.307336+00:00, id=c4e2d9dd-545e-4e05-99fe-16d377a87698, booking_email=daniel@anynode.se, updated_at=2025-05-16 09:40:53.307336+00:00, email=None
    - metadata={'city': 'Stockholm', 'address': 'Maria Skolgata 79A', 'postal_code': '118 53'}, created_at=2025-05-18 12:32:42.290134+00:00, id=14e1bef9-2833-40d5-b4fe-7576f7cffd6c, booking_email=None, updated_at=2025-05-18 12:32:42.290134+00:00, email=daniel@anynode.se

ğŸ“ Tabell: booking_settings
  â€¢ value (jsonb)
  â€¢ updated_at (timestamp with time zone)
  â€¢ key (text)
  â€¢ value_type (text)
  ğŸ§ª Topp 5 rader:
    - key=max_days_in_advance, value=30, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=buffer_between_meetings, value=15, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=max_weekly_booking_minutes, value=360, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=default_office_address, value=Maria Skolgata 79A, 118 53 Stockholm, value_type=string, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=fallback_travel_time_minutes, value=90, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00

ğŸ“ Tabell: translation
  â€¢ key (character varying)
  â€¢ sv (text)
  â€¢ en (text)
  ğŸ§ª Topp 5 rader:
    - key=error_min_duration_fysiskt_kund, sv=MÃ¶testiden fÃ¶r 'Fysiskt hos kund' mÃ¥ste vara minst {{minutes}} minuter. Du visste det redan., en=The meeting time for 'On-site at customer' must be at least {{minutes}} minutes. You knew that.
    - key=error_min_duration_fysiskt_mig, sv=MÃ¶testiden fÃ¶r 'Fysiskt hos mig' mÃ¥ste vara minst {{minutes}} minuter. Annars hinner vi bara sÃ¤ga hej., en=The meeting time for 'At my office' must be at least {{minutes}} minutes. Otherwise, weâ€™ll only have time to say hello.
    - key=email_body_booking_received, sv=Hej {{name}}! Vi har tagit emot din bokning fÃ¶r {{meeting_type}} mellan {{start_time}} och {{end_time}}. Ingen panik â€“ vi Ã¥terkommer med bekrÃ¤ftelse. / Daniel, en=Hello {{name}}, Weâ€™ve received your booking for {{meeting_type}} between {{start_time}} and {{end_time}}. No need to panic â€“ weâ€™ll confirm shortly. / Daniel
    - key=email_body_booking_confirmed, sv=Hej {{name}}! Din bokning fÃ¶r {{meeting_type}} mellan {{start_time}} och {{end_time}} Ã¤r nu spikad. Ser fram emot det! / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} is now locked in. Looking forward! / Daniel
    - key=email_body_booking_cancelled, sv=Hej {{name}}! Din bokning fÃ¶r {{meeting_type}} mellan {{start_time}} och {{end_time}} Ã¤r avbokad. HÃ¶r av dig om du vill hitta en ny tid. / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} has been cancelled. Let me know if you'd like a new one. / Daniel

