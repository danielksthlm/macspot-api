📂 KODTRÄD
==========
├── local_backend
│   ├── __init__.py
│   ├── config.py
│   ├── main.py
│   ├── modules
│   │   ├── __init__.py
│   │   ├── accounting
│   │   │   ├── __init__.py
│   │   │   ├── accounts_payable
│   │   │   │   ├── __init__.py
│   │   │   │   ├── routes.py
│   │   │   │   ├── services.py
│   │   │   ├── base
│   │   │   │   ├── __init__.py
│   │   │   │   ├── export.py
│   │   │   │   ├── routes.py
│   │   │   │   ├── schemas.py
│   │   │   │   ├── services.py
│   │   │   │   ├── suggest_accounting.py
│   │   │   ├── closing
│   │   │   │   ├── __init__.py
│   │   │   │   ├── routes.py
│   │   │   │   ├── services.py
│   │   │   ├── invoicing
│   │   │   │   ├── __init__.py
│   │   │   │   ├── routes.py
│   │   │   │   ├── services.py
│   │   │   ├── tax_reporting
│   │   │   │   ├── __init__.py
│   │   │   │   ├── routes.py
│   │   │   │   ├── services.py
│   │   ├── crm
│   │   │   ├── __init__.py
│   │   │   ├── routes.py
│   │   │   ├── services.py
==========

====================
📄 Fil: config.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 09:23:13
📏 Antal rader: 9
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 1 – ['import os']
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: config.py
import os
from dotenv import load_dotenv
from pathlib import Path

# Ladda .env från projektroten
env_path = Path(__file__).resolve().parents[2] / ".env"
load_dotenv(dotenv_path=env_path)

DB_DSN = os.getenv("LOCAL_DB_DSN")  # alt. bygg ihop från PGHOST, etc
END: config.py

====================
📄 Fil: __init__.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:33:00
📏 Antal rader: 1
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: __init__.py
# __init__.py för local_backend

END: __init__.py

====================
📄 Fil: main.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:26:28
📏 Antal rader: 59
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 1 – ['import os']
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 3
🧪 TODO/FIXME: 0
====================
START: main.py
from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi
from fastapi.security import APIKeyHeader
from fastapi.middleware.cors import CORSMiddleware
import os
from dotenv import load_dotenv
load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), "..", ".env"))

# Routers från olika moduler
from local_backend.modules.crm.routes import router as crm_router
from local_backend.modules.accounting.base.routes import router as base_accounting_router
from local_backend.modules.accounting.tax_reporting.routes import router as tax_router
from local_backend.modules.accounting.closing.routes import router as closing_router
from local_backend.modules.accounting.invoicing.routes import router as invoicing_router
from local_backend.modules.accounting.accounts_payable.routes import router as payable_router

app = FastAPI()

api_key_header = APIKeyHeader(name="Authorization")

def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="MacSpot API",
        version="1.0.0",
        description="Redovisnings-API med autentisering",
        routes=app.routes,
    )
    openapi_schema["components"]["securitySchemes"] = {
        "APIKeyHeader": {
            "type": "apiKey",
            "in": "header",
            "name": "Authorization"
        }
    }
    for path in openapi_schema["paths"].values():
        for op in path.values():
            op.setdefault("security", []).append({"APIKeyHeader": []})
    app.openapi_schema = openapi_schema
    return openapi_schema

app.openapi = custom_openapi

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Inkludera routers
app.include_router(crm_router)
app.include_router(base_accounting_router)
app.include_router(tax_router)
app.include_router(closing_router)
app.include_router(invoicing_router)
app.include_router(payable_router)
END: main.py

====================
📄 Fil: modules/__init__.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:33:00
📏 Antal rader: 1
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: __init__.py
# __init__.py för local_backend/modules

END: __init__.py

====================
📄 Fil: modules/accounting/__init__.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:33:00
📏 Antal rader: 1
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: __init__.py
# __init__.py för local_backend/modules/accounting

END: __init__.py

====================
📄 Fil: modules/accounting/tax_reporting/services.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:51:34
📏 Antal rader: 21
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 1 – ['import asyncpg']
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 2
🧪 TODO/FIXME: 0
====================
START: services.py
import asyncpg

async def generate_tax_report(db_url: str, year: int, month: int):
    conn = await asyncpg.connect(dsn=db_url)
    try:
        rows = await conn.fetch("""
            SELECT
                a.number AS account,
                a.name AS account_name,
                SUM(e.amount) AS total
            FROM entry e
            JOIN account a ON e.account_id = a.id
            WHERE EXTRACT(YEAR FROM e.created_at) = $1
              AND EXTRACT(MONTH FROM e.created_at) = $2
              AND a.number LIKE '26%'  -- momsrelaterade konton
            GROUP BY a.number, a.name
            ORDER BY a.number
        """, year, month)
        return [dict(r) for r in rows]
    finally:
        await conn.close()
END: services.py

====================
📄 Fil: modules/accounting/tax_reporting/__init__.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:33:00
📏 Antal rader: 1
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: __init__.py
# __init__.py för local_backend/modules/accounting/tax_reporting

END: __init__.py

====================
📄 Fil: modules/accounting/tax_reporting/routes.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:51:35
📏 Antal rader: 12
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 1 – ['import os']
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 1
🧪 TODO/FIXME: 0
====================
START: routes.py
from fastapi import APIRouter, Depends, Query
from fastapi.responses import JSONResponse
import os
from .services import generate_tax_report

router = APIRouter(prefix="/tax_reporting", tags=["tax_reporting"])

@router.get("/report", dependencies=[Depends(lambda: None)])  # Placeholder for auth
async def get_tax_report(year: int = Query(...), month: int = Query(...)):
    db_url = os.environ["LOCAL_DB_URL"]
    result = await generate_tax_report(db_url, year, month)
    return JSONResponse(content={"status": "ok", "report": result})
END: routes.py

====================
📄 Fil: modules/accounting/accounts_payable/services.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:50:16
📏 Antal rader: 14
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 2 – ['import asyncpg', 'import os']
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 1
🧪 TODO/FIXME: 0
====================
START: services.py
import asyncpg
import os

async def get_open_invoices():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT id, supplier, due_date, amount, status
        FROM invoice
        WHERE status = 'unpaid'
        ORDER BY due_date ASC
    """)
    await conn.close()
    return [dict(row) for row in rows]
END: services.py

====================
📄 Fil: modules/accounting/accounts_payable/__init__.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:33:00
📏 Antal rader: 1
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: __init__.py
# __init__.py för local_backend/modules/accounting/accounts_payable

END: __init__.py

====================
📄 Fil: modules/accounting/accounts_payable/routes.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:50:16
📏 Antal rader: 8
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: routes.py
from fastapi import APIRouter

router = APIRouter(prefix="/accounts_payable", tags=["Accounts Payable"])

@router.get("/open_invoices")
async def list_open_invoices():
    from .services import get_open_invoices
    return await get_open_invoices()
END: routes.py

====================
📄 Fil: modules/accounting/invoicing/services.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:49:29
📏 Antal rader: 13
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: services.py
from datetime import date
from uuid import uuid4

async def generate_invoice():
    return {
        "invoice_id": str(uuid4()),
        "date": date.today().isoformat(),
        "total": 2500.00,
        "currency": "SEK",
        "items": [
            {"description": "Konsulttjänster maj", "quantity": 10, "unit_price": 250.00}
        ]
    }
END: services.py

====================
📄 Fil: modules/accounting/invoicing/__init__.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:33:00
📏 Antal rader: 1
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: __init__.py
# __init__.py för local_backend/modules/accounting/invoicing

END: __init__.py

====================
📄 Fil: modules/accounting/invoicing/routes.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:49:28
📏 Antal rader: 10
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: routes.py
from fastapi import APIRouter
from .services import generate_invoice
from fastapi.responses import JSONResponse

router = APIRouter(prefix="/invoicing", tags=["invoicing"])

@router.get("/generate_invoice")
async def generate_invoice_route():
    invoice = await generate_invoice()
    return JSONResponse(content={"status": "ok", "invoice": invoice})
END: routes.py

====================
📄 Fil: modules/accounting/closing/services.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:46:55
📏 Antal rader: 31
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 2 – ['import asyncpg', 'import os']
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 1
🧪 TODO/FIXME: 0
====================
START: services.py
import asyncpg
import os
from datetime import date, timedelta

async def lock_period_service():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    today = date.today()
    result = await conn.execute("""
        UPDATE period
        SET locked = true
        WHERE end_date < $1 AND locked = false
    """, today)
    await conn.close()
    return f"Perioder låsta: {result}"

async def perform_year_end_closing():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    latest = await conn.fetchrow("SELECT end_date FROM period ORDER BY end_date DESC LIMIT 1")
    if not latest:
        await conn.close()
        return "Ingen tidigare period hittades"
    new_start = latest["end_date"] + timedelta(days=1)
    new_end = new_start.replace(year=new_start.year + 1) - timedelta(days=1)
    await conn.execute("""
        INSERT INTO period (id, start_date, end_date, locked, name, created_at)
        VALUES (gen_random_uuid(), $1, $2, false, $3, now())
    """, new_start, new_end, f"{new_start.year}")
    await conn.close()
    return f"Ny period skapad: {new_start} – {new_end}"
END: services.py

====================
📄 Fil: modules/accounting/closing/__init__.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:33:00
📏 Antal rader: 1
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: __init__.py
# __init__.py för local_backend/modules/accounting/closing

END: __init__.py

====================
📄 Fil: modules/accounting/closing/routes.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:45:47
📏 Antal rader: 16
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: routes.py
from fastapi import APIRouter
from fastapi.responses import JSONResponse

from .services import lock_period_service, perform_year_end_closing

router = APIRouter(prefix="/closing", tags=["closing"])

@router.post("/lock_period")
async def lock_period():
    result = await lock_period_service()
    return JSONResponse(content={"status": "ok", "message": result})

@router.post("/year_end")
async def year_end():
    result = await perform_year_end_closing()
    return JSONResponse(content={"status": "ok", "message": result})
END: routes.py

====================
📄 Fil: modules/accounting/base/services.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:08:42
📏 Antal rader: 477
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 7 – ['import os', 'import asyncpg', 'import os', 'import asyncpg', 'import json', 'import json', 'import json']
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 56
🧪 TODO/FIXME: 0
====================
START: services.py
from typing import Optional
import os
import asyncpg

async def generate_resultatrapport():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT rs.group_name, SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN report_structure rs
          ON (a.number = rs.account_number OR a.number BETWEEN split_part(rs.account_range, '-', 1)::text AND split_part(rs.account_range, '-', 2)::text)
        WHERE rs.report_type = 'resultat'
        GROUP BY rs.group_name, rs.order_index
        ORDER BY rs.order_index
    """)
    await conn.close()
    return [{"group": row["group_name"], "total": float(row["total"])} for row in rows]

async def generate_balansrapport():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT rs.group_name, SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN report_structure rs
          ON (a.number = rs.account_number OR a.number BETWEEN split_part(rs.account_range, '-', 1)::text AND split_part(rs.account_range, '-', 2)::text)
        WHERE rs.report_type = 'balans'
        GROUP BY rs.group_name, rs.order_index
        ORDER BY rs.order_index
    """)
    await conn.close()
    return [{"group": row["group_name"], "total": float(row["total"])} for row in rows]

async def generate_momsrapport():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT rs.group_name, SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN report_structure rs
          ON (a.number = rs.account_number OR a.number BETWEEN split_part(rs.account_range, '-', 1)::text AND split_part(rs.account_range, '-', 2)::text)
        WHERE rs.report_type = 'moms'
        GROUP BY rs.group_name, rs.order_index
        ORDER BY rs.order_index
    """)
    await conn.close()
    results = [{"group": row["group_name"], "total": float(row["total"])} for row in rows]
    netto = sum(r["total"] for r in results)
    results.append({"group": "Netto att betala", "total": netto})
    return results
async def get_chart_of_accounts(language="sv"):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT
            a.number,
            COALESCE(t.name, a.name) AS name,
            a.type,
            a.is_active,
            a.report_type,
            a.report_group
        FROM account a
        LEFT JOIN account_translation t
          ON t.account_id = a.id AND t.language = $1
        ORDER BY a.number
    """, language)
    await conn.close()
    return [dict(row) for row in rows]
from .schemas import TransactionIn
from uuid import uuid4
from decimal import Decimal
from datetime import datetime
import os
import asyncpg
import json

def fix_encoding(text):
    if isinstance(text, str):
        try:
            return text.encode("latin1").decode("utf-8")
        except Exception:
            return text
    return text

async def get_accounts(language="sv"):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            a.id,
            a.number,
            COALESCE(t.name, a.name) AS name,
            a.type
        FROM account a
        LEFT JOIN account_translation t
          ON t.account_id = a.id AND t.language = $1
        ORDER BY a.number
    """, language)
    await conn.close()
    from uuid import UUID
    return [
        {
            k: fix_encoding(str(v)) if isinstance(v, str) else str(v) if isinstance(v, UUID) else v
            for k, v in row.items()
        }
        for row in rows
    ]

async def get_transactions(language="sv", filter_user=None):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    # Prepare for future translation of 'description' via transaction_translation
    rows = await conn.fetch("""
        SELECT
            t.id,
            t.date,
            COALESCE(tt.description, t.description) AS description,
            t.description AS original_description,
            t.series,
            t.ver_no,
            t.metadata,
            t.created_at,
            json_agg(json_build_object(
                'id', e.id,
                'account_id', e.account_id,
                'amount', e.amount,
                'description', e.description,
                'metadata', e.metadata
            )) AS entries
        FROM transaction t
        LEFT JOIN transaction_translation tt
          ON tt.transaction_id = t.id AND tt.language = $1
        LEFT JOIN entry e ON e.transaction_id = t.id
        WHERE ($2::text IS NULL OR t.metadata->>'user' = $2)
        GROUP BY t.id, tt.description
        ORDER BY t.date DESC, t.ver_no DESC
        LIMIT 100
    """, language, filter_user)
    await conn.close()
    from uuid import UUID
    from datetime import date
    result = []
    for row in rows:
        user = None
        try:
            user = json.loads(row["metadata"]).get("user")
        except Exception:
            pass
        has_translation = row["description"] != row["original_description"]
        obj = {
            k: fix_encoding(str(v)) if isinstance(v, str)
            else str(v) if isinstance(v, (UUID, date))
            else v
            for k, v in row.items()
        }
        obj["has_translation"] = has_translation
        obj["user"] = user
        result.append(obj)
    return result


# Skapa ny funktion för att skapa transaktion
async def create_transaction(transaction: TransactionIn):
    import json
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)

    default_user = os.getenv("DEFAULT_USER_EMAIL", "unknown@local")

    # Hämta nästa ver_no för serien
    ver_row = await conn.fetchrow("""
        UPDATE journal_series
        SET next_ver_no = next_ver_no + 1
        WHERE series = $1
        RETURNING next_ver_no - 1 AS ver_no
    """, transaction.series)
    if not ver_row:
        await conn.close()
        raise ValueError(f"Ogiltig verifikationsserie: {transaction.series}")
    ver_no = ver_row["ver_no"]

    # Hämta alla kontonummer i en gång
    account_rows = await conn.fetch("SELECT id, number FROM account")
    account_map = {r["number"]: r["id"] for r in account_rows}

    # Kontroll: alla konton måste finnas
    for entry in transaction.entries:
        if entry.account_number not in account_map:
            await conn.close()
            raise ValueError(f"Konto saknas: {entry.account_number}")

    # Kontroll: debet = kredit
    total = sum([entry.amount for entry in transaction.entries])
    if total != Decimal("0.00"):
        await conn.close()
        raise ValueError(f"Obalanserad transaktion: {total}")

    # Kontrollera metadata och sätt user om saknas, serialisera till JSON-sträng
    metadata_dict = transaction.metadata or {}
    if "user" not in metadata_dict:
        metadata_dict["user"] = default_user
    metadata = json.dumps(metadata_dict)

    # Skapa verifikat
    tx_id = uuid4()
    now = datetime.utcnow()
    await conn.execute("""
        INSERT INTO transaction (id, date, description, series, ver_no, metadata, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $7)
    """, tx_id, transaction.date, transaction.description, transaction.series, ver_no, metadata, now)

    import json
    for entry in transaction.entries:
        entry_metadata = entry.metadata or {}
        entry_metadata["user"] = entry_metadata.get("user", metadata_dict["user"])
        entry_metadata["generated_by"] = entry_metadata.get("generated_by", "macspot-backend")
        entry_metadata = json.dumps(entry_metadata)
        await conn.execute("""
            INSERT INTO entry (id, transaction_id, account_id, amount, description, metadata, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
        """, uuid4(), tx_id, account_map[entry.account_number], entry.amount,
             entry.description, entry_metadata, now)

    await conn.close()
    return {"status": "ok", "transaction_id": str(tx_id), "series": transaction.series, "ver_no": ver_no}


# Avvikelse-/felupptäckt
async def detect_anomalies():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    try:
        rows = await conn.fetch("""
            SELECT t.id, t.description, t.date, t.ver_no, a.number AS account_number, e.amount
            FROM transaction t
            JOIN entry e ON e.transaction_id = t.id
            JOIN account a ON a.id = e.account_id
            WHERE t.date > now() - interval '12 months'
        """)
        seen = set()
        anomalies = []
        for r in rows:
            key = (r["description"], float(r["amount"]))
            if key in seen:
                anomalies.append({
                    "transaction_id": str(r["id"]),
                    "ver_no": r["ver_no"],
                    "reason": "Dublett: samma text och belopp",
                    "description": r["description"],
                    "amount": float(r["amount"]),
                    "date": r["date"].isoformat(),
                })
            else:
                seen.add(key)
            if abs(float(r["amount"])) > 50000:
                anomalies.append({
                    "transaction_id": str(r["id"]),
                    "ver_no": r["ver_no"],
                    "reason": "Högt belopp",
                    "description": r["description"],
                    "amount": float(r["amount"]),
                    "date": r["date"].isoformat(),
                })
    finally:
        await conn.close()
    return anomalies

# --- Budget vs Actual report
async def generate_budget_vs_actual(db_url: str, year: Optional[int] = None, month: Optional[int] = None):
    conditions = []
    values = []

    if year:
        conditions.append("b.year = $%d" % (len(values)+1))
        values.append(year)
    if month:
        conditions.append("b.month = $%d" % (len(values)+1))
        values.append(month)

    where_clause = f"WHERE {' AND '.join(conditions)}" if conditions else ""

    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch(f"""
        SELECT
            b.year,
            b.month,
            b.account_number,
            b.amount AS budget,
            COALESCE(SUM(e.amount), 0) AS actual
        FROM budget b
        LEFT JOIN account a ON a.number = b.account_number
        LEFT JOIN entry e ON e.account_id = a.id
          AND EXTRACT(YEAR FROM e.created_at) = b.year
          AND EXTRACT(MONTH FROM e.created_at) = b.month
        {where_clause}
        GROUP BY b.year, b.month, b.account_number, b.amount
        ORDER BY b.year, b.month, b.account_number
    """, *values)
    await conn.close()
    return [dict(r) for r in rows]

async def generate_cashflow_report():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            TO_CHAR(t.date, 'YYYY-MM') AS period,
            SUM(e.amount) FILTER (WHERE a.type = 'tillgång' AND e.amount > 0) AS inflow,
            SUM(e.amount) FILTER (WHERE a.type = 'tillgång' AND e.amount < 0) AS outflow
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN transaction t ON e.transaction_id = t.id
        GROUP BY period
        ORDER BY period
    """)
    await conn.close()
    return [dict(r) for r in rows]

async def generate_full_cashflow_report():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            TO_CHAR(t.date, 'YYYY-MM') AS period,
            a.number AS account_number,
            a.name AS account_name,
            a.type AS account_type,
            SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN transaction t ON e.transaction_id = t.id
        WHERE a.type IN ('tillgång', 'skuld')
        GROUP BY period, a.number, a.name, a.type
        ORDER BY period, a.number
    """)
    await conn.close()

    # Strukturera datan
    cashflow = {}
    for r in rows:
        period = r["period"]
        if period not in cashflow:
            cashflow[period] = {
                "period": period,
                "accounts": []
            }
        cashflow[period]["accounts"].append({
            "account_number": r["account_number"],
            "account_name": r["account_name"],
            "account_type": r["account_type"],
            "amount": float(r["total"])
        })

    return list(cashflow.values())


# Ny funktion: indirekt kassaflödesanalys
async def generate_indirect_cashflow(db_url: str):
    conn = await asyncpg.connect(dsn=db_url)
    try:
        # Steg 1: Hämta årets resultat (nettoresultat)
        net_result_row = await conn.fetchrow("""
            SELECT SUM(e.amount) AS net_income
            FROM entry e
            JOIN account a ON e.account_id = a.id
            WHERE a.report_type = 'resultat'
        """)

        # Steg 2: Justera för icke-kassapåverkande poster (t.ex. avskrivningar)
        adjustments = await conn.fetch("""
            SELECT a.number, a.name, SUM(e.amount) AS total
            FROM entry e
            JOIN account a ON e.account_id = a.id
            WHERE a.number LIKE '7%' -- t.ex. avskrivningar: 7830 etc.
            GROUP BY a.number, a.name
        """)

        # Steg 3: Förändringar i rörelsekapital (tillgångar och skulder)
        working_capital = await conn.fetch("""
            SELECT a.type, a.number, a.name, SUM(e.amount) AS delta
            FROM entry e
            JOIN account a ON e.account_id = a.id
            WHERE a.type IN ('tillgång', 'skuld')
            GROUP BY a.type, a.number, a.name
        """)

        await conn.close()

        return {
            "net_income": float(net_result_row["net_income"] or 0),
            "adjustments": [
                {
                    "account": r["number"],
                    "name": r["name"],
                    "amount": float(r["total"])
                } for r in adjustments
            ],
            "working_capital_changes": [
                {
                    "account": r["number"],
                    "name": r["name"],
                    "type": r["type"],
                    "delta": float(r["delta"])
                } for r in working_capital
            ]
        }
    except Exception as e:
        await conn.close()
        raise

# Ny funktion: kontoavstämning för ett specifikt konto
async def generate_reconciliation_report(db_url: str, account_number: str):
    conn = await asyncpg.connect(dsn=db_url)
    try:
        rows = await conn.fetch("""
            SELECT t.date, t.description, e.amount
            FROM entry e
            JOIN transaction t ON t.id = e.transaction_id
            JOIN account a ON a.id = e.account_id
            WHERE a.number = $1
            ORDER BY t.date
        """, account_number)
        total = sum([r["amount"] for r in rows])
        transactions = [{
            "date": r["date"].isoformat(),
            "description": r["description"],
            "amount": float(r["amount"])
        } for r in rows]
        return {
            "account_number": account_number,
            "total_balance": float(total),
            "transactions": transactions
        }
    finally:
        await conn.close()

# --- SIE export ---
async def generate_sie_export(start_date=None, end_date=None):
    conn = await asyncpg.connect(dsn=os.environ["LOCAL_DB_URL"])
    try:
        sie_lines = []
        sie_lines.append("#FLAGGA 0")
        sie_lines.append("#FORMAT PC8")
        sie_lines.append("#GEN 2")
        sie_lines.append("#SIETYP 4")
        sie_lines.append("#PROGRAM macspot 1.0")
        sie_lines.append(f"#ORGNR 000000-0000")
        sie_lines.append(f"#FNAMN Ditt Företag AB")

        # Kontoplan
        accounts = await conn.fetch("SELECT number, name FROM account ORDER BY number")
        for acc in accounts:
            sie_lines.append(f"#KONTO {acc['number']} \"{acc['name']}\"")

        # Verifikationer
        query = """
            SELECT t.id, t.date, t.series, t.ver_no, t.description, e.amount, a.number AS account
            FROM transaction t
            JOIN entry e ON e.transaction_id = t.id
            JOIN account a ON a.id = e.account_id
            WHERE ($1::date IS NULL OR t.date >= $1)
              AND ($2::date IS NULL OR t.date <= $2)
            ORDER BY t.date, t.ver_no
        """
        rows = await conn.fetch(query, start_date, end_date)
        for row in rows:
            datum = row["date"].strftime("%Y%m%d")
            sie_lines.append(f"#{'VER'} \"{row['series']}\" {datum} \"{row['description']}\"")
            sie_lines.append(f"#{'TRANS'} {row['account']} {row['amount']} \"\"")

        return "\n".join(sie_lines)
    finally:
        await conn.close()
END: services.py

====================
📄 Fil: modules/accounting/base/suggest_accounting.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:08:41
📏 Antal rader: 272
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 1 rader (0.4%)
📥 Imports: 5 – ['import re', 'import fitz  # PyMuPDF', 'import asyncpg', 'import os', 'import asyncpg']
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 38
🧪 TODO/FIXME: 2
====================
START: suggest_accounting.py
import re
from typing import Optional, Dict
import fitz  # PyMuPDF
# from .match_supplier import match_supplier_name


def parse_invoice_text(text: str) -> Dict[str, Optional[str]]:
    text = text.replace(",", ".")  # Normalize decimal separator
    text = text.replace("O", "0").replace("I", "1")
    numbers = [float(m.group()) for m in re.finditer(r"\d{1,3}(?:[ ]?\d{3})*(?:\.\d{2})", text)]
    total_amount = max(numbers) if numbers else None

    vat_patterns = {
        "25%": r"(25\s?%|moms\s?25\s?%)",
        "12%": r"(12\s?%)",
        "6%": r"(6\s?%)"
    }
    vat_detected = None
    for rate, pattern in vat_patterns.items():
        if re.search(pattern, text, re.IGNORECASE):
            vat_detected = rate
            break
    if not vat_detected:
        vat_detected = "25%"

    date_patterns = [r"\d{4}-\d{2}-\d{2}", r"\d{2}/\d{2}/\d{4}", r"\d{2}\.\d{2}\.\d{4}"]
    invoice_date = None
    for pattern in date_patterns:
        match = re.search(pattern, text)
        if match:
            invoice_date = match.group()
            break

    ocr_match = re.search(r"(OCR|Referens)?\s*[:#]?\s?(\d{6,})", text, re.IGNORECASE)
    reference = ocr_match.group(2) if ocr_match else None

    currency_match = re.search(r"(SEK|kr|EUR|€|USD|\$)", text, re.IGNORECASE)
    currency = currency_match.group() if currency_match else "SEK"

    orgnr = re.search(r"\b\d{6}-\d{4}\b", text)  # Ex: 556123-4567
    iban = re.search(r"[A-Z]{2}\d{2}[ ]?\d{4}[ ]?\d{4}[ ]?\d{4}[ ]?\d{4}", text)

    return {
        "total_amount": total_amount,
        "vat_rate": vat_detected,
        "invoice_date": invoice_date,
        "reference_number": reference,
        "currency": currency,
        "orgnr": orgnr.group() if orgnr else None,
        "iban": iban.group() if iban else None,
        # TODO: match supplier by name/orgnr/IBAN
    }

def extract_text_from_pdf(pdf_bytes: bytes) -> str:
    try:
        doc = fitz.open(stream=pdf_bytes, filetype="pdf")
        all_text = []
        for page in doc:
            all_text.append(page.get_text())
        return "\n".join(all_text)
    except Exception as e:
        return f"ERROR: {e.__class__.__name__} – {str(e)}"


# --- NEW FUNCTION ---
async def analyze_invoice_attachment(attachment_id: str, db_url: str) -> dict:
    import asyncpg
    conn = await asyncpg.connect(dsn=db_url)
    row = await conn.fetchrow("SELECT data FROM attachment WHERE id = $1", attachment_id)
    await conn.close()
    if not row:
        return {"error": "Attachment not found"}
    text = extract_text_from_pdf(row["data"])
    parsed = parse_invoice_text(text)
    parsed["supplier_name"] = "UNKNOWN"
    return {"text": text, "parsed": parsed}

def generate_transaction_from_parsed(parsed: dict, supplier_name: str = "", currency: str = "SEK") -> dict:
    supplier_name = parsed.get("supplier_name", supplier_name)
    description = f"Faktura {supplier_name}".strip()
    total = parsed.get("total_amount")
    vat_rate = parsed.get("vat_rate")
    date = parsed.get("invoice_date") or ""
    ref = parsed.get("reference_number") or ""
    currency = parsed.get("currency", currency)

    if not total or not vat_rate:
        return {}

    total = round(float(total), 2)
    vat_factor = {"25%": 0.2, "12%": 0.1071, "6%": 0.0566}.get(vat_rate, 0.2)
    vat_amount = round(total * vat_factor / (1 + vat_factor), 2)
    net_amount = round(total - vat_amount, 2)

    raw_entries = [
        {
            "account_number": "3001",
            "amount": -net_amount,
            "description": "Försäljning",
            "currency": currency
        },
        {
            "account_number": "2611",
            "amount": -vat_amount,
            "description": f"Moms {vat_rate}",
            "currency": currency
        },
        {
            "account_number": "1930",
            "amount": total,
            "description": "Inbetalning",
            "currency": currency
        }
    ]
    entries = apply_regulatory_rules(parsed, raw_entries)

    return {
        "description": description,
        "date": date,
        "reference": ref,
        "currency": currency,
        "entries": entries
    }
def detect_anomalies(transactions: list) -> list:
    anomalies = []
    for tx in transactions:
        seen_refs = set()
        ref = tx.get("reference", "")
        if ref in seen_refs:
            anomalies.append({
                "transaction_id": tx.get("id"),
                "issue": f"Duplicate reference: {ref}"
            })
        elif ref:
            seen_refs.add(ref)
        for entry in tx.get("entries", []):
            desc = entry.get("description", "").lower()
            amount = abs(entry.get("amount", 0))
            if "lunch" in desc or "middag" in desc:
                if amount > 1000:
                    anomalies.append({
                        "transaction_id": tx.get("id"),
                        "issue": f"High meal expense: {amount} SEK"
                    })
            if entry.get("account_number") == "3001" and amount > 500000:
                anomalies.append({
                    "transaction_id": tx.get("id"),
                    "issue": f"Unusually high revenue: {amount} SEK"
                })
            if entry.get("account_number") == "2641" and float(entry.get("amount", 0)) > 0:
                anomalies.append({
                    "transaction_id": tx.get("id"),
                    "issue": "Possible VAT paid on purchase (check for reverse charge)"
                })
    return anomalies

def suggest_periodization(description: str, total_amount: float) -> Optional[dict]:
    """
    Försök periodisera kostnader automatiskt.
    T.ex. Dropbox-abonnemang 1200 SEK → 100 SEK/månad i 12 månader.
    """
    description = description.lower()
    recurring_keywords = ["abonnemang", "dropbox", "google", "office365", "försäkring", "hyra", "licens"]
    if any(word in description for word in recurring_keywords) and total_amount > 1000:
        monthly = round(total_amount / 12, 2)
        return {
            "type": "monthly",
            "months": 12,
            "monthly_amount": monthly,
            "total": total_amount
        }
    return None

def apply_regulatory_rules(parsed: dict, entries: list) -> list:
    """
    Justera konton, moms och texter enligt svenska redovisningsregler:
    - Representation (avdragsgill/ej avdragsgill)
    - Omvänd moms (EU-handel)
    - Avdragsgränser
    """
    adjusted = []
    description_text = parsed.get("description", "").lower()
    vat_rate = parsed.get("vat_rate", "25%")
    currency = parsed.get("currency", "SEK")
    total = parsed.get("total_amount", 0)

    for entry in entries:
        account = entry["account_number"]
        text = entry["description"].lower()
        amount = entry["amount"]

        # Representation
        if "lunch" in text or "middag" in text or "representation" in text:
            if abs(amount) > 300:
                account = "5832"  # ej avdragsgill representation
            else:
                account = "5831"  # avdragsgill representation

        # EU-handel (om moms = 0% + utländsk valuta → anta EU-tjänst)
        if vat_rate == "0%" or vat_rate == "0" or vat_rate is None:
            if currency != "SEK":
                if amount < 0:
                    account = "2645"  # Ingående moms omvänd skattskyldighet
                else:
                    account = "2614"  # Utgående moms omvänd skattskyldighet

        # TODO: Lägg till fler regler här vid behov
        adjusted.append({
            **entry,
            "account_number": account,
            "currency": currency
        })

    return adjusted

# --- NEW FUNCTION ---
import os
import asyncpg

async def generate_cashflow_report():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            TO_CHAR(t.date, 'YYYY-MM') AS period,
            SUM(e.amount) FILTER (WHERE a.type = 'tillgång' AND e.amount > 0) AS inflow,
            SUM(e.amount) FILTER (WHERE a.type = 'tillgång' AND e.amount < 0) AS outflow
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN transaction t ON e.transaction_id = t.id
        GROUP BY period
        ORDER BY period
    """)
    await conn.close()
    return [dict(r) for r in rows]

async def generate_full_cashflow_report():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            TO_CHAR(t.date, 'YYYY-MM') AS period,
            a.number AS account_number,
            a.name AS account_name,
            a.type AS account_type,
            SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN transaction t ON e.transaction_id = t.id
        WHERE a.type IN ('tillgång', 'skuld')
        GROUP BY period, a.number, a.name, a.type
        ORDER BY period, a.number
    """)
    await conn.close()

    # Strukturera datan
    cashflow = {}
    for r in rows:
        period = r["period"]
        if period not in cashflow:
            cashflow[period] = {
                "period": period,
                "accounts": []
            }
        cashflow[period]["accounts"].append({
            "account_number": r["account_number"],
            "account_name": r["account_name"],
            "account_type": r["account_type"],
            "amount": float(r["total"])
        })

    return list(cashflow.values())
END: suggest_accounting.py

====================
📄 Fil: modules/accounting/base/__init__.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:33:00
📏 Antal rader: 19
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: __init__.py
from .services import *
from .schemas import *
from .suggest_accounting import *
from .export import *

__all__ = [
    "create_transaction",
    "get_accounts",
    "get_transactions",
    "generate_resultatrapport",
    "generate_balansrapport",
    "generate_momsrapport",
    "generate_sie_export",
    "analyze_invoice_attachment",
    "generate_transaction_from_parsed",
    "suggest_account",
    "suggest_periodization",
    "detect_anomalies"
]

END: __init__.py

====================
📄 Fil: modules/accounting/base/export.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 17:44:30
📏 Antal rader: 69
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 5 – ['import os', 'import json', 'import datetime', 'import asyncpg', 'import asyncio']
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 6
🧪 TODO/FIXME: 0
====================
START: export.py
import os
from dotenv import load_dotenv
import json
import datetime
import asyncpg
import asyncio

load_dotenv(dotenv_path="/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot/macspot-api/.env")

EXPORT_ROOT = "/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot/exports/accounting"
EXPORT_DATA_DIR = os.path.join(EXPORT_ROOT, "exportdata")
EXPORT_ATTACHMENTS_DIR = os.path.join(EXPORT_ROOT, "attachments")

DB_CONFIG = {
    "user": os.environ["LOCAL_DB_USER"],
    "password": os.environ["LOCAL_DB_PASSWORD"],
    "database": os.environ["LOCAL_DB_NAME"],
    "host": os.environ["LOCAL_DB_HOST"],
    "port": os.environ["LOCAL_DB_PORT"]
}

async def export_data():
    os.makedirs(EXPORT_DATA_DIR, exist_ok=True)
    os.makedirs(EXPORT_ATTACHMENTS_DIR, exist_ok=True)

    date_str = datetime.datetime.now().strftime("%Y-%m-%d")
    data_dir = os.path.join(EXPORT_DATA_DIR, date_str)
    os.makedirs(data_dir, exist_ok=True)

    conn = await asyncpg.connect(**DB_CONFIG)

    # Export transactions
    transactions = await conn.fetch("SELECT * FROM transaction")
    with open(os.path.join(data_dir, "transactions.json"), "w") as f:
        json.dump([dict(r) for r in transactions], f, default=str, indent=2)

    # Export accounts
    accounts = await conn.fetch("SELECT * FROM account")
    with open(os.path.join(data_dir, "accounts.json"), "w") as f:
        json.dump([dict(r) for r in accounts], f, indent=2, default=str)

    # Export momsrapport
    moms = await conn.fetch("""
        SELECT 
          CASE 
            WHEN a.number LIKE '26%' THEN 'Utgående moms' 
            WHEN a.number LIKE '264%' THEN 'Ingående moms' 
            ELSE 'Annat' 
          END AS group_name,
          SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        GROUP BY group_name
    """)
    with open(os.path.join(data_dir, "momsrapport.json"), "w") as f:
        json.dump([dict(r) for r in moms], f, indent=2, default=str)

    # Export attachments
    attachments = await conn.fetch("SELECT id, filename, data FROM attachment")
    for a in attachments:
        file_path = os.path.join(EXPORT_ATTACHMENTS_DIR, f"{a['id']}_{a['filename']}")
        with open(file_path, "wb") as f:
            f.write(a["data"])

    await conn.close()
    print(f"✅ Export klar: {data_dir}")

if __name__ == "__main__":
    asyncio.run(export_data())
END: export.py

====================
📄 Fil: modules/accounting/base/schemas.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 16:52:13
📏 Antal rader: 47
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: schemas.py
from typing import Optional, List
from uuid import UUID
from decimal import Decimal
from datetime import date

from pydantic import BaseModel, Field

class TransactionTranslationOut(BaseModel):
    transaction_id: UUID
    language: str
    description: str

class TransactionTranslationIn(BaseModel):
    transaction_id: UUID
    language: str
    description: str

class EntryIn(BaseModel):
    account_number: str
    amount: Decimal
    description: Optional[str] = None
    metadata: Optional[dict] = None


class TransactionIn(BaseModel):
    date: date
    description: Optional[str] = None
    series: str = Field(default="A", max_length=10)
    metadata: Optional[dict] = None
    entries: List[EntryIn]

class EntryOut(BaseModel):
    id: UUID
    account_id: UUID
    amount: Decimal
    description: Optional[str]
    metadata: Optional[dict]

class TransactionOut(BaseModel):
    id: UUID
    date: date
    description: Optional[str]
    series: str
    ver_no: int
    metadata: Optional[dict]
    entries: List[EntryOut]
    user: Optional[str] = None
END: schemas.py

====================
📄 Fil: modules/accounting/base/routes.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:39:03
📏 Antal rader: 459
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 10 – ['import os', 'import os', 'import csv', 'import asyncpg', 'import asyncpg', 'import os', 'import datetime', 'import asyncpg', 'import asyncpg', 'import datetime']
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 18
🧪 TODO/FIXME: 0
====================
START: routes.py
from fastapi import APIRouter
from fastapi import Depends
router = APIRouter(prefix="/accounting", tags=["accounting"])

# 🔐 Följande endpoints kräver Bearer-token (API-autentisering):
# - POST /transactions
# - POST /transaction_translations
# - POST /attachments

import os
API_KEY = os.getenv("API_ACCOUNTING_KEY")

from fastapi import Header, HTTPException
def verify_token(authorization: str = Header(None)):
    if authorization != f"Bearer {API_KEY}":
        raise HTTPException(status_code=401, detail="Invalid or missing token")

@router.get("/report/reconciliation", dependencies=[Depends(verify_token)])
async def get_reconciliation(account_number: str):
    from .services import generate_reconciliation_report
    db_url = os.environ["LOCAL_DB_URL"]
    result = await generate_reconciliation_report(db_url, account_number)
    return JSONResponse(content={"status": "ok", "result": result})
from .suggest_accounting import analyze_invoice_attachment
from fastapi import HTTPException
from fastapi import Path
from fastapi import UploadFile, File
from fastapi import Depends, Header
from fastapi import Query
from uuid import UUID
from .schemas import TransactionIn, TransactionTranslationIn, TransactionTranslationOut
from .services import create_transaction
from fastapi import APIRouter
from fastapi.responses import JSONResponse
from .services import get_accounts, get_transactions, generate_full_cashflow_report
from typing import Optional
import os

# --- BANK RECONCILIATION & CSV UPLOAD ---
import csv
from fastapi import UploadFile
from io import StringIO



router = APIRouter(prefix="/accounting", tags=["accounting"])

# 🔐 Följande endpoints kräver Bearer-token (API-autentisering):
# - POST /transactions
# - POST /transaction_translations
# - POST /attachments

API_KEY = os.getenv("API_ACCOUNTING_KEY")

def verify_token(authorization: str = Header(None)):
    if authorization != f"Bearer {API_KEY}":
        raise HTTPException(status_code=401, detail="Invalid or missing token")

@router.get("/chart_of_accounts")
async def get_chart(lang: str = "sv"):
    from .services import get_chart_of_accounts
    data = await get_chart_of_accounts(language=lang)
    return JSONResponse(content=data)

@router.get("/report/resultat")
async def get_resultatrapport():
    from .services import generate_resultatrapport
    data = await generate_resultatrapport()
    return JSONResponse(content=data)

@router.get("/report/balans")
async def get_balansrapport():
    from .services import generate_balansrapport
    data = await generate_balansrapport()
    return JSONResponse(content=data)

@router.get("/report/moms")
async def get_momsrapport():
    from .services import generate_momsrapport
    data = await generate_momsrapport()
    return JSONResponse(content=data)

@router.get("/accounts")
async def list_accounts(lang: str = "sv"):
    data = await get_accounts(language=lang)
    return JSONResponse(content=data)

@router.get("/transactions")
async def list_transactions(lang: str = "sv", user: Optional[str] = None):
    data = await get_transactions(language=lang, filter_user=user)
    return JSONResponse(content=data)


# Skapa ny POST-route för transactions
@router.post("/transactions", dependencies=[Depends(verify_token)])
async def post_transaction(transaction: TransactionIn):
    """
    Skapa en ny transaction. Tar emot och sparar även currency_code, exchange_rate och total_amount_original.
    """
    try:
        # Pass entire transaction object, which now includes currency_code, exchange_rate, total_amount_original
        result = await create_transaction(transaction)
        return JSONResponse(content=result)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))


# Ny POST-endpoint för att föreslå konto baserat på beskrivning, filnamn och belopp
@router.post("/suggest_accounting")
async def suggest_accounting_api(payload: dict):
    desc = payload.get("description", "")
    file_name = payload.get("file_name", "")
    amount = payload.get("amount")
    suggestion = suggest_account(desc, file_name, amount)
    return {"status": "ok", **suggestion}

from .suggest_accounting import extract_text_from_pdf
import asyncpg

@router.post("/extract_text_from_attachment")
async def extract_text_endpoint(attachment_id: UUID):
    try:
        db_url = os.environ["LOCAL_DB_URL"]
        conn = await asyncpg.connect(dsn=db_url)
        row = await conn.fetchrow("SELECT data FROM attachment WHERE id = $1", attachment_id)
        await conn.close()

        if not row:
            raise HTTPException(status_code=404, detail="Attachment not found")

        text = extract_text_from_pdf(row["data"])
        return {"text": text}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Skapa ny POST-route för transaction_translations
import asyncpg
from fastapi import HTTPException


@router.post("/transaction_translations", dependencies=[Depends(verify_token)])
async def add_transaction_translation(translation: TransactionTranslationIn):
    try:
        db_url = os.environ["LOCAL_DB_URL"]
        conn = await asyncpg.connect(dsn=db_url)
        await conn.execute("""
            INSERT INTO transaction_translation (transaction_id, language, description)
            VALUES ($1, $2, $3)
            ON CONFLICT (transaction_id, language) DO UPDATE
            SET description = EXCLUDED.description
        """, translation.transaction_id, translation.language, translation.description)
        await conn.close()
        return {"status": "ok"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Ny GET-endpoint för att hämta översättningar för en transaction_id
from typing import List
from uuid import UUID

@router.get("/transaction_translations/{transaction_id}", response_model=List[TransactionTranslationOut])
async def get_transaction_translations(transaction_id: UUID):
    try:
        db_url = os.environ["LOCAL_DB_URL"]
        conn = await asyncpg.connect(dsn=db_url)
        rows = await conn.fetch("""
            SELECT transaction_id, language, description
            FROM transaction_translation
            WHERE transaction_id = $1
        """, transaction_id)
        await conn.close()
        return [dict(row) for row in rows]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Ny POST-endpoint för att ladda upp bilagor
@router.post("/attachments", dependencies=[Depends(verify_token)])
async def upload_attachment(transaction_id: UUID, file: UploadFile = File(...)):
    allowed_types = ["application/pdf", "image/jpeg", "image/png"]
    max_size_bytes = 5 * 1024 * 1024  # 5 MB

    if file.content_type not in allowed_types:
        raise HTTPException(status_code=422, detail=f"Filtypen '{file.content_type}' är inte tillåten")

    content = await file.read()

    if len(content) > max_size_bytes:
        raise HTTPException(status_code=422, detail=f"Filen är för stor (max 5 MB)")

    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    await conn.execute("""
        INSERT INTO attachment (transaction_id, filename, content_type, data)
        VALUES ($1, $2, $3, $4)
    """, transaction_id, file.filename, file.content_type, content)
    await conn.close()

    return {"status": "ok", "filename": file.filename}
# Ny GET-endpoint för att hämta alla bilagor för en viss transaction_id
from uuid import UUID

@router.get("/attachments/{transaction_id}")
async def get_attachments(transaction_id: UUID):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT id, filename, content_type, data, uploaded_at
        FROM attachment
        WHERE transaction_id = $1
        ORDER BY uploaded_at
    """, transaction_id)
    await conn.close()
    return [
        {
            "id": str(row["id"]),
            "filename": row["filename"],
            "content_type": row["content_type"],
            "uploaded_at": row["uploaded_at"].isoformat(),
            "size_bytes": len(row["data"])
        }
        for row in rows
    ]


# Ny GET-endpoint för att ladda ner en bilaga
from uuid import UUID
from fastapi.responses import StreamingResponse
from io import BytesIO

@router.get("/attachments/{attachment_id}/download")
async def download_attachment(attachment_id: UUID):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    row = await conn.fetchrow("""
        SELECT filename, content_type, data
        FROM attachment
        WHERE id = $1
    """, attachment_id)
    await conn.close()

    if not row:
        raise HTTPException(status_code=404, detail="Attachment not found")

    return StreamingResponse(BytesIO(row["data"]), media_type=row["content_type"], headers={
        "Content-Disposition": f'attachment; filename="{row["filename"]}"'
    })

# Byt namn på en bilaga
@router.put("/attachments/{attachment_id}/rename", dependencies=[Depends(verify_token)])
async def rename_attachment(attachment_id: UUID, new_filename: str):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    result = await conn.execute("""
        UPDATE attachment SET filename = $1 WHERE id = $2
    """, new_filename, attachment_id)
    await conn.close()
    return {"status": "ok", "result": result}

# Radera en bilaga
@router.delete("/attachments/{attachment_id}", dependencies=[Depends(verify_token)])
async def delete_attachment(attachment_id: UUID):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    result = await conn.execute("""
        DELETE FROM attachment WHERE id = $1
    """, attachment_id)
    await conn.close()
    return {"status": "ok", "result": result}


# Ny POST-endpoint för att analysera en fakturabilaga
from uuid import UUID
from fastapi import Depends


@router.post("/analyze_invoice", dependencies=[Depends(verify_token)])
async def analyze_invoice(attachment_id: UUID):
    db_url = os.environ["LOCAL_DB_URL"]
    try:
        result = await analyze_invoice_attachment(attachment_id, db_url)
        from .suggest_accounting import suggest_periodization, generate_transaction_from_parsed
        periodization = suggest_periodization(result.get("text", ""), result.get("parsed", {}).get("total_amount", 0))
        tx_suggestion = generate_transaction_from_parsed(result.get("parsed", {}))
        result["periodization"] = periodization
        result["transaction_suggestion"] = tx_suggestion
        return JSONResponse(content={"status": "ok", **result})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Ny POST-endpoint: Konvertera fakturabilaga till transaktion
from uuid import UUID
from fastapi import Depends

@router.post("/invoice_to_transaction", dependencies=[Depends(verify_token)])
async def invoice_to_transaction(attachment_id: UUID):
    from .suggest_accounting import analyze_invoice_attachment, generate_transaction_from_parsed
    from .services import create_transaction
    from .schemas import TransactionIn, EntryIn
    import os
    import datetime

    db_url = os.environ["LOCAL_DB_URL"]
    result = await analyze_invoice_attachment(str(attachment_id), db_url)
    parsed = result.get("parsed", {})

    tx_suggestion = generate_transaction_from_parsed(parsed)
    if not tx_suggestion:
        raise HTTPException(status_code=422, detail="Kunde inte generera transaktion från faktura")

    try:
        entries = [
            EntryIn(
                account_number=e["account_number"],
                amount=e["amount"],
                description=e.get("description"),
                metadata={"generated_by": "invoice_to_transaction"}
            )
            for e in tx_suggestion["entries"]
        ]

        transaction = TransactionIn(
            date=datetime.date.fromisoformat(tx_suggestion["date"]) if tx_suggestion.get("date") else datetime.date.today(),
            description=tx_suggestion.get("description", "Fakturaimport"),
            series="A",
            metadata={"reference": tx_suggestion.get("reference"), "source": "invoice_auto"},
            entries=entries
        )

        result = await create_transaction(transaction)
        return {"status": "ok", **result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Ny GET-endpoint för att flagga avvikande transaktioner
@router.get("/anomalies", dependencies=[Depends(verify_token)])
async def get_anomalies():
    from .services import detect_anomalies
    db_url = os.environ["LOCAL_DB_URL"]
    try:
        anomalies = await detect_anomalies(db_url)
        return JSONResponse(content={"status": "ok", "anomalies": anomalies})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Ny GET-endpoint för budget vs actual
from typing import Optional

@router.get("/report/budget_vs_actual", dependencies=[Depends(verify_token)])
async def get_budget_vs_actual(year: Optional[int] = Query(None), month: Optional[int] = Query(None)):
    from .services import generate_budget_vs_actual
    db_url = os.environ["LOCAL_DB_URL"]
    data = await generate_budget_vs_actual(db_url, year=year, month=month)
    return JSONResponse(content={"status": "ok", "result": data})

@router.post("/suggest_periodization")
async def suggest_periodization_api(payload: dict):
    from .suggest_accounting import suggest_periodization
    description = payload.get("description", "")
    total_amount = float(payload.get("total_amount", 0))
    suggestion = suggest_periodization(description, total_amount)
    return {"status": "ok", "periodization": suggestion}

@router.get("/report/cashflow", dependencies=[Depends(verify_token)])
async def get_cashflow_report():
    data = await generate_full_cashflow_report()
    return JSONResponse(content={"status": "ok", "result": data})

# Ny GET-endpoint för indirekt kassaflödesanalys
@router.get("/report/cashflow_indirect", dependencies=[Depends(verify_token)])
async def get_indirect_cashflow():
    from .services import generate_indirect_cashflow
    db_url = os.environ["LOCAL_DB_URL"]
    data = await generate_indirect_cashflow(db_url)
    return JSONResponse(content={"status": "ok", "result": data})


# --- BANK CSV UPLOAD ENDPOINT ---
@router.post("/bank/upload_csv", dependencies=[Depends(verify_token)])
async def upload_bank_csv(file: UploadFile = File(...)):
    db_url = os.environ["LOCAL_DB_URL"]
    content = await file.read()
    text = content.decode("utf-8")
    reader = csv.DictReader(StringIO(text))
    import asyncpg
    conn = await asyncpg.connect(dsn=db_url)
    count = 0
    for row in reader:
        await conn.execute("""
            INSERT INTO bank_statement (date, balance, source, metadata)
            VALUES ($1, $2, $3, $4)
            ON CONFLICT DO NOTHING
        """, row["date"], float(row["balance"]), row.get("source", "unknown"), row)
        count += 1
    await conn.close()
    return {"status": "ok", "imported": count}

# --- BANK RECONCILIATION ENDPOINT ---
@router.get("/bank/reconcile", dependencies=[Depends(verify_token)])
async def reconcile_bank(account_number: str = Query(...)):
    import asyncpg
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)

    rows = await conn.fetch("""
        SELECT TO_CHAR(t.date, 'YYYY-MM-DD') AS date, SUM(e.amount) AS balance
        FROM entry e
        JOIN transaction t ON e.transaction_id = t.id
        JOIN account a ON a.id = e.account_id
        WHERE a.number = $1
        GROUP BY t.date
    """, account_number)

    entries_by_date = {r["date"]: float(r["balance"]) for r in rows}

    banks = await conn.fetch("""
        SELECT TO_CHAR(date, 'YYYY-MM-DD') AS date, balance
        FROM bank_statement
        ORDER BY date
    """)

    await conn.close()

    diffs = []
    for row in banks:
        bdate = row["date"]
        bbal = float(row["balance"])
        expected = entries_by_date.get(bdate)
        if expected is not None and abs(expected - bbal) > 0.01:
            diffs.append({"date": bdate, "bank_balance": bbal, "accounting_balance": expected, "difference": round(expected - bbal, 2)})

    return {"status": "ok", "differences": diffs}
# --- SIE export endpoint ---

from typing import Optional
from fastapi import Query, Depends
from fastapi import HTTPException

@router.get("/export/sie", dependencies=[Depends(verify_token)])
async def export_sie(start_date: Optional[str] = Query(None), end_date: Optional[str] = Query(None)):
    from .services import generate_sie_export
    import datetime
    from fastapi.responses import PlainTextResponse

    try:
        start = datetime.date.fromisoformat(start_date) if start_date else None
        end = datetime.date.fromisoformat(end_date) if end_date else None
    except ValueError:
        raise HTTPException(status_code=400, detail="Felaktigt datumformat. Använd YYYY-MM-DD.")

    sie_data = await generate_sie_export(start, end)
    return PlainTextResponse(sie_data, media_type="text/plain", headers={
        "Content-Disposition": 'attachment; filename="export.se"'
    })
END: routes.py

====================
📄 Fil: modules/crm/services.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 10:06:33
📏 Antal rader: 67
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 3 – ['import os', 'import asyncpg', 'import json']
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 5
🧪 TODO/FIXME: 0
====================
START: services.py
import os
import asyncpg
from typing import List

import json

def fix_encoding(text):
    if isinstance(text, str):
        try:
            return text.encode("latin1").decode("utf-8")
        except Exception:
            return text
    return text

async def get_all_contacts():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            c.id,
            c.email,
            c.booking_email,
            c.metadata,
            COALESCE(b.count, 0) AS booking_count
        FROM contact c
        LEFT JOIN (
            SELECT contact_id, COUNT(*) AS count
            FROM bookings
            GROUP BY contact_id
        ) b ON c.id = b.contact_id
        ORDER BY c.created_at DESC
        LIMIT 100
    """)
    await conn.close()
    contacts = []
    for row in rows:
        metadata_raw = row["metadata"]
        if isinstance(metadata_raw, dict):
            metadata = metadata_raw
        elif isinstance(metadata_raw, str):
            try:
                metadata = json.loads(metadata_raw)
            except Exception:
                metadata = {}
        else:
            metadata = {}
        print("RAW last_name:", metadata.get("last_name"))
        contacts.append({
            "id": str(row["id"]),
            "email": row["email"],
            "booking_email": row["booking_email"],
            "first_name": fix_encoding(metadata.get("first_name")),
            "last_name": fix_encoding(metadata.get("last_name")),
            "company": fix_encoding(metadata.get("company")),
            "phone": metadata.get("phone"),
            "booking_count": row["booking_count"]
        })
    return contacts

async def get_contact_by_id(contact_id: str):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    row = await conn.fetchrow("SELECT * FROM contact WHERE id = $1", contact_id)
    await conn.close()
    if row:
        return dict(row)
    return {"error": "Contact not found"}
END: services.py

====================
📄 Fil: modules/crm/__init__.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 21:33:00
📏 Antal rader: 1
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: __init__.py
# __init__.py för local_backend/modules/crm

END: __init__.py

====================
📄 Fil: modules/crm/routes.py
📂 Kodtyp: 📄 Övrigt
🗂 Filtyp: 🐍 Python
📅 Senast ändrad: 2025-06-03 08:06:43
📏 Antal rader: 14
🧩 Antal funktioner: 0
💬 Kommentarstäckning: 0 rader (0.0%)
📥 Imports: 0 – Inga
🔍 Längsta funktion: 0 rader
🧠 Komplexitetspoäng: 0
🧪 TODO/FIXME: 0
====================
START: routes.py
from fastapi import APIRouter
from fastapi.responses import JSONResponse
from .services import get_all_contacts, get_contact_by_id

router = APIRouter(prefix="/contacts", tags=["contacts"])

@router.get("/")
async def list_contacts():
    data = await get_all_contacts()
    return JSONResponse(content=data, media_type="application/json; charset=utf-8")

@router.get("/{contact_id}")
async def get_contact(contact_id: str):
    return await get_contact_by_id(contact_id)
END: routes.py

📁 KONFIGURATIONSFILER (function.json / host.json / package.json / .funcignore)
====================================

Inga function.json, host.json, package.json eller .funcignore hittades i projektet.

📈 SUMMERING AV ALLA JS-FILER
====================================
📏 Totalt antal rader kod: 1625
🧩 Totalt antal funktioner: 0
🧠 Total komplexitetspoäng: 131
🧪 Antal TODO/FIXME totalt: 2

📊 Per fil:
fil,rader,funktioner,komplexitet,kommentarer,imports
config.py,9,0,0,0,1
__init__.py,1,0,0,0,0
main.py,59,0,3,0,1
__init__.py,1,0,0,0,0
__init__.py,1,0,0,0,0
services.py,21,0,2,0,1
__init__.py,1,0,0,0,0
routes.py,12,0,1,0,1
services.py,14,0,1,0,2
__init__.py,1,0,0,0,0
routes.py,8,0,0,0,0
services.py,13,0,0,0,0
__init__.py,1,0,0,0,0
routes.py,10,0,0,0,0
services.py,31,0,1,0,2
__init__.py,1,0,0,0,0
routes.py,16,0,0,0,0
services.py,477,0,56,0,7
suggest_accounting.py,272,0,38,1,5
__init__.py,19,0,0,0,0
export.py,69,0,6,0,5
schemas.py,47,0,0,0,0
routes.py,459,0,18,0,10
services.py,67,0,5,0,3
__init__.py,1,0,0,0,0
routes.py,14,0,0,0,0
