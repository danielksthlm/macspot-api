ğŸ“‚ KODTRÃ„D
==========
â”œâ”€â”€ local_backend
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ apple_contact_sync
â”‚   â”‚   â”œâ”€â”€ Package.swift
â”‚   â”‚   â”œâ”€â”€ Sources
â”‚   â”‚   â”‚   â”œâ”€â”€ main.swift
â”‚   â”œâ”€â”€ config.py
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ modules
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ accounting
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ accounts_payable
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ routes.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ services.py
â”‚   â”‚   â”‚   â”œâ”€â”€ base
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ export.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ gpt_invoice_parser.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ routes.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ schemas.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ services.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ suggest_accounting.py
â”‚   â”‚   â”‚   â”œâ”€â”€ closing
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ routes.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ services.py
â”‚   â”‚   â”‚   â”œâ”€â”€ invoicing
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ routes.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ services.py
â”‚   â”‚   â”‚   â”œâ”€â”€ tax_reporting
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ routes.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ services.py
â”‚   â”‚   â”‚   â”œâ”€â”€ tests
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ test_accounting.py
â”‚   â”‚   â”œâ”€â”€ crm
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ services.py
==========

====================
ğŸ“„ Fil: config.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-04 15:51:16
ğŸ“ Antal rader: 9
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 1 â€“ ['import os']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: config.py
import os
from dotenv import load_dotenv
from pathlib import Path

# Ladda .env frÃ¥n projektroten
env_path = Path(__file__).resolve().parents[2] / ".env"
load_dotenv(dotenv_path=env_path)

DB_DSN = os.getenv("LOCAL_DB_DSN")  # alt. bygg ihop frÃ¥n PGHOST, etc
END: config.py

====================
ğŸ“„ Fil: __init__.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:33:00
ğŸ“ Antal rader: 1
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: __init__.py
# __init__.py fÃ¶r local_backend

END: __init__.py

====================
ğŸ“„ Fil: main.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:26:28
ğŸ“ Antal rader: 59
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 1 â€“ ['import os']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 3
ğŸ§ª TODO/FIXME: 0
====================
START: main.py
from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi
from fastapi.security import APIKeyHeader
from fastapi.middleware.cors import CORSMiddleware
import os
from dotenv import load_dotenv
load_dotenv(dotenv_path=os.path.join(os.path.dirname(__file__), "..", ".env"))

# Routers frÃ¥n olika moduler
from local_backend.modules.crm.routes import router as crm_router
from local_backend.modules.accounting.base.routes import router as base_accounting_router
from local_backend.modules.accounting.tax_reporting.routes import router as tax_router
from local_backend.modules.accounting.closing.routes import router as closing_router
from local_backend.modules.accounting.invoicing.routes import router as invoicing_router
from local_backend.modules.accounting.accounts_payable.routes import router as payable_router

app = FastAPI()

api_key_header = APIKeyHeader(name="Authorization")

def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="MacSpot API",
        version="1.0.0",
        description="Redovisnings-API med autentisering",
        routes=app.routes,
    )
    openapi_schema["components"]["securitySchemes"] = {
        "APIKeyHeader": {
            "type": "apiKey",
            "in": "header",
            "name": "Authorization"
        }
    }
    for path in openapi_schema["paths"].values():
        for op in path.values():
            op.setdefault("security", []).append({"APIKeyHeader": []})
    app.openapi_schema = openapi_schema
    return openapi_schema

app.openapi = custom_openapi

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Inkludera routers
app.include_router(crm_router)
app.include_router(base_accounting_router)
app.include_router(tax_router)
app.include_router(closing_router)
app.include_router(invoicing_router)
app.include_router(payable_router)
END: main.py

====================
ğŸ“„ Fil: modules/__init__.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:33:00
ğŸ“ Antal rader: 1
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: __init__.py
# __init__.py fÃ¶r local_backend/modules

END: __init__.py

====================
ğŸ“„ Fil: modules/accounting/__init__.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:33:00
ğŸ“ Antal rader: 1
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: __init__.py
# __init__.py fÃ¶r local_backend/modules/accounting

END: __init__.py

====================
ğŸ“„ Fil: modules/accounting/tax_reporting/services.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:51:34
ğŸ“ Antal rader: 21
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 1 â€“ ['import asyncpg']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 2
ğŸ§ª TODO/FIXME: 0
====================
START: services.py
import asyncpg

async def generate_tax_report(db_url: str, year: int, month: int):
    conn = await asyncpg.connect(dsn=db_url)
    try:
        rows = await conn.fetch("""
            SELECT
                a.number AS account,
                a.name AS account_name,
                SUM(e.amount) AS total
            FROM entry e
            JOIN account a ON e.account_id = a.id
            WHERE EXTRACT(YEAR FROM e.created_at) = $1
              AND EXTRACT(MONTH FROM e.created_at) = $2
              AND a.number LIKE '26%'  -- momsrelaterade konton
            GROUP BY a.number, a.name
            ORDER BY a.number
        """, year, month)
        return [dict(r) for r in rows]
    finally:
        await conn.close()
END: services.py

====================
ğŸ“„ Fil: modules/accounting/tax_reporting/__init__.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:33:00
ğŸ“ Antal rader: 1
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: __init__.py
# __init__.py fÃ¶r local_backend/modules/accounting/tax_reporting

END: __init__.py

====================
ğŸ“„ Fil: modules/accounting/tax_reporting/routes.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:51:35
ğŸ“ Antal rader: 12
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 1 â€“ ['import os']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 1
ğŸ§ª TODO/FIXME: 0
====================
START: routes.py
from fastapi import APIRouter, Depends, Query
from fastapi.responses import JSONResponse
import os
from .services import generate_tax_report

router = APIRouter(prefix="/tax_reporting", tags=["tax_reporting"])

@router.get("/report", dependencies=[Depends(lambda: None)])  # Placeholder for auth
async def get_tax_report(year: int = Query(...), month: int = Query(...)):
    db_url = os.environ["LOCAL_DB_URL"]
    result = await generate_tax_report(db_url, year, month)
    return JSONResponse(content={"status": "ok", "report": result})
END: routes.py

====================
ğŸ“„ Fil: modules/accounting/tests/test_accounting.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-04 09:05:20
ğŸ“ Antal rader: 31
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 1 â€“ ['import pytest']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: test_accounting.py
import pytest
from httpx import AsyncClient
from uuid import uuid4
from local_backend.main import app

@pytest.mark.asyncio
async def test_invoice_to_transaction():
    # Detta krÃ¤ver att en attachment redan finns i databasen
    attachment_id = "00000000-0000-0000-0000-000000000000"  # byt till ett riktigt id vid test

    async with AsyncClient(base_url="http://localhost:8000") as ac:
        response = await ac.post(
            "/accounting/invoice_to_transaction",
            params={"attachment_id": attachment_id},
            headers={"Authorization": "Bearer hemlig_nyckel_123"}
        )
        assert response.status_code in [200, 422, 404]  # beror pÃ¥ testdata
        print("Svar:", response.json())

@pytest.mark.asyncio
async def test_invoice_gpt_analysis():
    attachment_id = "00000000-0000-0000-0000-000000000000"  # byt till riktig testbilaga

    async with AsyncClient(base_url="http://localhost:8000") as ac:
        response = await ac.post(
            "/accounting/invoice_gpt_analysis",
            params={"attachment_id": attachment_id},
            headers={"Authorization": "Bearer hemlig_nyckel_123"}
        )
        assert response.status_code in [200, 404]
        print("GPT-svar:", response.json())
END: test_accounting.py

====================
ğŸ“„ Fil: modules/accounting/accounts_payable/services.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:50:16
ğŸ“ Antal rader: 14
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ['import asyncpg', 'import os']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 1
ğŸ§ª TODO/FIXME: 0
====================
START: services.py
import asyncpg
import os

async def get_open_invoices():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT id, supplier, due_date, amount, status
        FROM invoice
        WHERE status = 'unpaid'
        ORDER BY due_date ASC
    """)
    await conn.close()
    return [dict(row) for row in rows]
END: services.py

====================
ğŸ“„ Fil: modules/accounting/accounts_payable/__init__.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:33:00
ğŸ“ Antal rader: 1
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: __init__.py
# __init__.py fÃ¶r local_backend/modules/accounting/accounts_payable

END: __init__.py

====================
ğŸ“„ Fil: modules/accounting/accounts_payable/routes.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:50:16
ğŸ“ Antal rader: 8
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: routes.py
from fastapi import APIRouter

router = APIRouter(prefix="/accounts_payable", tags=["Accounts Payable"])

@router.get("/open_invoices")
async def list_open_invoices():
    from .services import get_open_invoices
    return await get_open_invoices()
END: routes.py

====================
ğŸ“„ Fil: modules/accounting/invoicing/services.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:49:29
ğŸ“ Antal rader: 13
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: services.py
from datetime import date
from uuid import uuid4

async def generate_invoice():
    return {
        "invoice_id": str(uuid4()),
        "date": date.today().isoformat(),
        "total": 2500.00,
        "currency": "SEK",
        "items": [
            {"description": "KonsulttjÃ¤nster maj", "quantity": 10, "unit_price": 250.00}
        ]
    }
END: services.py

====================
ğŸ“„ Fil: modules/accounting/invoicing/__init__.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:33:00
ğŸ“ Antal rader: 1
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: __init__.py
# __init__.py fÃ¶r local_backend/modules/accounting/invoicing

END: __init__.py

====================
ğŸ“„ Fil: modules/accounting/invoicing/routes.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:49:28
ğŸ“ Antal rader: 10
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: routes.py
from fastapi import APIRouter
from .services import generate_invoice
from fastapi.responses import JSONResponse

router = APIRouter(prefix="/invoicing", tags=["invoicing"])

@router.get("/generate_invoice")
async def generate_invoice_route():
    invoice = await generate_invoice()
    return JSONResponse(content={"status": "ok", "invoice": invoice})
END: routes.py

====================
ğŸ“„ Fil: modules/accounting/closing/services.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:46:55
ğŸ“ Antal rader: 31
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ['import asyncpg', 'import os']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 1
ğŸ§ª TODO/FIXME: 0
====================
START: services.py
import asyncpg
import os
from datetime import date, timedelta

async def lock_period_service():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    today = date.today()
    result = await conn.execute("""
        UPDATE period
        SET locked = true
        WHERE end_date < $1 AND locked = false
    """, today)
    await conn.close()
    return f"Perioder lÃ¥sta: {result}"

async def perform_year_end_closing():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    latest = await conn.fetchrow("SELECT end_date FROM period ORDER BY end_date DESC LIMIT 1")
    if not latest:
        await conn.close()
        return "Ingen tidigare period hittades"
    new_start = latest["end_date"] + timedelta(days=1)
    new_end = new_start.replace(year=new_start.year + 1) - timedelta(days=1)
    await conn.execute("""
        INSERT INTO period (id, start_date, end_date, locked, name, created_at)
        VALUES (gen_random_uuid(), $1, $2, false, $3, now())
    """, new_start, new_end, f"{new_start.year}")
    await conn.close()
    return f"Ny period skapad: {new_start} â€“ {new_end}"
END: services.py

====================
ğŸ“„ Fil: modules/accounting/closing/__init__.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:33:00
ğŸ“ Antal rader: 1
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: __init__.py
# __init__.py fÃ¶r local_backend/modules/accounting/closing

END: __init__.py

====================
ğŸ“„ Fil: modules/accounting/closing/routes.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:45:47
ğŸ“ Antal rader: 16
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: routes.py
from fastapi import APIRouter
from fastapi.responses import JSONResponse

from .services import lock_period_service, perform_year_end_closing

router = APIRouter(prefix="/closing", tags=["closing"])

@router.post("/lock_period")
async def lock_period():
    result = await lock_period_service()
    return JSONResponse(content={"status": "ok", "message": result})

@router.post("/year_end")
async def year_end():
    result = await perform_year_end_closing()
    return JSONResponse(content={"status": "ok", "message": result})
END: routes.py

====================
ğŸ“„ Fil: modules/accounting/base/services.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-04 08:18:32
ğŸ“ Antal rader: 483
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 7 â€“ ['import os', 'import asyncpg', 'import os', 'import asyncpg', 'import json', 'import json', 'import json']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 57
ğŸ§ª TODO/FIXME: 0
====================
START: services.py
from typing import Optional
import os
import asyncpg

async def generate_resultatrapport():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT rs.group_name, SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN report_structure rs
          ON (a.number = rs.account_number OR a.number BETWEEN split_part(rs.account_range, '-', 1)::text AND split_part(rs.account_range, '-', 2)::text)
        WHERE rs.report_type = 'resultat'
        GROUP BY rs.group_name, rs.order_index
        ORDER BY rs.order_index
    """)
    await conn.close()
    return [{"group": row["group_name"], "total": float(row["total"])} for row in rows]

async def generate_balansrapport():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT rs.group_name, SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN report_structure rs
          ON (a.number = rs.account_number OR a.number BETWEEN split_part(rs.account_range, '-', 1)::text AND split_part(rs.account_range, '-', 2)::text)
        WHERE rs.report_type = 'balans'
        GROUP BY rs.group_name, rs.order_index
        ORDER BY rs.order_index
    """)
    await conn.close()
    return [{"group": row["group_name"], "total": float(row["total"])} for row in rows]

async def generate_momsrapport():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT rs.group_name, SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN report_structure rs
          ON (a.number = rs.account_number OR a.number BETWEEN split_part(rs.account_range, '-', 1)::text AND split_part(rs.account_range, '-', 2)::text)
        WHERE rs.report_type = 'moms'
        GROUP BY rs.group_name, rs.order_index
        ORDER BY rs.order_index
    """)
    await conn.close()
    results = [{"group": row["group_name"], "total": float(row["total"])} for row in rows]
    netto = sum(r["total"] for r in results)
    results.append({"group": "Netto att betala", "total": netto})
    return results
async def get_chart_of_accounts(language="sv"):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT
            a.number,
            COALESCE(t.name, a.name) AS name,
            a.type,
            a.is_active,
            a.report_type,
            a.report_group
        FROM account a
        LEFT JOIN account_translation t
          ON t.account_id = a.id AND t.language = $1
        ORDER BY a.number
    """, language)
    await conn.close()
    return [dict(row) for row in rows]
from .schemas import TransactionIn
from uuid import uuid4
from decimal import Decimal
from datetime import datetime
import os
import asyncpg
import json

def fix_encoding(text):
    if isinstance(text, str):
        try:
            return text.encode("latin1").decode("utf-8")
        except Exception:
            return text
    return text

async def get_accounts(language="sv"):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            a.id,
            a.number,
            COALESCE(t.name, a.name) AS name,
            a.type
        FROM account a
        LEFT JOIN account_translation t
          ON t.account_id = a.id AND t.language = $1
        ORDER BY a.number
    """, language)
    await conn.close()
    from uuid import UUID
    return [
        {
            k: fix_encoding(str(v)) if isinstance(v, str) else str(v) if isinstance(v, UUID) else v
            for k, v in row.items()
        }
        for row in rows
    ]

async def get_transactions(language="sv", filter_user=None):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    # Prepare for future translation of 'description' via transaction_translation
    rows = await conn.fetch("""
        SELECT
            t.id,
            t.date,
            COALESCE(tt.description, t.description) AS description,
            t.description AS original_description,
            t.series,
            t.ver_no,
            t.metadata,
            t.created_at,
            json_agg(json_build_object(
                'id', e.id,
                'account_id', e.account_id,
                'amount', e.amount,
                'description', e.description,
                'metadata', e.metadata
            )) AS entries
        FROM transaction t
        LEFT JOIN transaction_translation tt
          ON tt.transaction_id = t.id AND tt.language = $1
        LEFT JOIN entry e ON e.transaction_id = t.id
        WHERE ($2::text IS NULL OR t.metadata->>'user' = $2)
        GROUP BY t.id, tt.description
        ORDER BY t.date DESC, t.ver_no DESC
        LIMIT 100
    """, language, filter_user)
    await conn.close()
    from uuid import UUID
    from datetime import date
    result = []
    for row in rows:
        user = None
        try:
            user = json.loads(row["metadata"]).get("user")
        except Exception:
            pass
        has_translation = row["description"] != row["original_description"]
        obj = {
            k: fix_encoding(str(v)) if isinstance(v, str)
            else str(v) if isinstance(v, (UUID, date))
            else v
            for k, v in row.items()
        }
        obj["has_translation"] = has_translation
        obj["user"] = user
        result.append(obj)
    return result


# Skapa ny funktion fÃ¶r att skapa transaktion
async def create_transaction(transaction: TransactionIn):
    import json
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)

    default_user = os.getenv("DEFAULT_USER_EMAIL", "unknown@local")

    # HÃ¤mta nÃ¤sta ver_no fÃ¶r serien
    ver_row = await conn.fetchrow("""
        UPDATE journal_series
        SET next_ver_no = next_ver_no + 1
        WHERE series = $1
        RETURNING next_ver_no - 1 AS ver_no
    """, transaction.series)
    if not ver_row:
        await conn.close()
        raise ValueError(f"Ogiltig verifikationsserie: {transaction.series}")
    ver_no = ver_row["ver_no"]

    # HÃ¤mta alla kontonummer i en gÃ¥ng
    account_rows = await conn.fetch("SELECT id, number FROM account")
    account_map = {r["number"]: r["id"] for r in account_rows}

    # Kontroll: alla konton mÃ¥ste finnas
    for entry in transaction.entries:
        if entry.account_number not in account_map:
            await conn.close()
            raise ValueError(f"Konto saknas: {entry.account_number}")

    # Kontroll: debet = kredit
    total = sum([entry.amount for entry in transaction.entries])
    if total != Decimal("0.00"):
        await conn.close()
        raise ValueError(f"Obalanserad transaktion: {total}")

    # Kontrollera metadata och sÃ¤tt user om saknas, serialisera till JSON-strÃ¤ng
    metadata_dict = transaction.metadata or {}
    if "user" not in metadata_dict:
        metadata_dict["user"] = default_user
    # --- created_by lookup ---
    created_by = None
    user_email = metadata_dict.get("user", default_user)
    contact_row = await conn.fetchrow("SELECT id FROM contact WHERE email = $1", user_email)
    if contact_row:
        created_by = contact_row["id"]
    metadata = json.dumps(metadata_dict)

    # Skapa verifikat
    tx_id = uuid4()
    now = datetime.utcnow()
    await conn.execute("""
        INSERT INTO transaction (id, date, description, series, ver_no, metadata, created_at, updated_at, status, created_by)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $7, $8, $9)
    """, tx_id, transaction.date, transaction.description, transaction.series, ver_no, metadata, now, transaction.status, created_by)

    import json
    for entry in transaction.entries:
        entry_metadata = entry.metadata or {}
        entry_metadata["user"] = entry_metadata.get("user", metadata_dict["user"])
        entry_metadata["generated_by"] = entry_metadata.get("generated_by", "macspot-backend")
        entry_metadata = json.dumps(entry_metadata)
        await conn.execute("""
            INSERT INTO entry (id, transaction_id, account_id, amount, description, metadata, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
        """, uuid4(), tx_id, account_map[entry.account_number], entry.amount,
             entry.description, entry_metadata, now)

    await conn.close()
    return {"status": "ok", "transaction_id": str(tx_id), "series": transaction.series, "ver_no": ver_no}


# Avvikelse-/felupptÃ¤ckt
async def detect_anomalies():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    try:
        rows = await conn.fetch("""
            SELECT t.id, t.description, t.date, t.ver_no, a.number AS account_number, e.amount
            FROM transaction t
            JOIN entry e ON e.transaction_id = t.id
            JOIN account a ON a.id = e.account_id
            WHERE t.date > now() - interval '12 months'
        """)
        seen = set()
        anomalies = []
        for r in rows:
            key = (r["description"], float(r["amount"]))
            if key in seen:
                anomalies.append({
                    "transaction_id": str(r["id"]),
                    "ver_no": r["ver_no"],
                    "reason": "Dublett: samma text och belopp",
                    "description": r["description"],
                    "amount": float(r["amount"]),
                    "date": r["date"].isoformat(),
                })
            else:
                seen.add(key)
            if abs(float(r["amount"])) > 50000:
                anomalies.append({
                    "transaction_id": str(r["id"]),
                    "ver_no": r["ver_no"],
                    "reason": "HÃ¶gt belopp",
                    "description": r["description"],
                    "amount": float(r["amount"]),
                    "date": r["date"].isoformat(),
                })
    finally:
        await conn.close()
    return anomalies

# --- Budget vs Actual report
async def generate_budget_vs_actual(db_url: str, year: Optional[int] = None, month: Optional[int] = None):
    conditions = []
    values = []

    if year:
        conditions.append("b.year = $%d" % (len(values)+1))
        values.append(year)
    if month:
        conditions.append("b.month = $%d" % (len(values)+1))
        values.append(month)

    where_clause = f"WHERE {' AND '.join(conditions)}" if conditions else ""

    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch(f"""
        SELECT
            b.year,
            b.month,
            b.account_number,
            b.amount AS budget,
            COALESCE(SUM(e.amount), 0) AS actual
        FROM budget b
        LEFT JOIN account a ON a.number = b.account_number
        LEFT JOIN entry e ON e.account_id = a.id
          AND EXTRACT(YEAR FROM e.created_at) = b.year
          AND EXTRACT(MONTH FROM e.created_at) = b.month
        {where_clause}
        GROUP BY b.year, b.month, b.account_number, b.amount
        ORDER BY b.year, b.month, b.account_number
    """, *values)
    await conn.close()
    return [dict(r) for r in rows]

async def generate_cashflow_report():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            TO_CHAR(t.date, 'YYYY-MM') AS period,
            SUM(e.amount) FILTER (WHERE a.type = 'tillgÃ¥ng' AND e.amount > 0) AS inflow,
            SUM(e.amount) FILTER (WHERE a.type = 'tillgÃ¥ng' AND e.amount < 0) AS outflow
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN transaction t ON e.transaction_id = t.id
        GROUP BY period
        ORDER BY period
    """)
    await conn.close()
    return [dict(r) for r in rows]

async def generate_full_cashflow_report():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            TO_CHAR(t.date, 'YYYY-MM') AS period,
            a.number AS account_number,
            a.name AS account_name,
            a.type AS account_type,
            SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN transaction t ON e.transaction_id = t.id
        WHERE a.type IN ('tillgÃ¥ng', 'skuld')
        GROUP BY period, a.number, a.name, a.type
        ORDER BY period, a.number
    """)
    await conn.close()

    # Strukturera datan
    cashflow = {}
    for r in rows:
        period = r["period"]
        if period not in cashflow:
            cashflow[period] = {
                "period": period,
                "accounts": []
            }
        cashflow[period]["accounts"].append({
            "account_number": r["account_number"],
            "account_name": r["account_name"],
            "account_type": r["account_type"],
            "amount": float(r["total"])
        })

    return list(cashflow.values())


# Ny funktion: indirekt kassaflÃ¶desanalys
async def generate_indirect_cashflow(db_url: str):
    conn = await asyncpg.connect(dsn=db_url)
    try:
        # Steg 1: HÃ¤mta Ã¥rets resultat (nettoresultat)
        net_result_row = await conn.fetchrow("""
            SELECT SUM(e.amount) AS net_income
            FROM entry e
            JOIN account a ON e.account_id = a.id
            WHERE a.report_type = 'resultat'
        """)

        # Steg 2: Justera fÃ¶r icke-kassapÃ¥verkande poster (t.ex. avskrivningar)
        adjustments = await conn.fetch("""
            SELECT a.number, a.name, SUM(e.amount) AS total
            FROM entry e
            JOIN account a ON e.account_id = a.id
            WHERE a.number LIKE '7%' -- t.ex. avskrivningar: 7830 etc.
            GROUP BY a.number, a.name
        """)

        # Steg 3: FÃ¶rÃ¤ndringar i rÃ¶relsekapital (tillgÃ¥ngar och skulder)
        working_capital = await conn.fetch("""
            SELECT a.type, a.number, a.name, SUM(e.amount) AS delta
            FROM entry e
            JOIN account a ON e.account_id = a.id
            WHERE a.type IN ('tillgÃ¥ng', 'skuld')
            GROUP BY a.type, a.number, a.name
        """)

        await conn.close()

        return {
            "net_income": float(net_result_row["net_income"] or 0),
            "adjustments": [
                {
                    "account": r["number"],
                    "name": r["name"],
                    "amount": float(r["total"])
                } for r in adjustments
            ],
            "working_capital_changes": [
                {
                    "account": r["number"],
                    "name": r["name"],
                    "type": r["type"],
                    "delta": float(r["delta"])
                } for r in working_capital
            ]
        }
    except Exception as e:
        await conn.close()
        raise

# Ny funktion: kontoavstÃ¤mning fÃ¶r ett specifikt konto
async def generate_reconciliation_report(db_url: str, account_number: str):
    conn = await asyncpg.connect(dsn=db_url)
    try:
        rows = await conn.fetch("""
            SELECT t.date, t.description, e.amount
            FROM entry e
            JOIN transaction t ON t.id = e.transaction_id
            JOIN account a ON a.id = e.account_id
            WHERE a.number = $1
            ORDER BY t.date
        """, account_number)
        total = sum([r["amount"] for r in rows])
        transactions = [{
            "date": r["date"].isoformat(),
            "description": r["description"],
            "amount": float(r["amount"])
        } for r in rows]
        return {
            "account_number": account_number,
            "total_balance": float(total),
            "transactions": transactions
        }
    finally:
        await conn.close()

# --- SIE export ---
async def generate_sie_export(start_date=None, end_date=None):
    conn = await asyncpg.connect(dsn=os.environ["LOCAL_DB_URL"])
    try:
        sie_lines = []
        sie_lines.append("#FLAGGA 0")
        sie_lines.append("#FORMAT PC8")
        sie_lines.append("#GEN 2")
        sie_lines.append("#SIETYP 4")
        sie_lines.append("#PROGRAM macspot 1.0")
        sie_lines.append(f"#ORGNR 000000-0000")
        sie_lines.append(f"#FNAMN Ditt FÃ¶retag AB")

        # Kontoplan
        accounts = await conn.fetch("SELECT number, name FROM account ORDER BY number")
        for acc in accounts:
            sie_lines.append(f"#KONTO {acc['number']} \"{acc['name']}\"")

        # Verifikationer
        query = """
            SELECT t.id, t.date, t.series, t.ver_no, t.description, e.amount, a.number AS account
            FROM transaction t
            JOIN entry e ON e.transaction_id = t.id
            JOIN account a ON a.id = e.account_id
            WHERE ($1::date IS NULL OR t.date >= $1)
              AND ($2::date IS NULL OR t.date <= $2)
            ORDER BY t.date, t.ver_no
        """
        rows = await conn.fetch(query, start_date, end_date)
        for row in rows:
            datum = row["date"].strftime("%Y%m%d")
            sie_lines.append(f"#{'VER'} \"{row['series']}\" {datum} \"{row['description']}\"")
            sie_lines.append(f"#{'TRANS'} {row['account']} {row['amount']} \"\"")

        return "\n".join(sie_lines)
    finally:
        await conn.close()
END: services.py

====================
ğŸ“„ Fil: modules/accounting/base/suggest_accounting.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-04 08:04:51
ğŸ“ Antal rader: 302
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 1 rader (0.3%)
ğŸ“¥ Imports: 5 â€“ ['import re', 'import fitz  # PyMuPDF', 'import asyncpg', 'import os', 'import asyncpg']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 45
ğŸ§ª TODO/FIXME: 2
====================
START: suggest_accounting.py
import re
from typing import Optional, Dict
import fitz  # PyMuPDF
# from .match_supplier import match_supplier_name

# Import GPT invoice parser from separate module
from .gpt_invoice_parser import parse_invoice_with_gpt


def parse_invoice_text(text: str) -> Dict[str, Optional[str]]:
    text = text.replace(",", ".")  # Normalize decimal separator
    text = text.replace("O", "0").replace("I", "1")
    numbers = [float(m.group()) for m in re.finditer(r"\d{1,3}(?:[ ]?\d{3})*(?:\.\d{2})", text)]
    total_amount = max(numbers) if numbers else None

    vat_patterns = {
        "25%": r"(25\s?%|moms\s?25\s?%)",
        "12%": r"(12\s?%)",
        "6%": r"(6\s?%)"
    }
    vat_detected = None
    for rate, pattern in vat_patterns.items():
        if re.search(pattern, text, re.IGNORECASE):
            vat_detected = rate
            break
    if not vat_detected:
        vat_detected = "25%"

    date_patterns = [r"\d{4}-\d{2}-\d{2}", r"\d{2}/\d{2}/\d{4}", r"\d{2}\.\d{2}\.\d{4}"]
    invoice_date = None
    for pattern in date_patterns:
        match = re.search(pattern, text)
        if match:
            invoice_date = match.group()
            break

    ocr_match = re.search(r"(OCR|Referens)?\s*[:#]?\s?(\d{6,})", text, re.IGNORECASE)
    reference = ocr_match.group(2) if ocr_match else None

    currency_match = re.search(r"(SEK|kr|EUR|â‚¬|USD|\$)", text, re.IGNORECASE)
    currency = currency_match.group() if currency_match else "SEK"

    orgnr = re.search(r"\b\d{6}-\d{4}\b", text)  # Ex: 556123-4567
    iban = re.search(r"[A-Z]{2}\d{2}[ ]?\d{4}[ ]?\d{4}[ ]?\d{4}[ ]?\d{4}", text)

    return {
        "total_amount": total_amount,
        "vat_rate": vat_detected,
        "invoice_date": invoice_date,
        "reference_number": reference,
        "currency": currency,
        "orgnr": orgnr.group() if orgnr else None,
        "iban": iban.group() if iban else None,
        # TODO: match supplier by name/orgnr/IBAN
    }


def extract_text_from_pdf(pdf_bytes: bytes) -> str:
    try:
        doc = fitz.open(stream=pdf_bytes, filetype="pdf")
        all_text = []
        for page in doc:
            all_text.append(page.get_text())
        return "\n".join(all_text)
    except Exception as e:
        return f"ERROR: {e.__class__.__name__} â€“ {str(e)}"


# --- NEW FUNCTION ---
async def analyze_invoice_attachment(attachment_id: str, db_url: str) -> dict:
    import asyncpg
    from datetime import datetime
    conn = await asyncpg.connect(dsn=db_url)
    row = await conn.fetchrow("SELECT data FROM attachment WHERE id = $1", attachment_id)
    await conn.close()
    if not row:
        return {"error": "Attachment not found"}
    text = extract_text_from_pdf(row["data"])
    parsed = parse_invoice_text(text)
    needs_fallback = False
    try:
        parsed_date = parsed.get("invoice_date")
        if parsed_date:
            try:
                invoice_date_obj = datetime.strptime(parsed_date[:10], "%Y-%m-%d")
                if invoice_date_obj > datetime.now():
                    needs_fallback = True
            except ValueError:
                needs_fallback = True
        else:
            needs_fallback = True

        total = parsed.get("total_amount")
        if not total or float(total) < 10 or float(total) > 1_000_000:
            needs_fallback = True

        if not parsed.get("reference_number"):
            needs_fallback = True
    except Exception:
        needs_fallback = True

    if needs_fallback:
        gpt_parsed = parse_invoice_with_gpt(text, log=True)
        parsed.update({k: v for k, v in gpt_parsed.items() if v})
    parsed["supplier_name"] = "UNKNOWN"
    return {"text": text, "parsed": parsed}

def generate_transaction_from_parsed(parsed: dict, supplier_name: str = "", currency: str = "SEK") -> dict:
    supplier_name = parsed.get("supplier_name", supplier_name)
    description = f"Faktura {supplier_name}".strip()
    total = parsed.get("total_amount")
    vat_rate = parsed.get("vat_rate")
    date = parsed.get("invoice_date") or ""
    ref = parsed.get("reference_number") or ""
    currency = parsed.get("currency", currency)

    if not total or not vat_rate:
        return {}

    total = round(float(total), 2)
    vat_factor = {"25%": 0.2, "12%": 0.1071, "6%": 0.0566}.get(vat_rate, 0.2)
    vat_amount = round(total * vat_factor / (1 + vat_factor), 2)
    net_amount = round(total - vat_amount, 2)

    raw_entries = [
        {
            "account_number": "3001",
            "amount": -net_amount,
            "description": "FÃ¶rsÃ¤ljning",
            "currency": currency
        },
        {
            "account_number": "2611",
            "amount": -vat_amount,
            "description": f"Moms {vat_rate}",
            "currency": currency
        },
        {
            "account_number": "1930",
            "amount": total,
            "description": "Inbetalning",
            "currency": currency
        }
    ]
    entries = apply_regulatory_rules(parsed, raw_entries)

    return {
        "description": description,
        "date": date,
        "reference": ref,
        "currency": currency,
        "entries": entries
    }
def detect_anomalies(transactions: list) -> list:
    anomalies = []
    for tx in transactions:
        seen_refs = set()
        ref = tx.get("reference", "")
        if ref in seen_refs:
            anomalies.append({
                "transaction_id": tx.get("id"),
                "issue": f"Duplicate reference: {ref}"
            })
        elif ref:
            seen_refs.add(ref)
        for entry in tx.get("entries", []):
            desc = entry.get("description", "").lower()
            amount = abs(entry.get("amount", 0))
            if "lunch" in desc or "middag" in desc:
                if amount > 1000:
                    anomalies.append({
                        "transaction_id": tx.get("id"),
                        "issue": f"High meal expense: {amount} SEK"
                    })
            if entry.get("account_number") == "3001" and amount > 500000:
                anomalies.append({
                    "transaction_id": tx.get("id"),
                    "issue": f"Unusually high revenue: {amount} SEK"
                })
            if entry.get("account_number") == "2641" and float(entry.get("amount", 0)) > 0:
                anomalies.append({
                    "transaction_id": tx.get("id"),
                    "issue": "Possible VAT paid on purchase (check for reverse charge)"
                })
    return anomalies

def suggest_periodization(description: str, total_amount: float) -> Optional[dict]:
    """
    FÃ¶rsÃ¶k periodisera kostnader automatiskt.
    T.ex. Dropbox-abonnemang 1200 SEK â†’ 100 SEK/mÃ¥nad i 12 mÃ¥nader.
    """
    description = description.lower()
    recurring_keywords = ["abonnemang", "dropbox", "google", "office365", "fÃ¶rsÃ¤kring", "hyra", "licens"]
    if any(word in description for word in recurring_keywords) and total_amount > 1000:
        monthly = round(total_amount / 12, 2)
        return {
            "type": "monthly",
            "months": 12,
            "monthly_amount": monthly,
            "total": total_amount
        }
    return None

def apply_regulatory_rules(parsed: dict, entries: list) -> list:
    """
    Justera konton, moms och texter enligt svenska redovisningsregler:
    - Representation (avdragsgill/ej avdragsgill)
    - OmvÃ¤nd moms (EU-handel)
    - AvdragsgrÃ¤nser
    """
    adjusted = []
    description_text = parsed.get("description", "").lower()
    vat_rate = parsed.get("vat_rate", "25%")
    currency = parsed.get("currency", "SEK")
    total = parsed.get("total_amount", 0)

    for entry in entries:
        account = entry["account_number"]
        text = entry["description"].lower()
        amount = entry["amount"]

        # Representation
        if "lunch" in text or "middag" in text or "representation" in text:
            if abs(amount) > 300:
                account = "5832"  # ej avdragsgill representation
            else:
                account = "5831"  # avdragsgill representation

        # EU-handel (om moms = 0% + utlÃ¤ndsk valuta â†’ anta EU-tjÃ¤nst)
        if vat_rate == "0%" or vat_rate == "0" or vat_rate is None:
            if currency != "SEK":
                if amount < 0:
                    account = "2645"  # IngÃ¥ende moms omvÃ¤nd skattskyldighet
                else:
                    account = "2614"  # UtgÃ¥ende moms omvÃ¤nd skattskyldighet

        # TODO: LÃ¤gg till fler regler hÃ¤r vid behov
        adjusted.append({
            **entry,
            "account_number": account,
            "currency": currency
        })

    return adjusted

# --- NEW FUNCTION ---
import os
import asyncpg

async def generate_cashflow_report():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            TO_CHAR(t.date, 'YYYY-MM') AS period,
            SUM(e.amount) FILTER (WHERE a.type = 'tillgÃ¥ng' AND e.amount > 0) AS inflow,
            SUM(e.amount) FILTER (WHERE a.type = 'tillgÃ¥ng' AND e.amount < 0) AS outflow
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN transaction t ON e.transaction_id = t.id
        GROUP BY period
        ORDER BY period
    """)
    await conn.close()
    return [dict(r) for r in rows]

async def generate_full_cashflow_report():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            TO_CHAR(t.date, 'YYYY-MM') AS period,
            a.number AS account_number,
            a.name AS account_name,
            a.type AS account_type,
            SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        JOIN transaction t ON e.transaction_id = t.id
        WHERE a.type IN ('tillgÃ¥ng', 'skuld')
        GROUP BY period, a.number, a.name, a.type
        ORDER BY period, a.number
    """)
    await conn.close()

    # Strukturera datan
    cashflow = {}
    for r in rows:
        period = r["period"]
        if period not in cashflow:
            cashflow[period] = {
                "period": period,
                "accounts": []
            }
        cashflow[period]["accounts"].append({
            "account_number": r["account_number"],
            "account_name": r["account_name"],
            "account_type": r["account_type"],
            "amount": float(r["total"])
        })

    return list(cashflow.values())
END: suggest_accounting.py

====================
ğŸ“„ Fil: modules/accounting/base/__init__.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:33:00
ğŸ“ Antal rader: 19
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: __init__.py
from .services import *
from .schemas import *
from .suggest_accounting import *
from .export import *

__all__ = [
    "create_transaction",
    "get_accounts",
    "get_transactions",
    "generate_resultatrapport",
    "generate_balansrapport",
    "generate_momsrapport",
    "generate_sie_export",
    "analyze_invoice_attachment",
    "generate_transaction_from_parsed",
    "suggest_account",
    "suggest_periodization",
    "detect_anomalies"
]

END: __init__.py

====================
ğŸ“„ Fil: modules/accounting/base/export.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 17:44:30
ğŸ“ Antal rader: 69
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 5 â€“ ['import os', 'import json', 'import datetime', 'import asyncpg', 'import asyncio']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 6
ğŸ§ª TODO/FIXME: 0
====================
START: export.py
import os
from dotenv import load_dotenv
import json
import datetime
import asyncpg
import asyncio

load_dotenv(dotenv_path="/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot/macspot-api/.env")

EXPORT_ROOT = "/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot/exports/accounting"
EXPORT_DATA_DIR = os.path.join(EXPORT_ROOT, "exportdata")
EXPORT_ATTACHMENTS_DIR = os.path.join(EXPORT_ROOT, "attachments")

DB_CONFIG = {
    "user": os.environ["LOCAL_DB_USER"],
    "password": os.environ["LOCAL_DB_PASSWORD"],
    "database": os.environ["LOCAL_DB_NAME"],
    "host": os.environ["LOCAL_DB_HOST"],
    "port": os.environ["LOCAL_DB_PORT"]
}

async def export_data():
    os.makedirs(EXPORT_DATA_DIR, exist_ok=True)
    os.makedirs(EXPORT_ATTACHMENTS_DIR, exist_ok=True)

    date_str = datetime.datetime.now().strftime("%Y-%m-%d")
    data_dir = os.path.join(EXPORT_DATA_DIR, date_str)
    os.makedirs(data_dir, exist_ok=True)

    conn = await asyncpg.connect(**DB_CONFIG)

    # Export transactions
    transactions = await conn.fetch("SELECT * FROM transaction")
    with open(os.path.join(data_dir, "transactions.json"), "w") as f:
        json.dump([dict(r) for r in transactions], f, default=str, indent=2)

    # Export accounts
    accounts = await conn.fetch("SELECT * FROM account")
    with open(os.path.join(data_dir, "accounts.json"), "w") as f:
        json.dump([dict(r) for r in accounts], f, indent=2, default=str)

    # Export momsrapport
    moms = await conn.fetch("""
        SELECT 
          CASE 
            WHEN a.number LIKE '26%' THEN 'UtgÃ¥ende moms' 
            WHEN a.number LIKE '264%' THEN 'IngÃ¥ende moms' 
            ELSE 'Annat' 
          END AS group_name,
          SUM(e.amount) AS total
        FROM entry e
        JOIN account a ON e.account_id = a.id
        GROUP BY group_name
    """)
    with open(os.path.join(data_dir, "momsrapport.json"), "w") as f:
        json.dump([dict(r) for r in moms], f, indent=2, default=str)

    # Export attachments
    attachments = await conn.fetch("SELECT id, filename, data FROM attachment")
    for a in attachments:
        file_path = os.path.join(EXPORT_ATTACHMENTS_DIR, f"{a['id']}_{a['filename']}")
        with open(file_path, "wb") as f:
            f.write(a["data"])

    await conn.close()
    print(f"âœ… Export klar: {data_dir}")

if __name__ == "__main__":
    asyncio.run(export_data())
END: export.py

====================
ğŸ“„ Fil: modules/accounting/base/schemas.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-04 08:15:57
ğŸ“ Antal rader: 49
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: schemas.py
from typing import Optional, List
from uuid import UUID
from decimal import Decimal
from datetime import date

from pydantic import BaseModel, Field

class TransactionTranslationOut(BaseModel):
    transaction_id: UUID
    language: str
    description: str

class TransactionTranslationIn(BaseModel):
    transaction_id: UUID
    language: str
    description: str

class EntryIn(BaseModel):
    account_number: str
    amount: Decimal
    description: Optional[str] = None
    metadata: Optional[dict] = None


class TransactionIn(BaseModel):
    date: date
    description: Optional[str] = None
    series: str = Field(default="A", max_length=10)
    metadata: Optional[dict] = None
    entries: List[EntryIn]
    status: Optional[str] = Field(default="prelim", pattern="^(prelim|posted|locked)$")

class EntryOut(BaseModel):
    id: UUID
    account_id: UUID
    amount: Decimal
    description: Optional[str]
    metadata: Optional[dict]

class TransactionOut(BaseModel):
    id: UUID
    date: date
    description: Optional[str]
    series: str
    ver_no: int
    metadata: Optional[dict]
    entries: List[EntryOut]
    user: Optional[str] = None
    status: Optional[str]
END: schemas.py

====================
ğŸ“„ Fil: modules/accounting/base/gpt_invoice_parser.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-04 08:01:38
ğŸ“ Antal rader: 60
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 3 â€“ ['import openai', 'import json', 'import os']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 1
ğŸ§ª TODO/FIXME: 0
====================
START: gpt_invoice_parser.py
from typing import Optional, Dict
import openai
import json
import os
from dotenv import load_dotenv
from datetime import datetime

def parse_invoice_with_gpt(text: str, log: bool = False) -> Dict[str, Optional[str]]:
    load_dotenv()
    openai.api_key = os.getenv("OPENAI_API_KEY")

    prompt = f"""
    Du Ã¤r en redovisningsexpert som extraherar data frÃ¥n OCR-scannade fakturor i PDF-format.
    Svara alltid med ett strikt JSON-objekt. Ingen fÃ¶rklaring.

    Extrahera fÃ¶ljande fÃ¤lt:
    - total_amount (float)
    - vat_rate (t.ex. "25%")
    - invoice_date (YYYY-MM-DD)
    - reference_number (OCR eller referensnummer)
    - currency (t.ex. "SEK", "EUR")
    - orgnr (organisationsnummer, t.ex. "556123-4567")
    - iban (internationellt kontonummer)

    Svarsexempel:
    {{
      "total_amount": 1234.56,
      "vat_rate": "25%",
      "invoice_date": "2025-06-01",
      "reference_number": "1234567890",
      "currency": "SEK",
      "orgnr": "556123-4567",
      "iban": "SE3550000000054910000003"
    }}

    Text:
    {text}
    """
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": prompt}]
        )
        gpt_output = response.choices[0].message.content
        result = json.loads(gpt_output)

        if log:
            log_dir = os.path.join(os.path.dirname(__file__), "logs")
            os.makedirs(log_dir, exist_ok=True)
            log_file = os.path.join(log_dir, "gpt_invoice.log")
            with open(log_file, "a", encoding="utf-8") as f:
                f.write(f"\n\n--- {datetime.now().isoformat()} ---\n")
                f.write("PROMPT:\n")
                f.write(prompt.strip() + "\n")
                f.write("GPT SVAR:\n")
                f.write(gpt_output.strip())

        return result
    except Exception as e:
        return {"error": str(e)}
END: gpt_invoice_parser.py

====================
ğŸ“„ Fil: modules/accounting/base/routes.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-04 09:24:55
ğŸ“ Antal rader: 476
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 12 â€“ ['import os', 'import os', 'import csv', 'import asyncpg', 'import asyncpg', 'import os', 'import datetime', 'import asyncpg', 'import os', 'import asyncpg', 'import asyncpg', 'import datetime']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 19
ğŸ§ª TODO/FIXME: 0
====================
START: routes.py
from fastapi import APIRouter
from fastapi import Depends
router = APIRouter(prefix="/accounting", tags=["accounting"])

# ğŸ” FÃ¶ljande endpoints krÃ¤ver Bearer-token (API-autentisering):
# - POST /transactions
# - POST /transaction_translations
# - POST /attachments

import os
API_KEY = os.getenv("API_ACCOUNTING_KEY")

from fastapi import Header, HTTPException
def verify_token(authorization: str = Header(None)):
    if authorization != f"Bearer {API_KEY}":
        raise HTTPException(status_code=401, detail="Invalid or missing token")

@router.get("/report/reconciliation", dependencies=[Depends(verify_token)])
async def get_reconciliation(account_number: str):
    from .services import generate_reconciliation_report
    db_url = os.environ["LOCAL_DB_URL"]
    result = await generate_reconciliation_report(db_url, account_number)
    return JSONResponse(content={"status": "ok", "result": result})
from .suggest_accounting import analyze_invoice_attachment
from fastapi import HTTPException
from fastapi import Path
from fastapi import UploadFile, File
from fastapi import Depends, Header
from fastapi import Query
from uuid import UUID
from .schemas import TransactionIn, TransactionTranslationIn, TransactionTranslationOut
from .services import create_transaction
from fastapi import APIRouter
from fastapi.responses import JSONResponse
from .services import get_accounts, get_transactions, generate_full_cashflow_report
from typing import Optional
import os

# --- BANK RECONCILIATION & CSV UPLOAD ---
import csv
from fastapi import UploadFile
from io import StringIO



router = APIRouter(prefix="/accounting", tags=["accounting"])

# ğŸ” FÃ¶ljande endpoints krÃ¤ver Bearer-token (API-autentisering):
# - POST /transactions
# - POST /transaction_translations
# - POST /attachments

API_KEY = os.getenv("API_ACCOUNTING_KEY")

def verify_token(authorization: str = Header(None)):
    if authorization != f"Bearer {API_KEY}":
        raise HTTPException(status_code=401, detail="Invalid or missing token")

@router.get("/chart_of_accounts")
async def get_chart(lang: str = "sv"):
    from .services import get_chart_of_accounts
    data = await get_chart_of_accounts(language=lang)
    return JSONResponse(content=data)

@router.get("/report/resultat")
async def get_resultatrapport():
    from .services import generate_resultatrapport
    data = await generate_resultatrapport()
    return JSONResponse(content=data)

@router.get("/report/balans")
async def get_balansrapport():
    from .services import generate_balansrapport
    data = await generate_balansrapport()
    return JSONResponse(content=data)

@router.get("/report/moms")
async def get_momsrapport():
    from .services import generate_momsrapport
    data = await generate_momsrapport()
    return JSONResponse(content=data)

@router.get("/accounts")
async def list_accounts(lang: str = "sv"):
    data = await get_accounts(language=lang)
    return JSONResponse(content=data)

@router.get("/transactions")
async def list_transactions(lang: str = "sv", user: Optional[str] = None):
    data = await get_transactions(language=lang, filter_user=user)
    return JSONResponse(content=data)


# Skapa ny POST-route fÃ¶r transactions
@router.post("/transactions", dependencies=[Depends(verify_token)])
async def post_transaction(transaction: TransactionIn):
    """
    Skapa en ny transaction. Tar emot och sparar Ã¤ven currency_code, exchange_rate och total_amount_original.
    """
    try:
        # Pass entire transaction object, which now includes currency_code, exchange_rate, total_amount_original
        result = await create_transaction(transaction)
        return JSONResponse(content=result)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))


# Ny POST-endpoint fÃ¶r att fÃ¶reslÃ¥ konto baserat pÃ¥ beskrivning, filnamn och belopp
@router.post("/suggest_accounting")
async def suggest_accounting_api(payload: dict):
    desc = payload.get("description", "")
    file_name = payload.get("file_name", "")
    amount = payload.get("amount")
    suggestion = suggest_account(desc, file_name, amount)
    return {"status": "ok", **suggestion}

from .suggest_accounting import extract_text_from_pdf
import asyncpg

@router.post("/extract_text_from_attachment")
async def extract_text_endpoint(attachment_id: UUID):
    try:
        db_url = os.environ["LOCAL_DB_URL"]
        conn = await asyncpg.connect(dsn=db_url)
        row = await conn.fetchrow("SELECT data FROM attachment WHERE id = $1", attachment_id)
        await conn.close()

        if not row:
            raise HTTPException(status_code=404, detail="Attachment not found")

        text = extract_text_from_pdf(row["data"])
        return {"text": text}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Skapa ny POST-route fÃ¶r transaction_translations
import asyncpg
from fastapi import HTTPException


@router.post("/transaction_translations", dependencies=[Depends(verify_token)])
async def add_transaction_translation(translation: TransactionTranslationIn):
    try:
        db_url = os.environ["LOCAL_DB_URL"]
        conn = await asyncpg.connect(dsn=db_url)
        await conn.execute("""
            INSERT INTO transaction_translation (transaction_id, language, description)
            VALUES ($1, $2, $3)
            ON CONFLICT (transaction_id, language) DO UPDATE
            SET description = EXCLUDED.description
        """, translation.transaction_id, translation.language, translation.description)
        await conn.close()
        return {"status": "ok"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Ny GET-endpoint fÃ¶r att hÃ¤mta Ã¶versÃ¤ttningar fÃ¶r en transaction_id
from typing import List
from uuid import UUID

@router.get("/transaction_translations/{transaction_id}", response_model=List[TransactionTranslationOut])
async def get_transaction_translations(transaction_id: UUID):
    try:
        db_url = os.environ["LOCAL_DB_URL"]
        conn = await asyncpg.connect(dsn=db_url)
        rows = await conn.fetch("""
            SELECT transaction_id, language, description
            FROM transaction_translation
            WHERE transaction_id = $1
        """, transaction_id)
        await conn.close()
        return [dict(row) for row in rows]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Ny POST-endpoint fÃ¶r att ladda upp bilagor
@router.post("/attachments", dependencies=[Depends(verify_token)])
async def upload_attachment(transaction_id: UUID, file: UploadFile = File(...)):
    allowed_types = ["application/pdf", "image/jpeg", "image/png"]
    max_size_bytes = 5 * 1024 * 1024  # 5 MB

    if file.content_type not in allowed_types:
        raise HTTPException(status_code=422, detail=f"Filtypen '{file.content_type}' Ã¤r inte tillÃ¥ten")

    content = await file.read()

    if len(content) > max_size_bytes:
        raise HTTPException(status_code=422, detail=f"Filen Ã¤r fÃ¶r stor (max 5 MB)")

    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    await conn.execute("""
        INSERT INTO attachment (transaction_id, filename, content_type, data)
        VALUES ($1, $2, $3, $4)
    """, transaction_id, file.filename, file.content_type, content)
    await conn.close()

    return {"status": "ok", "filename": file.filename}
# Ny GET-endpoint fÃ¶r att hÃ¤mta alla bilagor fÃ¶r en viss transaction_id
from uuid import UUID

@router.get("/attachments/{transaction_id}")
async def get_attachments(transaction_id: UUID):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT id, filename, content_type, data, uploaded_at
        FROM attachment
        WHERE transaction_id = $1
        ORDER BY uploaded_at
    """, transaction_id)
    await conn.close()
    return [
        {
            "id": str(row["id"]),
            "filename": row["filename"],
            "content_type": row["content_type"],
            "uploaded_at": row["uploaded_at"].isoformat(),
            "size_bytes": len(row["data"])
        }
        for row in rows
    ]


# Ny GET-endpoint fÃ¶r att ladda ner en bilaga
from uuid import UUID
from fastapi.responses import StreamingResponse
from io import BytesIO

@router.get("/attachments/{attachment_id}/download")
async def download_attachment(attachment_id: UUID):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    row = await conn.fetchrow("""
        SELECT filename, content_type, data
        FROM attachment
        WHERE id = $1
    """, attachment_id)
    await conn.close()

    if not row:
        raise HTTPException(status_code=404, detail="Attachment not found")

    return StreamingResponse(BytesIO(row["data"]), media_type=row["content_type"], headers={
        "Content-Disposition": f'attachment; filename="{row["filename"]}"'
    })

# Byt namn pÃ¥ en bilaga
@router.put("/attachments/{attachment_id}/rename", dependencies=[Depends(verify_token)])
async def rename_attachment(attachment_id: UUID, new_filename: str):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    result = await conn.execute("""
        UPDATE attachment SET filename = $1 WHERE id = $2
    """, new_filename, attachment_id)
    await conn.close()
    return {"status": "ok", "result": result}

# Radera en bilaga
@router.delete("/attachments/{attachment_id}", dependencies=[Depends(verify_token)])
async def delete_attachment(attachment_id: UUID):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    result = await conn.execute("""
        DELETE FROM attachment WHERE id = $1
    """, attachment_id)
    await conn.close()
    return {"status": "ok", "result": result}


# Ny POST-endpoint fÃ¶r att analysera en fakturabilaga
from uuid import UUID
from fastapi import Depends


@router.post("/analyze_invoice", dependencies=[Depends(verify_token)])
async def analyze_invoice(attachment_id: UUID):
    db_url = os.environ["LOCAL_DB_URL"]
    try:
        result = await analyze_invoice_attachment(attachment_id, db_url)
        from .suggest_accounting import suggest_periodization, generate_transaction_from_parsed
        periodization = suggest_periodization(result.get("text", ""), result.get("parsed", {}).get("total_amount", 0))
        tx_suggestion = generate_transaction_from_parsed(result.get("parsed", {}))
        result["periodization"] = periodization
        result["transaction_suggestion"] = tx_suggestion
        return JSONResponse(content={"status": "ok", **result})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Ny POST-endpoint: Konvertera fakturabilaga till transaktion
from uuid import UUID
from fastapi import Depends

@router.post("/invoice_to_transaction", dependencies=[Depends(verify_token)])
async def invoice_to_transaction(attachment_id: UUID):
    from .suggest_accounting import analyze_invoice_attachment, generate_transaction_from_parsed
    from .services import create_transaction
    from .schemas import TransactionIn, EntryIn
    import os
    import datetime

    db_url = os.environ["LOCAL_DB_URL"]
    result = await analyze_invoice_attachment(str(attachment_id), db_url)
    parsed = result.get("parsed", {})

    tx_suggestion = generate_transaction_from_parsed(parsed)
    if not tx_suggestion:
        raise HTTPException(status_code=422, detail="Kunde inte generera transaktion frÃ¥n faktura")

    try:
        entries = [
            EntryIn(
                account_number=e["account_number"],
                amount=e["amount"],
                description=e.get("description"),
                metadata={"generated_by": "invoice_to_transaction"}
            )
            for e in tx_suggestion["entries"]
        ]

        transaction = TransactionIn(
            date=datetime.date.fromisoformat(tx_suggestion["date"]) if tx_suggestion.get("date") else datetime.date.today(),
            description=tx_suggestion.get("description", "Fakturaimport"),
            series="A",
            metadata={"reference": tx_suggestion.get("reference"), "source": "invoice_auto"},
            entries=entries
        )

        result = await create_transaction(transaction)
        return {"status": "ok", **result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Ny POST-endpoint fÃ¶r GPT-analys av faktura
@router.post("/invoice_gpt_analysis", dependencies=[Depends(verify_token)])
async def invoice_gpt_analysis(attachment_id: UUID):
    from .suggest_accounting import extract_text_from_pdf, parse_invoice_with_gpt
    import asyncpg
    import os
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    row = await conn.fetchrow("SELECT data FROM attachment WHERE id = $1", str(attachment_id))
    await conn.close()
    if not row:
        raise HTTPException(status_code=404, detail="Attachment not found")
    text = extract_text_from_pdf(row["data"])
    gpt_result = parse_invoice_with_gpt(text)
    return {"text": text, "gpt_parsed": gpt_result}

# Ny GET-endpoint fÃ¶r att flagga avvikande transaktioner
@router.get("/anomalies", dependencies=[Depends(verify_token)])
async def get_anomalies():
    from .services import detect_anomalies
    db_url = os.environ["LOCAL_DB_URL"]
    try:
        anomalies = await detect_anomalies(db_url)
        return JSONResponse(content={"status": "ok", "anomalies": anomalies})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Ny GET-endpoint fÃ¶r budget vs actual
from typing import Optional

@router.get("/report/budget_vs_actual", dependencies=[Depends(verify_token)])
async def get_budget_vs_actual(year: Optional[int] = Query(None), month: Optional[int] = Query(None)):
    from .services import generate_budget_vs_actual
    db_url = os.environ["LOCAL_DB_URL"]
    data = await generate_budget_vs_actual(db_url, year=year, month=month)
    return JSONResponse(content={"status": "ok", "result": data})

@router.post("/suggest_periodization")
async def suggest_periodization_api(payload: dict):
    from .suggest_accounting import suggest_periodization
    description = payload.get("description", "")
    total_amount = float(payload.get("total_amount", 0))
    suggestion = suggest_periodization(description, total_amount)
    return {"status": "ok", "periodization": suggestion}

@router.get("/report/cashflow", dependencies=[Depends(verify_token)])
async def get_cashflow_report():
    data = await generate_full_cashflow_report()
    return JSONResponse(content={"status": "ok", "result": data})

# Ny GET-endpoint fÃ¶r indirekt kassaflÃ¶desanalys
@router.get("/report/cashflow_indirect", dependencies=[Depends(verify_token)])
async def get_indirect_cashflow():
    from .services import generate_indirect_cashflow
    db_url = os.environ["LOCAL_DB_URL"]
    data = await generate_indirect_cashflow(db_url)
    return JSONResponse(content={"status": "ok", "result": data})


# --- BANK CSV UPLOAD ENDPOINT ---
@router.post("/bank/upload_csv", dependencies=[Depends(verify_token)])
async def upload_bank_csv(file: UploadFile = File(...)):
    db_url = os.environ["LOCAL_DB_URL"]
    content = await file.read()
    text = content.decode("utf-8")
    reader = csv.DictReader(StringIO(text))
    import asyncpg
    conn = await asyncpg.connect(dsn=db_url)
    count = 0
    for row in reader:
        await conn.execute("""
            INSERT INTO bank_statement (date, balance, source, metadata)
            VALUES ($1, $2, $3, $4)
            ON CONFLICT DO NOTHING
        """, row["date"], float(row["balance"]), row.get("source", "unknown"), row)
        count += 1
    await conn.close()
    return {"status": "ok", "imported": count}

# --- BANK RECONCILIATION ENDPOINT ---
@router.get("/bank/reconcile", dependencies=[Depends(verify_token)])
async def reconcile_bank(account_number: str = Query(...)):
    import asyncpg
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)

    rows = await conn.fetch("""
        SELECT TO_CHAR(t.date, 'YYYY-MM-DD') AS date, SUM(e.amount) AS balance
        FROM entry e
        JOIN transaction t ON e.transaction_id = t.id
        JOIN account a ON a.id = e.account_id
        WHERE a.number = $1
        GROUP BY t.date
    """, account_number)

    entries_by_date = {r["date"]: float(r["balance"]) for r in rows}

    banks = await conn.fetch("""
        SELECT TO_CHAR(date, 'YYYY-MM-DD') AS date, balance
        FROM bank_statement
        ORDER BY date
    """)

    await conn.close()

    diffs = []
    for row in banks:
        bdate = row["date"]
        bbal = float(row["balance"])
        expected = entries_by_date.get(bdate)
        if expected is not None and abs(expected - bbal) > 0.01:
            diffs.append({"date": bdate, "bank_balance": bbal, "accounting_balance": expected, "difference": round(expected - bbal, 2)})

    return {"status": "ok", "differences": diffs}
# --- SIE export endpoint ---

from typing import Optional
from fastapi import Query, Depends
from fastapi import HTTPException

@router.get("/export/sie", dependencies=[Depends(verify_token)])
async def export_sie(start_date: Optional[str] = Query(None), end_date: Optional[str] = Query(None)):
    from .services import generate_sie_export
    import datetime
    from fastapi.responses import PlainTextResponse

    try:
        start = datetime.date.fromisoformat(start_date) if start_date else None
        end = datetime.date.fromisoformat(end_date) if end_date else None
    except ValueError:
        raise HTTPException(status_code=400, detail="Felaktigt datumformat. AnvÃ¤nd YYYY-MM-DD.")

    sie_data = await generate_sie_export(start, end)
    return PlainTextResponse(sie_data, media_type="text/plain", headers={
        "Content-Disposition": 'attachment; filename="export.se"'
    })
END: routes.py

====================
ğŸ“„ Fil: modules/crm/services.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-24 18:11:14
ğŸ“ Antal rader: 71
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 3 â€“ ['import os', 'import asyncpg', 'import json']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 5
ğŸ§ª TODO/FIXME: 0
====================
START: services.py
import os
import asyncpg
from typing import List

import json

def fix_encoding(text):
    if isinstance(text, str):
        try:
            return text.encode("latin1").decode("utf-8")
        except Exception:
            return text
    return text

async def get_all_contacts():
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    rows = await conn.fetch("""
        SELECT 
            c.id,
            ccr.metadata->>'email' AS email,
            c.metadata,
            COALESCE(b.count, 0) AS booking_count
        FROM contact c
        JOIN ccrelation ccr ON c.id = ccr.contact_id
        LEFT JOIN (
            SELECT contact_id, COUNT(*) AS count
            FROM bookings
            GROUP BY contact_id
        ) b ON c.id = b.contact_id
        ORDER BY c.created_at DESC
    """)
    await conn.close()
    contacts = []
    for row in rows:
        metadata_raw = row["metadata"]
        if isinstance(metadata_raw, dict):
            metadata = metadata_raw
        elif isinstance(metadata_raw, str):
            try:
                metadata = json.loads(metadata_raw)
            except Exception:
                metadata = {}
        else:
            metadata = {}
        print("RAW last_name:", metadata.get("last_name"))
        contacts.append({
            "id": str(row["id"]),
            "email": row["email"],  # Now comes from ccr.metadata->>'email'
            "first_name": fix_encoding(metadata.get("first_name")),
            "last_name": fix_encoding(metadata.get("last_name")),
            "company": fix_encoding(metadata.get("company")),
            "phone": metadata.get("phone"),
            "booking_count": row["booking_count"]
        })
    return contacts

async def get_contact_by_id(contact_id: str):
    db_url = os.environ["LOCAL_DB_URL"]
    conn = await asyncpg.connect(dsn=db_url)
    row = await conn.fetchrow("""
        SELECT c.*, ccr.metadata->>'email' AS email
        FROM contact c
        JOIN ccrelation ccr ON c.id = ccr.contact_id
        WHERE c.id = $1
        LIMIT 1
    """, contact_id)
    await conn.close()
    if row:
        return dict(row)
    return {"error": "Contact not found"}
END: services.py

====================
ğŸ“„ Fil: modules/crm/__init__.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-06-03 21:33:00
ğŸ“ Antal rader: 1
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: __init__.py
# __init__.py fÃ¶r local_backend/modules/crm

END: __init__.py

====================
ğŸ“„ Fil: apple_contact_sync/Package.swift
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ“„ OkÃ¤nt format
ğŸ“… Senast Ã¤ndrad: 2025-06-19 23:05:43
ğŸ“ Antal rader: 22
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 2 rader (9.1%)
ğŸ“¥ Imports: 1 â€“ ['import PackageDescription']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: Package.swift
// swift-tools-version: 6.1
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "contact_sync",
    platforms: [
        .macOS(.v12)
    ],
    dependencies: [
        .package(url: "https://github.com/codewinsdotcom/PostgresClientKit", from: "1.3.0")
    ],
    targets: [
        .executableTarget(
            name: "contact_sync",
            dependencies: [
                .product(name: "PostgresClientKit", package: "PostgresClientKit")
            ]
        )
    ]
)

END: Package.swift

====================
ğŸ“„ Fil: apple_contact_sync/Sources/main.swift
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ“„ OkÃ¤nt format
ğŸ“… Senast Ã¤ndrad: 2025-06-24 21:25:33
ğŸ“ Antal rader: 542
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 21 rader (3.9%)
ğŸ“¥ Imports: 3 â€“ ['import Foundation', 'import Contacts', 'import PostgresClientKit']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 88
ğŸ§ª TODO/FIXME: 0
====================
START: main.swift
import Foundation
import Contacts
import PostgresClientKit

// ğŸ”„ Ladda .env
let defaultEnvPath = "/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot/macspot-api/.env"
let envPath = ProcessInfo.processInfo.environment["ENV_PATH"] ?? defaultEnvPath
let envURL = URL(fileURLWithPath: envPath)
guard let envData = try? String(contentsOf: envURL) else {
  fatalError("Kunde inte lÃ¤sa .env")
}

var env: [String: String] = [:]
for line in envData.split(separator: "\n") {
  let parts = line.split(separator: "=", maxSplits: 1)
  if parts.count == 2 {
    env[String(parts[0])] = String(parts[1])
  }
}

print("ğŸ“„ Laddade miljÃ¶variabler:")
for (key, value) in env {
    print("  \(key)=\(value)")
}

guard
  let host = env["PGHOST"],
  let portString = env["PGPORT"],
  let db = env["PGDATABASE"],
  let user = env["PGUSER"],
  let password = env["PGPASSWORD"],
  let port = Int(portString)
else {
  fatalError("Saknar nÃ¥gon PG* variabel")
}

// ğŸ”— Anslut till PostgreSQL
var configuration = PostgresClientKit.ConnectionConfiguration()
configuration.host = host
configuration.port = port
configuration.database = db
configuration.user = user
configuration.credential = .trust
configuration.ssl = false

do {
  let connection = try PostgresClientKit.Connection(configuration: configuration)
  defer { connection.close() }

  let keysToFetch: [CNKeyDescriptor] = [
    CNContactIdentifierKey as CNKeyDescriptor,
    CNContactGivenNameKey as CNKeyDescriptor,
    CNContactMiddleNameKey as CNKeyDescriptor,
    CNContactFamilyNameKey as CNKeyDescriptor,
    CNContactOrganizationNameKey as CNKeyDescriptor,
    CNContactJobTitleKey as CNKeyDescriptor,
    CNContactDepartmentNameKey as CNKeyDescriptor,
    CNContactPhoneNumbersKey as CNKeyDescriptor,
    CNContactEmailAddressesKey as CNKeyDescriptor,
    CNContactPostalAddressesKey as CNKeyDescriptor,
    CNContactBirthdayKey as CNKeyDescriptor,
    CNContactNoteKey as CNKeyDescriptor,
    CNContactUrlAddressesKey as CNKeyDescriptor,
    CNContactSocialProfilesKey as CNKeyDescriptor,
    CNContactDatesKey as CNKeyDescriptor,
    CNContactNicknameKey as CNKeyDescriptor
  ]
  let store = CNContactStore()
  let request = CNContactFetchRequest(keysToFetch: keysToFetch)
  var skippedDueToError = 0

  // ğŸ§¹ Cleanup: Mark incoming pending_changes as processed if already handled as outgoing
  let cleanupStmt = try connection.prepareStatement(text: """
  UPDATE pending_changes
  SET processed = true
  WHERE direction = 'in'
    AND record_id IN (
        SELECT record_id FROM pending_changes WHERE direction = 'out' AND processed = true
    )
  """)
  defer { cleanupStmt.close() }
  try cleanupStmt.execute()

  // ğŸ§¹ Dedupe: Remove duplicate pending_changes for contact (keep latest per apple_id)
  let dedupeStmt = try connection.prepareStatement(text: """
    DELETE FROM pending_changes pc
    WHERE id NOT IN (
      SELECT MAX(id::text)::uuid
      FROM pending_changes
      WHERE table_name = 'contact' AND direction = 'out' AND NOT processed
      GROUP BY (payload->'metadata'->>'apple_id')
    )
    AND table_name = 'contact' AND direction = 'out' AND NOT processed
  """)
  try dedupeStmt.execute()
  dedupeStmt.close()
  try store.enumerateContacts(with: request, usingBlock: { (contact: CNContact, stop: UnsafeMutablePointer<ObjCBool>) in
    guard !contact.emailAddresses.isEmpty else {
        print("âš ï¸ Kontakt utan e-postadress â€“ hoppar Ã¶ver: \(contact.givenName) \(contact.familyName)")
        return
    }
    for emailValue in contact.emailAddresses {
        let email = (emailValue.value as String).lowercased()
        do {
          let firstName = contact.givenName
          let lastName = contact.familyName
          _ = contact.organizationName
          _ = contact.phoneNumbers.first?.value.stringValue ?? ""

          print("ğŸ“± macOS-kontakt: \(firstName) \(lastName) â€” \(email)")

          let stmt = try connection.prepareStatement(text: """
              SELECT id, metadata FROM contact
              WHERE metadata->>'apple_id' = $1
                 OR EXISTS (
                   SELECT 1 FROM ccrelation
                   WHERE ccrelation.contact_id = contact.id
                     AND ccrelation.metadata->>'email' = $2
                 )
              """)
          let result = try stmt.execute(parameterValues: [contact.identifier, email])
          var rows: [PostgresClientKit.Row] = []
          while case let .success(row) = result.next() {
              rows.append(row)
          }
          stmt.close()
          var found = false
          for row in rows {
              let columns = row.columns
              let recordId = try UUID(uuidString: columns[0].string()) ?? UUID()
              let metadataValue = columns[1]
              let metadataString = try metadataValue.string()
              print("ğŸ—„ï¸ DB-data:", metadataString)
              
              if let data = metadataString.data(using: .utf8) {
                  found = true
                  let json = try JSONSerialization.jsonObject(with: data, options: [])
                  
                  if let existing = json as? [String: Any],
                     let existingMeta = existing["metadata"] as? [String: Any],
                     let existingOrigin = existingMeta["origin"] as? String {

                      let existingAppleId = existingMeta["apple_id"] as? String ?? ""

                      if existingAppleId == contact.identifier && existingOrigin != "klrab.se" {
                          print("â™»ï¸ Override frÃ¥n Apple â€“ uppdaterar kontakt: \(email)")

                          let addresses = contact.postalAddresses.map { [
                              "label": $0.label ?? "",
                              "street": $0.value.street,
                              "city": $0.value.city,
                              "state": $0.value.state,
                              "postalCode": $0.value.postalCode,
                              "country": $0.value.country
                          ]}

                          let phones = contact.phoneNumbers.map { [
                              "label": $0.label ?? "",
                              "number": $0.value.stringValue
                          ]}

                          let emails = contact.emailAddresses.map { [
                              "label": $0.label ?? "",
                              "email": ($0.value as String).lowercased()
                          ]}

                          let urls = contact.urlAddresses.map { [
                              "label": $0.label ?? "",
                              "url": $0.value as String
                          ]}

                          let social = contact.socialProfiles.map { [
                              "label": $0.label ?? "",
                              "service": $0.value.service,
                              "url": $0.value.urlString
                          ]}

                          // Kontrollera om kontakt redan Ã¤r identisk i tabellen innan pending_change.
                          let checkContactStmt = try connection.prepareStatement(
                              text: """
                              SELECT metadata FROM contact WHERE metadata->>'apple_id' = $1
                              """
                          )
                          let contactResult = try checkContactStmt.execute(parameterValues: [contact.identifier])
                          var skipInsert = false
                          let cleanMetadata: [String: Any] = [
                              "origin": "klrab.se",
                              "apple_id": contact.identifier,
                              "apple_uid": contact.identifier
                          ]
                          var safeMetadata = cleanMetadata
                          safeMetadata.removeValue(forKey: "metadata")
                          let jsonPayload: [String: Any] = [
                              "apple_id": contact.identifier,
                              "apple_uid": contact.identifier,
                              "first_name": contact.givenName,
                              "middle_name": contact.middleName,
                              "last_name": contact.familyName,
                              "organization": contact.organizationName,
                              "job_title": contact.jobTitle,
                              "department": contact.departmentName,
                              "note": contact.isKeyAvailable(CNContactNoteKey) ? contact.note : "",
                              "nickname": contact.nickname,
                              "birthday": contact.birthday?.date.map { ISO8601DateFormatter().string(from: $0) } ?? "",
                              "emails": emails,
                              "phones": phones,
                              "addresses": addresses,
                              "urls": urls,
                              "social_profiles": social,
                              "metadata": safeMetadata
                          ]
                          // --- Begin: sorted JSON comparison ---
                          let sortedPayloadData = try JSONSerialization.data(withJSONObject: jsonPayload, options: [.sortedKeys])
                          let sortedPayloadStr = String(data: sortedPayloadData, encoding: .utf8)

                          if case let .success(row) = contactResult.next() {
                              let metadataString = try row.columns[0].string()
                              var sortedDbPayloadStr: String? = nil
                              if let dbData = metadataString.data(using: .utf8),
                                 let dbJson = try? JSONSerialization.jsonObject(with: dbData),
                                 let dbSorted = try? JSONSerialization.data(withJSONObject: dbJson, options: [.sortedKeys]) {
                                  sortedDbPayloadStr = String(data: dbSorted, encoding: .utf8)
                              }
                          if sortedDbPayloadStr == sortedPayloadStr {
                              print("ğŸ§¼ Kontakt redan identisk (sorterad JSON) â€“ hoppar Ã¶ver: \(email)")
                              skipInsert = true
                              return
                          }
                          }
                          checkContactStmt.close()

                          let data = try JSONSerialization.data(withJSONObject: jsonPayload, options: [])

                          let updatePayload = String(data: data, encoding: .utf8) ?? "{}"

                          // Kontroll: Finns redan identisk pending_change fÃ¶r samma email+apple_id?
                          let checkPendingStmt = try connection.prepareStatement(
                              text: """
                              SELECT id, payload FROM pending_changes
                              WHERE table_name = 'contact'
                                AND direction = 'out'
                                AND processed = false
                                AND (payload->>'email') = $1
                                AND (payload->'metadata'->>'apple_id') = $2
                              """
                          )
                          let checkPendingResult = try checkPendingStmt.execute(parameterValues: [email, contact.identifier])
                          while case let .success(row) = checkPendingResult.next() {
                              let payloadStr = try row.columns[1].string()
                              if let data = payloadStr.data(using: .utf8),
                                 let oldPayload = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                                 NSDictionary(dictionary: oldPayload).isEqual(to: jsonPayload) {
                                  print("ğŸ§¼ Kontakt redan identisk i pending_changes â€“ hoppar Ã¶ver: \(email)")
                                  skipInsert = true
                                  break
                              }
                          }
                          checkPendingResult.close()
                          checkPendingStmt.close()
                          // Kontrollera att ingen duplikat-pending_change skapas fÃ¶r samma email + apple_id
                          if !skipInsert {
                              let dupeCheckStmt = try connection.prepareStatement(
                                  text: """
                                  SELECT count(*) FROM pending_changes
                                  WHERE table_name = 'contact'
                                    AND direction = 'out'
                                    AND processed = false
                                    AND (payload->>'email') = $1
                                    AND (payload->'metadata'->>'apple_id') = $2
                                  """
                              )
                              let dupeResult = try dupeCheckStmt.execute(parameterValues: [email, contact.identifier])
                              var isDupe = false
                              if case let .success(dupeRow) = dupeResult.next() {
                                  let count = try dupeRow.columns[0].int()
                                  if count > 0 {
                                      print("ğŸ§¼ Duplikat pending_change finns redan fÃ¶r \(email) + \(contact.identifier) â€“ hoppar Ã¶ver.")
                                      isDupe = true
                                  }
                              }
                              dupeResult.close()
                              dupeCheckStmt.close()
                              if !isDupe {
                                  // Kontroll: Finns andra kontakter med samma e-post men annan apple_id â†’ hoppa Ã¶ver
                                  let emailDupeCheckStmt = try connection.prepareStatement(text: """
                                  SELECT COUNT(*) FROM ccrelation
                                  WHERE metadata->>'email' = $1 AND contact_id IS NOT NULL
                                  """)
                                  let emailDupeResult = try emailDupeCheckStmt.execute(parameterValues: [email])
                                  if case let .success(row) = emailDupeResult.next() {
                                      let count = try row.columns[0].int()
                                      if count > 0 {
                                          print("ğŸ›‘ Dubblettkontakt hittad med samma e-post â€“ hoppar Ã¶ver pending_change: \(email)")
                                          emailDupeResult.close()
                                          emailDupeCheckStmt.close()
                                          continue
                                      }
                                  }
                                  emailDupeResult.close()
                                  emailDupeCheckStmt.close()
                                  let updateStmt = try connection.prepareStatement(
                                      text: """
                                      INSERT INTO pending_changes (table_name, operation, payload, record_id, created_at, change_type, direction)
                                      VALUES ($1, $2, $3::jsonb, $4::uuid, NOW(), $5, $6)
                                      """
                                  )
                                  defer { updateStmt.close() }
                                  try updateStmt.execute(parameterValues: ["contact", "UPDATE", updatePayload, recordId.uuidString, "metadata_changed", "out"])
                                  print("ğŸ•“ Skapade pending_changes fÃ¶r \(email)")
                              }
                          }
                      } else if existingOrigin == "klrab.se" {
                          print("ğŸš« Skyddad kontakt (klrab.se) â€“ ingen uppdatering: \(email)")
                      }
                  }
              }
          }
          // âœ… StÃ¤nger resultatet efter iteration â€“ undviker cursorClosed
          result.close()
          if !found {
              print("â“ Ingen match i databasen fÃ¶r: \(email)")
              let recordId = UUID()
              let appleId = contact.identifier

              let checkStmt = try connection.prepareStatement(text: """
SELECT id, metadata FROM contact
WHERE metadata->>'apple_id' = $1 OR metadata->>'apple_uid' = $1
""")
              let checkResult = try checkStmt.execute(parameterValues: [appleId])
              var checkRows: [PostgresClientKit.Row] = []
              while case let .success(row) = checkResult.next() {
                  checkRows.append(row)
              }
              checkStmt.close()
              // Extra villkor: hoppa Ã¶ver om nÃ¥gon har origin = klrab.se
              let skipDueToProtectedOrigin = try checkRows.contains { row in
                  let metadataString = try row.columns[1].string()
                  if let data = metadataString.data(using: .utf8),
                     let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                     let meta = json["metadata"] as? [String: Any],
                     let origin = meta["origin"] as? String,
                     origin == "klrab.se" {
                      return true
                  }
                  return false
              }
              if skipDueToProtectedOrigin {
                  print("ğŸš« Skyddad kontakt (klrab.se) â€“ skippar INSERT: \(email)")
                  continue
              }
              let foundExisting = !checkRows.isEmpty
              if foundExisting {
                  print("âš ï¸ Kontakt med samma apple_id/apple_uid redan finns â€“ hoppar Ã¶ver INSERT")
                  continue
              }

              // Kontroll: hoppa Ã¶ver om kontakt med denna e-post redan finns
              let emailCheckStmt = try connection.prepareStatement(text: """
                SELECT COUNT(*) FROM ccrelation WHERE metadata->>'email' = $1
              """)
              let emailCheckResult = try emailCheckStmt.execute(parameterValues: [email])
              if case let .success(row) = emailCheckResult.next() {
                let count = try row.columns[0].int()
                if count > 0 {
                  print("ğŸ§¼ Kontakt med e-post redan finns i DB â€“ hoppar Ã¶ver: \(email)")
                  emailCheckStmt.close()
                  continue
                }
              }
              emailCheckStmt.close()

              let addresses = contact.postalAddresses.map { [
                  "label": $0.label ?? "",
                  "street": $0.value.street,
                  "city": $0.value.city,
                  "state": $0.value.state,
                  "postalCode": $0.value.postalCode,
                  "country": $0.value.country
              ]}

              let phones = contact.phoneNumbers.map { [
                  "label": $0.label ?? "",
                  "number": $0.value.stringValue
              ]}

              let emails = contact.emailAddresses.map { [
                  "label": $0.label ?? "",
                  "email": ($0.value as String).lowercased()
              ]}

              let urls = contact.urlAddresses.map { [
                  "label": $0.label ?? "",
                  "url": $0.value as String
              ]}

              // let relations = contact.contactRelations.map { [
              //     "label": $0.label ?? "",
              //     "name": $0.value.name
              // ]}

              let social = contact.socialProfiles.map { [
                  "label": $0.label ?? "",
                  "service": $0.value.service,
                  "url": $0.value.urlString
              ]}

              let cleanMetadata: [String: Any] = [
                  "origin": "macos",
                  "apple_id": appleId,
                  "apple_uid": appleId
              ]
              var safeMetadata = cleanMetadata
              safeMetadata.removeValue(forKey: "metadata")
              let jsonPayload: [String: Any] = [
                  "apple_id": appleId,
                  "apple_uid": appleId,
                  "first_name": contact.givenName,
                  "middle_name": contact.middleName,
                  "last_name": contact.familyName,
                  "organization": contact.organizationName,
                  "job_title": contact.jobTitle,
                  "department": contact.departmentName,
                  "note": contact.isKeyAvailable(CNContactNoteKey) ? contact.note : "",
                  "nickname": contact.nickname,
                  "birthday": contact.birthday?.date.map { ISO8601DateFormatter().string(from: $0) } ?? "",
                  "emails": emails,
                  "phones": phones,
                  "addresses": addresses,
                  "urls": urls,
                  // "relations": relations,
                  "social_profiles": social,
                  "metadata": safeMetadata
              ]

              let data = try JSONSerialization.data(withJSONObject: jsonPayload, options: [])
              let json = String(data: data, encoding: .utf8) ?? "{}"

              // Kontroll: Finns redan identisk pending_change fÃ¶r samma email+apple_id?
              let checkPendingStmt = try connection.prepareStatement(
                  text: """
                  SELECT id, payload FROM pending_changes
                  WHERE table_name = 'contact'
                    AND direction = 'out'
                    AND processed = false
                    AND (payload->>'email') = $1
                    AND (payload->'metadata'->>'apple_id') = $2
                  """
              )
              let checkPendingResult = try checkPendingStmt.execute(parameterValues: [email, appleId])
              var skipInsert = false
              // --- Begin: sorted JSON comparison ---
              let sortedPayloadData = try JSONSerialization.data(withJSONObject: jsonPayload, options: [.sortedKeys])
              let sortedPayloadStr = String(data: sortedPayloadData, encoding: .utf8)
              while case let .success(row) = checkPendingResult.next() {
                  let payloadStr = try row.columns[1].string()
                  var sortedDbPayloadStr: String? = nil
                  if let dbData = payloadStr.data(using: .utf8),
                     let dbJson = try? JSONSerialization.jsonObject(with: dbData),
                     let dbSorted = try? JSONSerialization.data(withJSONObject: dbJson, options: [.sortedKeys]) {
                      sortedDbPayloadStr = String(data: dbSorted, encoding: .utf8)
                  }
                  if sortedDbPayloadStr == sortedPayloadStr {
                      print("ğŸ§¼ Kontakt redan identisk (sorterad JSON) â€“ hoppar Ã¶ver: \(email)")
                      skipInsert = true
                      break
                  }
              }
              checkPendingResult.close()
              checkPendingStmt.close()
              // Kontrollera att vi inte redan har identisk kontakt i tabellen
              if !skipInsert {
                  let checkContactStmt = try connection.prepareStatement(
                      text: """
                      SELECT metadata FROM contact WHERE metadata->>'apple_id' = $1
                      """
                  )
                  let contactResult = try checkContactStmt.execute(parameterValues: [appleId])
                  if case let .success(row) = contactResult.next() {
                      let metadataString = try row.columns[0].string()
                      var sortedDbPayloadStr: String? = nil
                      if let dbData = metadataString.data(using: .utf8),
                         let dbJson = try? JSONSerialization.jsonObject(with: dbData),
                         let dbSorted = try? JSONSerialization.data(withJSONObject: dbJson, options: [.sortedKeys]) {
                          sortedDbPayloadStr = String(data: dbSorted, encoding: .utf8)
                      }
                  if sortedDbPayloadStr == sortedPayloadStr {
                      print("ğŸ§¼ Kontakt redan identisk (sorterad JSON) â€“ hoppar Ã¶ver: \(email)")
                      skipInsert = true
                      return
                  }
                  }
                  checkContactStmt.close()
              }
              if !skipInsert {
                  // Kontrollera att ingen duplikat-pending_change skapas fÃ¶r samma email + apple_id
                  let dupeCheckStmt = try connection.prepareStatement(
                      text: """
                      SELECT count(*) FROM pending_changes
                      WHERE table_name = 'contact'
                        AND direction = 'out'
                        AND processed = false
                        AND (payload->>'email') = $1
                        AND (payload->'metadata'->>'apple_id') = $2
                      """
                  )
                  let dupeResult = try dupeCheckStmt.execute(parameterValues: [email, appleId])
                  var isDupe = false
                  if case let .success(dupeRow) = dupeResult.next() {
                      let count = try dupeRow.columns[0].int()
                      if count > 0 {
                          print("ğŸ§¼ Duplikat pending_change finns redan fÃ¶r \(email) + \(appleId) â€“ hoppar Ã¶ver.")
                          isDupe = true
                      }
                  }
                  dupeResult.close()
                  dupeCheckStmt.close()
                  if !isDupe {
                      let insertPendingStmt = try connection.prepareStatement(
                          text: """
                          INSERT INTO pending_changes (table_name, operation, payload, record_id, created_at, change_type, direction)
                          VALUES ($1, $2, $3::jsonb, $4::uuid, NOW(), $5, $6)
                          """
                      )
                      defer { insertPendingStmt.close() }
                      try insertPendingStmt.execute(parameterValues: ["contact", "INSERT", json, recordId.uuidString, "new_contact", "out"])
                      print("ğŸ•“ Skapade pending_changes fÃ¶r \(email)")
                  }
              }
          }

          print("â€”")
        } catch {
          print("âŒ Fel i kontaktloop: \(error)")
          skippedDueToError += 1
        }
    }
  })
  print("âš ï¸ Totalt Ã¶verhoppade p.g.a. fel: \(skippedDueToError)")

} catch {
  print("ğŸ’¥ Fel vid databaskoppling: \(error)")
}

END: main.swift

ğŸ“ KONFIGURATIONSFILER (function.json / host.json / package.json / .funcignore)
====================================

Inga function.json, host.json, package.json eller .funcignore hittades i projektet.

ğŸ“ˆ SUMMERING AV ALLA JS-FILER
====================================
ğŸ“ Totalt antal rader kod: 2325
ğŸ§© Totalt antal funktioner: 0
ğŸ§  Total komplexitetspoÃ¤ng: 229
ğŸ§ª Antal TODO/FIXME totalt: 2

ğŸ“Š Per fil:
fil,rader,funktioner,komplexitet,kommentarer,imports
config.py,9,0,0,0,1
__init__.py,1,0,0,0,0
main.py,59,0,3,0,1
__init__.py,1,0,0,0,0
__init__.py,1,0,0,0,0
services.py,21,0,2,0,1
__init__.py,1,0,0,0,0
routes.py,12,0,1,0,1
test_accounting.py,31,0,0,0,1
services.py,14,0,1,0,2
__init__.py,1,0,0,0,0
routes.py,8,0,0,0,0
services.py,13,0,0,0,0
__init__.py,1,0,0,0,0
routes.py,10,0,0,0,0
services.py,31,0,1,0,2
__init__.py,1,0,0,0,0
routes.py,16,0,0,0,0
services.py,483,0,57,0,7
suggest_accounting.py,302,0,45,1,5
__init__.py,19,0,0,0,0
export.py,69,0,6,0,5
schemas.py,49,0,0,0,0
gpt_invoice_parser.py,60,0,1,0,3
routes.py,476,0,19,0,12
services.py,71,0,5,0,3
__init__.py,1,0,0,0,0
Package.swift,22,0,0,2,1
main.swift,542,0,88,21,3
ğŸ“Š LOKAL DATABAS â€“ STRUKTUR & INNEHÃ…LL
====================================

ğŸ“ Tabell: bookings
  â€¢ start_time (timestamp with time zone)
  â€¢ end_time (timestamp with time zone)
  â€¢ meeting_type (text)
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp with time zone)
  â€¢ contact_id (uuid)
  â€¢ id (uuid)
  â€¢ updated_at (timestamp with time zone)
  â€¢ booking_email (text)
  ğŸ“ Kolumntyper:
    - start_time: timestamp with time zone
    - end_time: timestamp with time zone
    - meeting_type: text
    - metadata: jsonb
    - created_at: timestamp with time zone
    - contact_id: uuid
    - id: uuid
    - updated_at: timestamp with time zone
    - booking_email: text
  ğŸ”‘ [p] bookings_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] fk_bookings_contact: FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE SET NULL
  ğŸ”‘ [f] fk_bookings_contact_id: FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE SET NULL
  ğŸ”— Relationer:
    - contact_id â¡ contact.id
    - contact_id â¡ contact.id
  âš™ï¸ Triggers:
    - log_bookings_change_trigger (INSERT): EXECUTE FUNCTION log_bookings_change()
    - log_bookings_change_trigger (DELETE): EXECUTE FUNCTION log_bookings_change()
    - log_bookings_change_trigger (UPDATE): EXECUTE FUNCTION log_bookings_change()

ğŸ“ Tabell: contact
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp with time zone)
  â€¢ id (uuid)
  â€¢ updated_at (timestamp with time zone)
  â€¢ email (text)
  â€¢ apple_uid (text)
  ğŸ“ Kolumntyper:
    - metadata: jsonb
    - created_at: timestamp with time zone
    - id: uuid
    - updated_at: timestamp with time zone
    - email: text
    - apple_uid: text
  ğŸ”‘ [p] contact_pkey: PRIMARY KEY (id)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:
    - log_contact_change_trigger (INSERT): EXECUTE FUNCTION log_contact_change()
    - log_contact_change_trigger (DELETE): EXECUTE FUNCTION log_contact_change()
    - log_contact_change_trigger (UPDATE): EXECUTE FUNCTION log_contact_change()
  ğŸ§ª Exempelrader:
    - metadata={'note': '', 'urls': [{'url': 'linkedin://#profile/82637159', 'label': '_$!<HomePage>!$_'}], 'emails': [{'email': 'thor.bramert@ephone.nu', 'label': '_$!<Home>!$_'}], 'phones': [{'label': '_$!<Home>!$_', 'number': '+46 8 96 91 92'}, {'label': '_$!<Mobile>!$_', 'number': '+46 708 93 70 31'}, {'label': '_$!<Work>!$_', 'number': '+46 8 451 71 04'}, {'label': '_$!<Other>!$_', 'number': '+46 70759 01 03'}], 'apple_id': '0155FA7A-B234-4AA6-8FC0-C9D2E210CC1D:ABPerson', 'birthday': '', 'metadata': {'origin': 'macos', 'apple_id': '0155FA7A-B234-4AA6-8FC0-C9D2E210CC1D:ABPerson', 'apple_uid': '0155FA7A-B234-4AA6-8FC0-C9D2E210CC1D:ABPerson'}, 'nickname': '', 'addresses': [{'city': 'STOCKHOLM', 'label': '_$!<Home>!$_', 'state': '', 'street': 'EastmansvÃ¤gen 11, lgh 303', 'country': 'Sverige', 'postalCode': '113 61'}, {'city': 'Stockholm, Sweden', 'label': '', 'state': '', 'street': '', 'country': '', 'postalCode': ''}], 'apple_uid': '0155FA7A-B234-4AA6-8FC0-C9D2E210CC1D:ABPerson', 'job_title': 'Deputy Chief Legal Counsel at SPP LivfÃ¶rsÃ¤kring AB', 'last_name': 'Bramert', 'department': '', 'first_name': 'Thor', 'middle_name': '', 'organization': 'Flera fÃ¶retag', 'social_profiles': [{'url': 'http://twitter.com/BramertThor', 'label': '', 'service': 'Twitter'}, {'url': 'https://www.linkedin.com/profile/view?id=thor-bramert-5674301a&trk=tardis-contact', 'label': '', 'service': 'LinkedIn'}, {'url': 'https://www.linkedin.com/profile/view?id=thor-bramert-51b81223&trk=tardis-contact', 'label': '', 'service': 'LinkedIn'}]}, created_at=2025-06-24 17:28:11.571119+02:00, id=e7691349-8b6f-4985-b7f0-1337ad059722, updated_at=2025-06-24 22:48:40.597970+02:00, email=thor.bramert@ephone.nu, apple_uid=None
    - metadata={'note': '', 'urls': [], 'emails': [{'email': 'hanna.fischer@momentpsykologi.se', 'label': '_$!<Work>!$_'}], 'phones': [{'label': '_$!<Mobile>!$_', 'number': '08-54064040'}, {'label': '_$!<Mobile>!$_', 'number': '08-53331543'}], 'apple_id': '034A7907-3F5A-4CFB-B19D-132425DD308E:ABPerson', 'birthday': '', 'metadata': {'origin': 'macos', 'apple_id': '034A7907-3F5A-4CFB-B19D-132425DD308E:ABPerson', 'apple_uid': '034A7907-3F5A-4CFB-B19D-132425DD308E:ABPerson'}, 'nickname': '', 'addresses': [{'city': 'Stockholm', 'label': '_$!<Work>!$_', 'state': '', 'street': 'VÃ¤stmannagatan 6, 5 tr', 'country': '', 'postalCode': '111 24'}], 'apple_uid': '034A7907-3F5A-4CFB-B19D-132425DD308E:ABPerson', 'job_title': '', 'last_name': 'Fischer', 'department': '', 'first_name': 'Hanna', 'middle_name': '', 'organization': '', 'social_profiles': []}, created_at=2025-06-24 17:28:11.571119+02:00, id=fbaf2157-7288-4cc8-b3de-a40c0279ce40, updated_at=2025-06-24 22:48:40.597970+02:00, email=hanna.fischer@momentpsykologi.se, apple_uid=None
    - metadata={'note': '', 'urls': [], 'emails': [{'email': 'jonaser@outlook.com', 'label': '_$!<Home>!$_'}], 'phones': [], 'apple_id': '077B7561-2F59-4E7B-BA94-A888E4A828C9:ABPerson', 'birthday': '', 'metadata': {'origin': 'macos', 'apple_id': '077B7561-2F59-4E7B-BA94-A888E4A828C9:ABPerson', 'apple_uid': '077B7561-2F59-4E7B-BA94-A888E4A828C9:ABPerson'}, 'nickname': '', 'addresses': [], 'apple_uid': '077B7561-2F59-4E7B-BA94-A888E4A828C9:ABPerson', 'job_title': '', 'last_name': '', 'department': '', 'first_name': 'Jonas', 'middle_name': '', 'organization': '', 'social_profiles': []}, created_at=2025-06-24 17:28:11.571119+02:00, id=a9b09100-f058-4a02-812a-187913a05f3d, updated_at=2025-06-24 22:48:40.597970+02:00, email=jonaser@outlook.com, apple_uid=None
    - metadata={'note': '', 'urls': [{'url': 'linkedin://#profile/4350701', 'label': '_$!<HomePage>!$_'}], 'emails': [{'email': 'henrik.tibbling@pts.se', 'label': '_$!<Work>!$_'}, {'email': 'henrik@fullgera.se', 'label': '_$!<Work>!$_'}], 'phones': [], 'apple_id': '0C530674-5865-4BE5-B81F-AF4ECD80BCE6:ABPerson', 'birthday': '', 'metadata': {'origin': 'macos', 'apple_id': '0C530674-5865-4BE5-B81F-AF4ECD80BCE6:ABPerson', 'apple_uid': '0C530674-5865-4BE5-B81F-AF4ECD80BCE6:ABPerson'}, 'nickname': '', 'addresses': [{'city': 'Stockholm County, Sweden', 'label': '', 'state': '', 'street': '', 'country': '', 'postalCode': ''}], 'apple_uid': '0C530674-5865-4BE5-B81F-AF4ECD80BCE6:ABPerson', 'job_title': 'Technical Officer', 'last_name': 'Tibbling', 'department': '', 'first_name': 'Henrik', 'middle_name': '', 'organization': 'PTS', 'social_profiles': [{'url': 'https://www.linkedin.com/profile/view?id=henrik-tibbling-9255591&trk=tardis-contact', 'label': '', 'service': 'LinkedIn'}]}, created_at=2025-06-24 17:28:11.571119+02:00, id=c92a998f-9095-4390-b7bc-7e14538afd5c, updated_at=2025-06-24 22:48:40.597970+02:00, email=henrik.tibbling@pts.se, apple_uid=None
    - metadata={'note': '', 'urls': [], 'emails': [{'email': 'martin.hockert@supermarket.ica.se', 'label': '_$!<Work>!$_'}], 'phones': [{'label': '_$!<Mobile>!$_', 'number': '0733507393'}, {'label': '_$!<WorkFAX>!$_', 'number': '084415739'}, {'label': '_$!<Work>!$_', 'number': '084415731'}], 'apple_id': '0D377F94-E836-42BC-BF9A-CCC9E0058BE7:ABPerson', 'birthday': '', 'metadata': {'origin': 'macos', 'apple_id': '0D377F94-E836-42BC-BF9A-CCC9E0058BE7:ABPerson', 'apple_uid': '0D377F94-E836-42BC-BF9A-CCC9E0058BE7:ABPerson'}, 'nickname': '', 'addresses': [{'city': 'STOCKHOLM', 'label': '_$!<Work>!$_', 'state': '', 'street': 'VanadisvÃ¶gen 12 B', 'country': '', 'postalCode': '11346'}], 'apple_uid': '0D377F94-E836-42BC-BF9A-CCC9E0058BE7:ABPerson', 'job_title': 'FÃ¶rsÃ¤ljningschef Restaurang & Deli', 'last_name': 'HÃ¶ckert', 'department': '', 'first_name': 'Martin', 'middle_name': '', 'organization': 'ICA supermarket Vanadis', 'social_profiles': []}, created_at=2025-06-24 17:28:11.571119+02:00, id=aaa9df40-e3e9-4999-9c6f-82e1813a17ba, updated_at=2025-06-24 22:48:40.597970+02:00, email=martin.hockert@supermarket.ica.se, apple_uid=None

ğŸ“ Tabell: transaction
  â€¢ id (uuid)
  â€¢ date (date)
  â€¢ description (text)
  â€¢ series (text)
  â€¢ ver_no (integer)
  â€¢ created_at (timestamp with time zone)
  â€¢ updated_at (timestamp with time zone)
  â€¢ metadata (jsonb)
  â€¢ status (text)
  â€¢ currency_code (text)
  â€¢ exchange_rate (numeric)
  â€¢ total_amount_original (numeric)
  â€¢ created_by (uuid)
  ğŸ“ Kolumntyper:
    - id: uuid
    - date: date
    - description: text
    - series: text
    - ver_no: integer
    - created_at: timestamp with time zone
    - updated_at: timestamp with time zone
    - metadata: jsonb
    - status: text
    - currency_code: text
    - exchange_rate: numeric
    - total_amount_original: numeric
    - created_by: uuid
  ğŸ”‘ [p] transaction_pkey: PRIMARY KEY (id)
  ğŸ”‘ [u] unique_verifikat: UNIQUE (series, ver_no)
  ğŸ”‘ [c] transaction_status_check: CHECK ((status = ANY (ARRAY['prelim'::text, 'posted'::text, 'locked'::text])))
  ğŸ”‘ [f] transaction_created_by_fkey: FOREIGN KEY (created_by) REFERENCES contact(id)
  ğŸ”— Relationer:
    - created_by â¡ contact.id
  âš™ï¸ Triggers:

ğŸ“ Tabell: table_metadata
  â€¢ table_name (text)
  â€¢ category (text)
  â€¢ description (text)
  ğŸ“ Kolumntyper:
    - table_name: text
    - category: text
    - description: text
  ğŸ”‘ [p] table_metadata_pkey: PRIMARY KEY (table_name)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:
  ğŸ§ª Exempelrader:
    - table_name=account, category=bokfÃ¶ring, description=Kontoplan med baskonto-information
    - table_name=account_translation, category=bokfÃ¶ring, description=SprÃ¥kstÃ¶d fÃ¶r konton
    - table_name=entry, category=bokfÃ¶ring, description=Verifikatposter kopplade till transaktioner
    - table_name=entry_tag, category=bokfÃ¶ring, description=Taggar fÃ¶r verifikat
    - table_name=entry_tag_relation, category=bokfÃ¶ring, description=Relation entry â†” tag

ğŸ“ Tabell: booking_settings
  â€¢ key (text)
  â€¢ value (jsonb)
  â€¢ value_type (text)
  â€¢ updated_at (timestamp with time zone)
  ğŸ“ Kolumntyper:
    - key: text
    - value: jsonb
    - value_type: text
    - updated_at: timestamp with time zone
  ğŸ”‘ [p] booking_settings_pkey: PRIMARY KEY (key)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:
  ğŸ§ª Exempelrader:
    - key=email_subject_templates, value={'zoom': 'ZoommÃ¶te: {{first_name}} | {{company}} & Daniel | Kinnekulle LedningsrÃ¥dgivning AB', 'teams': 'TeamsmÃ¶te: {{first_name}} | {{company}} & Daniel | Kinnekulle LedningsrÃ¥dgivning AB', 'atclient': 'MÃ¶te hos {{company}}: {{first_name}} | {{company}} & Daniel | Kinnekulle LedningsrÃ¥dgivning AB', 'atoffice': 'MÃ¶te hos KLR AB (Stockholm | SÃ¶dermalm): {{first_name}} | {{company}} & Daniel | Kinnekulle LedningsrÃ¥dgivning AB', 'facetime': 'FaceTime-mÃ¶te: {{first_name}} | {{company}} & Daniel | Kinnekulle LedningsrÃ¥dgivning AB'}, value_type=json, updated_at=2025-05-30 22:46:14.058171+02:00
    - key=default_language, value=sv, value_type=string, updated_at=2025-05-25 12:37:53.619684+02:00
    - key=default_meeting_length_atclient, value=[90, 180, 270, 360], value_type=array, updated_at=2025-04-23 14:48:49.778155+02:00
    - key=default_meeting_length_atoffice, value=[60, 90], value_type=array, updated_at=2025-04-23 14:48:49.778155+02:00
    - key=default_meeting_length_digital, value=[10, 20, 60], value_type=array, updated_at=2025-04-23 14:48:49.778155+02:00

ğŸ“ Tabell: vat_rate
  â€¢ id (uuid)
  â€¢ name (text)
  â€¢ percentage (numeric)
  â€¢ account_sales (uuid)
  â€¢ account_vat (uuid)
  â€¢ created_at (timestamp with time zone)
  ğŸ“ Kolumntyper:
    - id: uuid
    - name: text
    - percentage: numeric
    - account_sales: uuid
    - account_vat: uuid
    - created_at: timestamp with time zone
  ğŸ”‘ [p] vat_rate_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] vat_rate_account_sales_fkey: FOREIGN KEY (account_sales) REFERENCES account(id)
  ğŸ”‘ [f] vat_rate_account_vat_fkey: FOREIGN KEY (account_vat) REFERENCES account(id)
  ğŸ”— Relationer:
    - account_sales â¡ account.id
    - account_vat â¡ account.id
  âš™ï¸ Triggers:

ğŸ“ Tabell: company
  â€¢ name (text)
  â€¢ org_number (text)
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp with time zone)
  â€¢ id (uuid)
  ğŸ“ Kolumntyper:
    - name: text
    - org_number: text
    - metadata: jsonb
    - created_at: timestamp with time zone
    - id: uuid
  ğŸ”‘ [p] company_pkey: PRIMARY KEY (id)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:

ğŸ“ Tabell: translation
  â€¢ key (character varying)
  â€¢ sv (text)
  â€¢ en (text)
  ğŸ“ Kolumntyper:
    - key: character varying
    - sv: text
    - en: text
  ğŸ”‘ [u] unique_translation_key: UNIQUE (key)
  ğŸ”‘ [p] translation_pkey: PRIMARY KEY (key)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:
  ğŸ§ª Exempelrader:
    - key=error_min_duration_fysiskt_kund, sv=MÃ¶testiden fÃ¶r 'Fysiskt hos kund' mÃ¥ste vara minst {{minutes}} minuter. Du visste det redan., en=The meeting time for 'On-site at customer' must be at least {{minutes}} minutes. You knew that.
    - key=error_min_duration_fysiskt_mig, sv=MÃ¶testiden fÃ¶r 'Fysiskt hos mig' mÃ¥ste vara minst {{minutes}} minuter. Annars hinner vi bara sÃ¤ga hej., en=The meeting time for 'At my office' must be at least {{minutes}} minutes. Otherwise, weâ€™ll only have time to say hello.
    - key=email_body_booking_received, sv=Hej {{name}}! Vi har tagit emot din bokning fÃ¶r {{meeting_type}} mellan {{start_time}} och {{end_time}}. Ingen panik â€“ vi Ã¥terkommer med bekrÃ¤ftelse. / Daniel, en=Hello {{name}}, Weâ€™ve received your booking for {{meeting_type}} between {{start_time}} and {{end_time}}. No need to panic â€“ weâ€™ll confirm shortly. / Daniel
    - key=email_body_booking_confirmed, sv=Hej {{name}}! Din bokning fÃ¶r {{meeting_type}} mellan {{start_time}} och {{end_time}} Ã¤r nu spikad. Ser fram emot det! / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} is now locked in. Looking forward! / Daniel
    - key=email_body_booking_cancelled, sv=Hej {{name}}! Din bokning fÃ¶r {{meeting_type}} mellan {{start_time}} och {{end_time}} Ã¤r avbokad. HÃ¶r av dig om du vill hitta en ny tid. / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} has been cancelled. Let me know if you'd like a new one. / Daniel

ğŸ“ Tabell: journal_series
  â€¢ series (text)
  â€¢ name (text)
  â€¢ description (text)
  â€¢ next_ver_no (integer)
  ğŸ“ Kolumntyper:
    - series: text
    - name: text
    - description: text
    - next_ver_no: integer
  ğŸ”‘ [p] journal_series_pkey: PRIMARY KEY (series)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:
  ğŸ§ª Exempelrader:
    - series=A, name=Huvudbok, description=Ordinarie verifikatserie fÃ¶r huvudbok, next_ver_no=11

ğŸ“ Tabell: period
  â€¢ id (uuid)
  â€¢ name (text)
  â€¢ start_date (date)
  â€¢ end_date (date)
  â€¢ locked (boolean)
  â€¢ created_at (timestamp with time zone)
  ğŸ“ Kolumntyper:
    - id: uuid
    - name: text
    - start_date: date
    - end_date: date
    - locked: boolean
    - created_at: timestamp with time zone
  ğŸ”‘ [p] period_pkey: PRIMARY KEY (id)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:

ğŸ“ Tabell: ccrelation
  â€¢ contact_id (uuid)
  â€¢ company_id (uuid)
  â€¢ role (text)
  â€¢ main_contact (boolean)
  â€¢ start_date (date)
  â€¢ end_date (date)
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp with time zone)
  â€¢ id (uuid)
  ğŸ“ Kolumntyper:
    - contact_id: uuid
    - company_id: uuid
    - role: text
    - main_contact: boolean
    - start_date: date
    - end_date: date
    - metadata: jsonb
    - created_at: timestamp with time zone
    - id: uuid
  ğŸ”‘ [p] ccrelation_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] fk_ccrelation_contact_id: FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE CASCADE
  ğŸ”‘ [f] fk_ccrelation_company_id: FOREIGN KEY (company_id) REFERENCES company(id) ON DELETE CASCADE
  ğŸ”— Relationer:
    - contact_id â¡ contact.id
    - company_id â¡ company.id
  âš™ï¸ Triggers:

ğŸ“ Tabell: currency
  â€¢ code (text)
  â€¢ name (text)
  â€¢ symbol (text)
  â€¢ exchange_rate (numeric)
  â€¢ updated_at (timestamp with time zone)
  ğŸ“ Kolumntyper:
    - code: text
    - name: text
    - symbol: text
    - exchange_rate: numeric
    - updated_at: timestamp with time zone
  ğŸ”‘ [p] currency_pkey: PRIMARY KEY (code)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:

ğŸ“ Tabell: template_transaction
  â€¢ id (uuid)
  â€¢ name (text)
  â€¢ description (text)
  â€¢ default_amount (numeric)
  â€¢ default_account_debit (uuid)
  â€¢ default_account_credit (uuid)
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp with time zone)
  ğŸ“ Kolumntyper:
    - id: uuid
    - name: text
    - description: text
    - default_amount: numeric
    - default_account_debit: uuid
    - default_account_credit: uuid
    - metadata: jsonb
    - created_at: timestamp with time zone
  ğŸ”‘ [p] template_transaction_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] template_transaction_default_account_debit_fkey: FOREIGN KEY (default_account_debit) REFERENCES account(id)
  ğŸ”‘ [f] template_transaction_default_account_credit_fkey: FOREIGN KEY (default_account_credit) REFERENCES account(id)
  ğŸ”— Relationer:
    - default_account_debit â¡ account.id
    - default_account_credit â¡ account.id
  âš™ï¸ Triggers:

ğŸ“ Tabell: pending_changes
  â€¢ id (uuid)
  â€¢ table_name (text)
  â€¢ record_id (uuid)
  â€¢ change_type (text)
  â€¢ direction (text)
  â€¢ processed (boolean)
  â€¢ created_at (timestamp with time zone)
  â€¢ operation (text)
  â€¢ payload (jsonb)
  â€¢ booking_id (uuid)
  ğŸ“ Kolumntyper:
    - id: uuid
    - table_name: text
    - record_id: uuid
    - change_type: text
    - direction: text
    - processed: boolean
    - created_at: timestamp with time zone
    - operation: text
    - payload: jsonb
    - booking_id: uuid
  ğŸ”‘ [p] pending_changes_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] fk_pending_changes_booking_id: FOREIGN KEY (booking_id) REFERENCES bookings(id) ON DELETE CASCADE
  ğŸ”— Relationer:
    - booking_id â¡ bookings.id
  âš™ï¸ Triggers:
  ğŸ§ª Exempelrader:
    - id=aba81075-14d8-45b7-a76e-0d8e3a8c03f6, table_name=contact, record_id=d69397a0-124b-4abe-9680-ed7e499dc67d, change_type=metadata_changed, direction=out, processed=True, created_at=2025-06-24 21:25:09.249266+02:00, operation=UPDATE, payload={'note': '', 'urls': [], 'emails': [{'email': 'jorn.lindberg@lindbergs.se', 'label': ''}], 'phones': [{'label': '_$!<Work>!$_', 'number': '+46 854566601'}, {'label': '_$!<Mobile>!$_', 'number': '+46 707250350'}], 'apple_id': '66B7D0A5-08DA-48E1-8EB7-C984691BE311:ABPerson', 'birthday': '', 'metadata': {'origin': 'klrab.se', 'apple_id': '66B7D0A5-08DA-48E1-8EB7-C984691BE311:ABPerson', 'apple_uid': '66B7D0A5-08DA-48E1-8EB7-C984691BE311:ABPerson'}, 'nickname': '', 'addresses': [{'city': 'STOCKHOLM', 'label': '_$!<Work>!$_', 'state': '', 'street': 'Box 5171', 'country': 'Sweden', 'postalCode': '102 44'}, {'city': 'STOCKHOLM', 'label': '_$!<Home>!$_', 'state': '', 'street': '', 'country': 'Sweden', 'postalCode': '10244'}], 'apple_uid': '66B7D0A5-08DA-48E1-8EB7-C984691BE311:ABPerson', 'job_title': '', 'last_name': 'Lindberg', 'department': '', 'first_name': 'JÃ¶rn', 'middle_name': '', 'organization': 'Lindberg & Son AB', 'social_profiles': []}, booking_id=None
    - id=93730a22-98ab-451e-966b-830e455fd91e, table_name=contact, record_id=d6520ce8-1319-4ab0-9905-9fdad02f8f78, change_type=metadata_changed, direction=out, processed=True, created_at=2025-06-24 21:25:53.248991+02:00, operation=UPDATE, payload={'note': '', 'urls': [], 'emails': [{'email': 'daniel.segui@anoto.com', 'label': '_$!<Other>!$_'}], 'phones': [{'label': '_$!<Mobile>!$_', 'number': '+46706244810'}], 'apple_id': '66B87025-97C5-4856-A946-35FC17E9FB09:ABPerson', 'birthday': '', 'metadata': {'origin': 'klrab.se', 'apple_id': '66B87025-97C5-4856-A946-35FC17E9FB09:ABPerson', 'apple_uid': '66B87025-97C5-4856-A946-35FC17E9FB09:ABPerson'}, 'nickname': '', 'addresses': [], 'apple_uid': '66B87025-97C5-4856-A946-35FC17E9FB09:ABPerson', 'job_title': '', 'last_name': 'Segui', 'department': '', 'first_name': 'Daniel', 'middle_name': '', 'organization': 'Anoto', 'social_profiles': []}, booking_id=None
    - id=0d9ffa21-f542-4961-8b1c-0e2cb3b25d63, table_name=contact, record_id=23026ef2-ee74-481f-bbfc-9969e76bf4b4, change_type=metadata_changed, direction=out, processed=True, created_at=2025-06-24 21:24:46.257827+02:00, operation=UPDATE, payload={'note': '', 'urls': [], 'emails': [{'email': 'p.mesterton@hotmail.com', 'label': '_$!<Home>!$_'}, {'email': 'patrik.mesterton@bonniernews.se', 'label': '_$!<Work>!$_'}, {'email': 'patrik@nordstrandsmakleri.se', 'label': '_$!<Work>!$_'}], 'phones': [{'label': '_$!<Home>!$_', 'number': '+46 70-410 26 57'}, {'label': '_$!<Work>!$_', 'number': '+4670-292 26 32'}], 'apple_id': '66BBB41D-6F95-40E4-8614-E84223FFB65A:ABPerson', 'birthday': '1967-01-12T00:00:00Z', 'metadata': {'origin': 'klrab.se', 'apple_id': '66BBB41D-6F95-40E4-8614-E84223FFB65A:ABPerson', 'apple_uid': '66BBB41D-6F95-40E4-8614-E84223FFB65A:ABPerson'}, 'nickname': 'Putte', 'addresses': [{'city': 'LidingÃ¶', 'label': '_$!<Home>!$_', 'state': '', 'street': 'SlipvÃ¤gen 7', 'country': 'Sverige', 'postalCode': '181 66'}, {'city': 'Arvika', 'label': '_$!<Other>!$_', 'state': 'VÃ¤rmlands lÃ¤n', 'street': 'Humlekil NÃ¤set 5', 'country': 'Sverige', 'postalCode': '671 91'}], 'apple_uid': '66BBB41D-6F95-40E4-8614-E84223FFB65A:ABPerson', 'job_title': 'Branschansvarig Bostad', 'last_name': 'Mesterton', 'department': '', 'first_name': 'Patrik', 'middle_name': '', 'organization': 'Dagens Nyheter', 'social_profiles': [{'url': 'https://www.linkedin.com/profile/view?id=patrik-mesterton-5b435510&trk=tardis-contact', 'label': '', 'service': 'LinkedIn'}]}, booking_id=None
    - id=f55b18b2-939e-4f90-9fd4-fba385f739ad, table_name=contact, record_id=51d203ef-b990-4360-aa09-1cf1ff1eab89, change_type=metadata_changed, direction=out, processed=True, created_at=2025-06-24 21:49:02.460442+02:00, operation=UPDATE, payload={'note': '', 'urls': [], 'emails': [{'email': 'bengt.ekberg@overview.se', 'label': '_$!<Work>!$_'}, {'email': 'bengt.ekberg@lbs.se', 'label': '_$!<Home>!$_'}], 'phones': [{'label': '_$!<Work>!$_', 'number': '+46340675617'}, {'label': '_$!<Mobile>!$_', 'number': '+46705844361'}], 'apple_id': '538B55B2-1E18-471A-AF12-8D3F80953D3F:ABPerson', 'birthday': '', 'metadata': {'origin': 'klrab.se', 'apple_id': '538B55B2-1E18-471A-AF12-8D3F80953D3F:ABPerson', 'apple_uid': '538B55B2-1E18-471A-AF12-8D3F80953D3F:ABPerson'}, 'nickname': '', 'addresses': [{'city': 'VARBERG', 'label': '_$!<Work>!$_', 'state': '', 'street': 'Kungsgatan 12C', 'country': 'Sweden', 'postalCode': '432 16'}, {'city': 'VARBERG', 'label': '_$!<Home>!$_', 'state': '', 'street': '', 'country': 'Sweden', 'postalCode': '432 16'}], 'apple_uid': '538B55B2-1E18-471A-AF12-8D3F80953D3F:ABPerson', 'job_title': '', 'last_name': 'Ekberg', 'department': '', 'first_name': 'Bengt', 'middle_name': '', 'organization': 'Ljud & Bildskolan LBS AB', 'social_profiles': []}, booking_id=None
    - id=b98cbf16-1005-43c2-9d8a-0bc5117b975d, table_name=contact, record_id=0b9bc780-17f5-4632-a77c-077a5c6191c1, change_type=metadata_changed, direction=out, processed=True, created_at=2025-06-24 21:24:46.343166+02:00, operation=UPDATE, payload={'note': '', 'urls': [], 'emails': [{'email': 'kalle.farnskog@gmail.com', 'label': '_$!<Home>!$_'}], 'phones': [{'label': 'iPhone', 'number': '+46 70-162 72 20'}], 'apple_id': '671301C1-1E5C-4B1A-89E9-22E79449D756:ABPerson', 'birthday': '', 'metadata': {'origin': 'klrab.se', 'apple_id': '671301C1-1E5C-4B1A-89E9-22E79449D756:ABPerson', 'apple_uid': '671301C1-1E5C-4B1A-89E9-22E79449D756:ABPerson'}, 'nickname': '', 'addresses': [], 'apple_uid': '671301C1-1E5C-4B1A-89E9-22E79449D756:ABPerson', 'job_title': '', 'last_name': 'FÃ¤rnskog', 'department': '', 'first_name': 'Kalle', 'middle_name': '', 'organization': '', 'social_profiles': []}, booking_id=None

ğŸ“ Tabell: entry_tag
  â€¢ id (uuid)
  â€¢ name (text)
  â€¢ description (text)
  â€¢ created_at (timestamp with time zone)
  ğŸ“ Kolumntyper:
    - id: uuid
    - name: text
    - description: text
    - created_at: timestamp with time zone
  ğŸ”‘ [p] entry_tag_pkey: PRIMARY KEY (id)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:

ğŸ“ Tabell: account
  â€¢ id (uuid)
  â€¢ number (text)
  â€¢ name (text)
  â€¢ type (text)
  â€¢ created_at (timestamp with time zone)
  â€¢ updated_at (timestamp with time zone)
  â€¢ is_active (boolean)
  â€¢ account_group (text)
  â€¢ report_type (text)
  â€¢ report_group (text)
  ğŸ“ Kolumntyper:
    - id: uuid
    - number: text
    - name: text
    - type: text
    - created_at: timestamp with time zone
    - updated_at: timestamp with time zone
    - is_active: boolean
    - account_group: text
    - report_type: text
    - report_group: text
  ğŸ”‘ [p] account_pkey: PRIMARY KEY (id)
  ğŸ”‘ [u] account_number_key: UNIQUE (number)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:
  ğŸ§ª Exempelrader:
    - id=84d18e0a-2338-4c67-8151-5a44f6131d3f, number=1930, name=FÃ¶retagskonto, type=tillgÃ¥ng, created_at=2025-06-03 15:16:53.189475+02:00, updated_at=2025-06-03 15:16:53.189475+02:00, is_active=True, account_group=None, report_type=None, report_group=None
    - id=bc275792-31a3-40b5-8a1d-29cff9d2e7d0, number=3001, name=FÃ¶rsÃ¤ljning Sverige 25%, type=intÃ¤kt, created_at=2025-06-03 15:16:53.189475+02:00, updated_at=2025-06-03 15:16:53.189475+02:00, is_active=True, account_group=None, report_type=None, report_group=None
    - id=2b78ec5e-6f1d-4403-b7af-cc61f611155e, number=2611, name=UtgÃ¥ende moms 25%, type=skuld, created_at=2025-06-03 15:16:53.189475+02:00, updated_at=2025-06-03 15:16:53.189475+02:00, is_active=True, account_group=None, report_type=None, report_group=None
    - id=f826389c-d9ec-42db-8f17-920ea0e082cd, number=2010, name=Eget kapital, type=eget_kapital, created_at=2025-06-03 16:20:49.857423+02:00, updated_at=2025-06-03 16:20:49.857423+02:00, is_active=True, account_group=None, report_type=None, report_group=None
    - id=5e3ba7a3-1683-42a3-afe5-e03839170542, number=2390, name=Ã–vriga lÃ¥ngfristiga skulder, type=skuld, created_at=2025-06-03 16:20:49.857423+02:00, updated_at=2025-06-03 16:20:49.857423+02:00, is_active=True, account_group=None, report_type=None, report_group=None

ğŸ“ Tabell: report_structure
  â€¢ id (integer)
  â€¢ report_type (text)
  â€¢ group_name (text)
  â€¢ account_number (text)
  â€¢ account_range (text)
  â€¢ order_index (integer)
  ğŸ“ Kolumntyper:
    - id: integer
    - report_type: text
    - group_name: text
    - account_number: text
    - account_range: text
    - order_index: integer
  ğŸ”‘ [p] report_structure_pkey: PRIMARY KEY (id)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:
  ğŸ§ª Exempelrader:
    - id=1, report_type=resultat, group_name=IntÃ¤kter, account_number=None, account_range=3000-3999, order_index=10
    - id=2, report_type=resultat, group_name=Varukostnader, account_number=None, account_range=4000-4999, order_index=20
    - id=3, report_type=resultat, group_name=Ã–vriga externa kostnader, account_number=None, account_range=5000-5999, order_index=30
    - id=4, report_type=resultat, group_name=Personalkostnader, account_number=None, account_range=6000-6999, order_index=40
    - id=5, report_type=resultat, group_name=Avskrivningar, account_number=None, account_range=7000-7999, order_index=50

ğŸ“ Tabell: transaction_translation
  â€¢ transaction_id (uuid)
  â€¢ language (text)
  â€¢ description (text)
  ğŸ“ Kolumntyper:
    - transaction_id: uuid
    - language: text
    - description: text
  ğŸ”‘ [p] transaction_translation_pkey: PRIMARY KEY (transaction_id, language)
  ğŸ”‘ [f] transaction_translation_transaction_id_fkey: FOREIGN KEY (transaction_id) REFERENCES transaction(id) ON DELETE CASCADE
  ğŸ”— Relationer:
    - transaction_id â¡ transaction.id
  âš™ï¸ Triggers:

ğŸ“ Tabell: account_translation
  â€¢ account_id (uuid)
  â€¢ language (text)
  â€¢ name (text)
  ğŸ“ Kolumntyper:
    - account_id: uuid
    - language: text
    - name: text
  ğŸ”‘ [p] account_translation_pkey: PRIMARY KEY (account_id, language)
  ğŸ”‘ [f] account_translation_account_id_fkey: FOREIGN KEY (account_id) REFERENCES account(id) ON DELETE CASCADE
  ğŸ”— Relationer:
    - account_id â¡ account.id
  âš™ï¸ Triggers:
  ğŸ§ª Exempelrader:
    - account_id=84d18e0a-2338-4c67-8151-5a44f6131d3f, language=en, name=Corporate Bank Account
    - account_id=bc275792-31a3-40b5-8a1d-29cff9d2e7d0, language=en, name=Sales Sweden 25% VAT
    - account_id=2b78ec5e-6f1d-4403-b7af-cc61f611155e, language=en, name=Output VAT 25%
    - account_id=f826389c-d9ec-42db-8f17-920ea0e082cd, language=en, name=Equity
    - account_id=5e3ba7a3-1683-42a3-afe5-e03839170542, language=en, name=Other Long-term Liabilities

ğŸ“ Tabell: settings
  â€¢ key (text)
  â€¢ value (text)
  â€¢ value_type (text)
  â€¢ updated_at (timestamp with time zone)
  ğŸ“ Kolumntyper:
    - key: text
    - value: text
    - value_type: text
    - updated_at: timestamp with time zone
  ğŸ”‘ [p] settings_pkey: PRIMARY KEY (key)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:
  ğŸ§ª Exempelrader:
    - key=default_language, value=sv, value_type=string, updated_at=2025-06-03 16:17:04.085806+02:00
    - key=reporting_currency, value=SEK, value_type=string, updated_at=2025-06-03 16:17:04.085806+02:00
    - key=period_start_month, value=1, value_type=integer, updated_at=2025-06-03 16:17:04.085806+02:00

ğŸ“ Tabell: budget
  â€¢ year (integer)
  â€¢ month (integer)
  â€¢ account_number (text)
  â€¢ amount (numeric)
  ğŸ“ Kolumntyper:
    - year: integer
    - month: integer
    - account_number: text
    - amount: numeric
  ğŸ”— Relationer:
  âš™ï¸ Triggers:

ğŸ“ Tabell: bank_statement
  â€¢ id (uuid)
  â€¢ date (date)
  â€¢ balance (numeric)
  â€¢ source (text)
  â€¢ metadata (jsonb)
  ğŸ“ Kolumntyper:
    - id: uuid
    - date: date
    - balance: numeric
    - source: text
    - metadata: jsonb
  ğŸ”‘ [p] bank_statement_pkey: PRIMARY KEY (id)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:

ğŸ“ Tabell: pending_verification
  â€¢ id (uuid)
  â€¢ email (text)
  â€¢ token (text)
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp without time zone)
  â€¢ used_at (timestamp without time zone)
  ğŸ“ Kolumntyper:
    - id: uuid
    - email: text
    - token: text
    - metadata: jsonb
    - created_at: timestamp without time zone
    - used_at: timestamp without time zone
  ğŸ”‘ [p] pending_verification_pkey: PRIMARY KEY (id)
  ğŸ”‘ [u] pending_verification_token_key: UNIQUE (token)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:

ğŸ“ Tabell: tracking_event
  â€¢ id (uuid)
  â€¢ visitor_id (text)
  â€¢ event_type (text)
  â€¢ timestamp (timestamp with time zone)
  â€¢ metadata (jsonb)
  ğŸ“ Kolumntyper:
    - id: uuid
    - visitor_id: text
    - event_type: text
    - timestamp: timestamp with time zone
    - metadata: jsonb
  ğŸ”‘ [p] tracking_event_pkey: PRIMARY KEY (id)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:
  ğŸ§ª Exempelrader:
    - id=65448382-0365-4057-8c78-2d7ef1bbfd18, visitor_id=ceb0405d-6f78-42a9-9253-b4235765a287, event_type=page_view, timestamp=2025-06-24 17:55:19.476000+02:00, metadata={'url': '/', 'utm': {'medium': None, 'source': None, 'campaign': None}, 'screen': {'width': 390, 'height': 844, 'devicePixelRatio': 3}, 'language': 'sv-SE', 'nav_type': 0, 'platform': 'iPhone', 'referrer': 'http://m.facebook.com/', 'timezone': 'Europe/Stockholm', 'viewport': {'scrollY': 0, 'innerHeight': 655}, 'is_mobile': True, 'ip_address': None, 'user_agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/22F76 [FBAN/FBIOS;FBAV/518.0.0.52.100;FBBV/750192798;FBDV/iPhone14,5;FBMD/iPhone;FBSN/iOS;FBSV/18.5;FBSS/3;FBID/phone;FBLC/sv_SE;FBOP/5;FBRV/752652323;IABMV/1]', 'color_depth': 24, 'fingerprint': 'c43a04fb73eb91c09e117f6003b3831cbf68534200177807da45a4b9bf593139', 'deviceMemory': None, 'do_not_track': False, 'performance_now': 1523, 'hardwareConcurrency': 4, 'timezone_offset_min': -120}
    - id=0d4bfbba-1290-4092-8b9a-708ffffb761c, visitor_id=ceb0405d-6f78-42a9-9253-b4235765a287, event_type=scroll_50, timestamp=2025-06-24 17:55:39.933000+02:00, metadata={'url': '/', 'utm': {'medium': None, 'source': None, 'campaign': None}, 'screen': {'width': 390, 'height': 844, 'devicePixelRatio': 3}, 'language': 'sv-SE', 'nav_type': 0, 'platform': 'iPhone', 'referrer': 'http://m.facebook.com/', 'timezone': 'Europe/Stockholm', 'viewport': {'scrollY': 1310, 'innerHeight': 769}, 'is_mobile': True, 'ip_address': '94.191.139.100', 'user_agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/22F76 [FBAN/FBIOS;FBAV/518.0.0.52.100;FBBV/750192798;FBDV/iPhone14,5;FBMD/iPhone;FBSN/iOS;FBSV/18.5;FBSS/3;FBID/phone;FBLC/sv_SE;FBOP/5;FBRV/752652323;IABMV/1]', 'color_depth': 24, 'fingerprint': 'c43a04fb73eb91c09e117f6003b3831cbf68534200177807da45a4b9bf593139', 'deviceMemory': None, 'do_not_track': False, 'page_load_ms': 1927, 'performance_now': 21982, 'hardwareConcurrency': 4, 'timezone_offset_min': -120}
    - id=4f52e783-cb5f-4d4a-bd67-9bf601667129, visitor_id=ceb0405d-6f78-42a9-9253-b4235765a287, event_type=click, timestamp=2025-06-24 17:55:47.207000+02:00, metadata={'tag': 'A', 'url': '/', 'utm': {'medium': None, 'source': None, 'campaign': None}, 'href': 'https://www.klrab.se/sustainability', 'text': 'HÃ…LLBARHET', 'screen': {'width': 390, 'height': 844, 'devicePixelRatio': 3}, 'language': 'sv-SE', 'nav_type': 0, 'platform': 'iPhone', 'referrer': 'http://m.facebook.com/', 'timezone': 'Europe/Stockholm', 'viewport': {'scrollY': 813, 'innerHeight': 655}, 'is_mobile': True, 'ip_address': '94.191.139.100', 'user_agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/22F76 [FBAN/FBIOS;FBAV/518.0.0.52.100;FBBV/750192798;FBDV/iPhone14,5;FBMD/iPhone;FBSN/iOS;FBSV/18.5;FBSS/3;FBID/phone;FBLC/sv_SE;FBOP/5;FBRV/752652323;IABMV/1]', 'color_depth': 24, 'fingerprint': 'c43a04fb73eb91c09e117f6003b3831cbf68534200177807da45a4b9bf593139', 'deviceMemory': None, 'do_not_track': False, 'page_load_ms': 1927, 'performance_now': 29256, 'hardwareConcurrency': 4, 'timezone_offset_min': -120, 'time_since_page_load_ms': 29250}
    - id=a0f20249-cc96-474c-94ea-ba6d9fe68659, visitor_id=ceb0405d-6f78-42a9-9253-b4235765a287, event_type=page_view, timestamp=2025-06-24 17:55:47.580000+02:00, metadata={'url': '/sustainability', 'utm': {'medium': None, 'source': None, 'campaign': None}, 'screen': {'width': 390, 'height': 844, 'devicePixelRatio': 3}, 'language': 'sv-SE', 'nav_type': 0, 'platform': 'iPhone', 'referrer': 'https://www.klrab.se/?fbclid=IwZXh0bgNhZW0CMTEAAR5hzWmOzv6HpUYbozAgHZ2Vx9j0qWTw58evLsXlWjFnkuvI-ev2yHSNbA58RQ_aem_QNWFcdQrigQcphPI8p1LqA', 'timezone': 'Europe/Stockholm', 'viewport': {'scrollY': 0, 'innerHeight': 655}, 'is_mobile': True, 'ip_address': None, 'user_agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/22F76 [FBAN/FBIOS;FBAV/518.0.0.52.100;FBBV/750192798;FBDV/iPhone14,5;FBMD/iPhone;FBSN/iOS;FBSV/18.5;FBSS/3;FBID/phone;FBLC/sv_SE;FBOP/5;FBRV/752652323;IABMV/1]', 'color_depth': 24, 'fingerprint': 'c43a04fb73eb91c09e117f6003b3831cbf68534200177807da45a4b9bf593139', 'deviceMemory': None, 'do_not_track': False, 'page_load_ms': 364, 'performance_now': 363, 'hardwareConcurrency': 4, 'timezone_offset_min': -120}
    - id=acc6e76d-bc03-4d85-bacc-c6ab4c5390ac, visitor_id=ceb0405d-6f78-42a9-9253-b4235765a287, event_type=scroll_50, timestamp=2025-06-24 17:55:51.856000+02:00, metadata={'url': '/sustainability', 'utm': {'medium': None, 'source': None, 'campaign': None}, 'screen': {'width': 390, 'height': 844, 'devicePixelRatio': 3}, 'language': 'sv-SE', 'nav_type': 0, 'platform': 'iPhone', 'referrer': 'https://www.klrab.se/?fbclid=IwZXh0bgNhZW0CMTEAAR5hzWmOzv6HpUYbozAgHZ2Vx9j0qWTw58evLsXlWjFnkuvI-ev2yHSNbA58RQ_aem_QNWFcdQrigQcphPI8p1LqA', 'timezone': 'Europe/Stockholm', 'viewport': {'scrollY': 1223, 'innerHeight': 769}, 'is_mobile': True, 'ip_address': '94.191.139.100', 'user_agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/22F76 [FBAN/FBIOS;FBAV/518.0.0.52.100;FBBV/750192798;FBDV/iPhone14,5;FBMD/iPhone;FBSN/iOS;FBSV/18.5;FBSS/3;FBID/phone;FBLC/sv_SE;FBOP/5;FBRV/752652323;IABMV/1]', 'color_depth': 24, 'fingerprint': 'c43a04fb73eb91c09e117f6003b3831cbf68534200177807da45a4b9bf593139', 'deviceMemory': None, 'do_not_track': False, 'page_load_ms': 364, 'performance_now': 4640, 'hardwareConcurrency': 4, 'timezone_offset_min': -120}

ğŸ“ Tabell: entry
  â€¢ id (uuid)
  â€¢ transaction_id (uuid)
  â€¢ account_id (uuid)
  â€¢ amount (numeric)
  â€¢ description (text)
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp with time zone)
  â€¢ amount_original (numeric)
  ğŸ“ Kolumntyper:
    - id: uuid
    - transaction_id: uuid
    - account_id: uuid
    - amount: numeric
    - description: text
    - metadata: jsonb
    - created_at: timestamp with time zone
    - amount_original: numeric
  ğŸ”‘ [p] entry_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] entry_transaction_id_fkey: FOREIGN KEY (transaction_id) REFERENCES transaction(id) ON DELETE CASCADE
  ğŸ”‘ [f] entry_account_id_fkey: FOREIGN KEY (account_id) REFERENCES account(id) ON DELETE RESTRICT
  ğŸ”— Relationer:
    - transaction_id â¡ transaction.id
    - account_id â¡ account.id
  âš™ï¸ Triggers:

ğŸ“ Tabell: attachment
  â€¢ id (uuid)
  â€¢ transaction_id (uuid)
  â€¢ filename (text)
  â€¢ content_type (text)
  â€¢ data (bytea)
  â€¢ uploaded_at (timestamp with time zone)
  â€¢ metadata (jsonb)
  ğŸ“ Kolumntyper:
    - id: uuid
    - transaction_id: uuid
    - filename: text
    - content_type: text
    - data: bytea
    - uploaded_at: timestamp with time zone
    - metadata: jsonb
  ğŸ”‘ [p] attachment_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] attachment_transaction_id_fkey: FOREIGN KEY (transaction_id) REFERENCES transaction(id) ON DELETE CASCADE
  ğŸ”— Relationer:
    - transaction_id â¡ transaction.id
  âš™ï¸ Triggers:

ğŸ“ Tabell: entry_tag_relation
  â€¢ entry_id (uuid)
  â€¢ tag_id (uuid)
  ğŸ“ Kolumntyper:
    - entry_id: uuid
    - tag_id: uuid
  ğŸ”‘ [p] entry_tag_relation_pkey: PRIMARY KEY (entry_id, tag_id)
  ğŸ”‘ [f] entry_tag_relation_entry_id_fkey: FOREIGN KEY (entry_id) REFERENCES entry(id) ON DELETE CASCADE
  ğŸ”‘ [f] entry_tag_relation_tag_id_fkey: FOREIGN KEY (tag_id) REFERENCES entry_tag(id) ON DELETE CASCADE
  ğŸ”— Relationer:
    - entry_id â¡ entry.id
    - tag_id â¡ entry_tag.id
  âš™ï¸ Triggers:

ğŸ“ Tabell: event_log
  â€¢ source (text)
  â€¢ event_type (text)
  â€¢ payload (jsonb)
  â€¢ received_at (timestamp with time zone)
  â€¢ id (uuid)
  â€¢ table_name (text)
  â€¢ record_id (uuid)
  â€¢ action (text)
  â€¢ timestamp (timestamp with time zone)
  â€¢ booking_id (uuid)
  ğŸ“ Kolumntyper:
    - source: text
    - event_type: text
    - payload: jsonb
    - received_at: timestamp with time zone
    - id: uuid
    - table_name: text
    - record_id: uuid
    - action: text
    - timestamp: timestamp with time zone
    - booking_id: uuid
  ğŸ”‘ [p] event_log_pkey: PRIMARY KEY (id)
  ğŸ”— Relationer:
  âš™ï¸ Triggers:
  ğŸ§ª Exempelrader:
    - source=None, event_type=None, payload=None, received_at=2025-06-24 17:28:11.571119+02:00, id=38d75043-8239-45aa-bf67-921675749983, table_name=contact, record_id=61b2a257-9368-4017-9552-0c22810a03cb, action=INSERT, timestamp=2025-06-24 17:28:11.571119+02:00, booking_id=None
    - source=None, event_type=None, payload=None, received_at=2025-06-24 17:28:11.571119+02:00, id=c0aaac8a-2080-47e6-a185-abd24b718595, table_name=contact, record_id=e17c6638-c18b-472c-a566-a3785f82135c, action=INSERT, timestamp=2025-06-24 17:28:11.571119+02:00, booking_id=None
    - source=None, event_type=None, payload=None, received_at=2025-06-24 17:28:11.571119+02:00, id=5b6fdb0f-f11c-4fcb-88fa-670d15a065eb, table_name=contact, record_id=570d0c49-dd0a-49bf-84c1-3ee75f4dd33e, action=INSERT, timestamp=2025-06-24 17:28:11.571119+02:00, booking_id=None
    - source=None, event_type=None, payload=None, received_at=2025-06-24 17:28:11.571119+02:00, id=6839af9a-3393-46a9-b0f8-e511d3775806, table_name=contact, record_id=c6a9bd11-8cca-4ad0-888c-40e8136720d2, action=INSERT, timestamp=2025-06-24 17:28:11.571119+02:00, booking_id=None
    - source=None, event_type=None, payload=None, received_at=2025-06-24 17:28:11.571119+02:00, id=e2fde31b-4acb-4349-a00c-db9f22a9f9c3, table_name=contact, record_id=c02f4a7e-00b4-4671-bc9b-362ad00ed1e8, action=INSERT, timestamp=2025-06-24 17:28:11.571119+02:00, booking_id=None

