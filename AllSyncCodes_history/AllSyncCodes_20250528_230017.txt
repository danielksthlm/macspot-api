üìÇ KODTR√ÑD
==========
‚îú‚îÄ‚îÄ macspot.sync.plist
‚îú‚îÄ‚îÄ sync.py
‚îú‚îÄ‚îÄ sync_all.py
‚îú‚îÄ‚îÄ sync_from_cloud.py
‚îú‚îÄ‚îÄ sync_static_tables.py
‚îú‚îÄ‚îÄ sync_to_cloud.py
==========

====================
üìÑ Fil: sync_from_cloud.py
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üêç Python
üìÖ Senast √§ndrad: 2025-05-15 18:23:27
üìè Antal rader: 141
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ['import psycopg2', 'import json']
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 28
üß™ TODO/FIXME: 0
====================
START: sync_from_cloud.py
import psycopg2
import json
from config import LOCAL_DB_CONFIG, REMOTE_DB_CONFIG

def connect_db(config):
    return psycopg2.connect(**config)

def apply_change(cur, table, operation, payload):
    if operation == "INSERT":
        cols = ", ".join(payload.keys())
        placeholders = ", ".join(["%s"] * len(payload))
        sql = f"INSERT INTO {table} ({cols}) VALUES ({placeholders}) ON CONFLICT (id) DO NOTHING"
        cur.execute(sql, [json.dumps(v) if isinstance(v, dict) else v for v in payload.values()])
    elif operation == "UPDATE":
        if table == "contact" and "metadata" in payload:
            local_meta = payload["metadata"]
            if isinstance(local_meta, str):
                local_meta = json.loads(local_meta)
            cur.execute("SELECT metadata FROM contact WHERE id = %s", (payload["id"],))
            row = cur.fetchone()
            if row:
                remote_meta = row[0]
                if isinstance(remote_meta, str):
                    remote_meta = json.loads(remote_meta)
                if remote_meta == local_meta:
                    print(f"‚ôªÔ∏è Ingen skillnad i metadata f√∂r {payload['id']}, hoppar UPDATE och markerar som klar.")
                    return
        sets = ", ".join([f"{col} = %s" for col in payload if col != "id"])
        values = [json.dumps(payload[col]) if isinstance(payload[col], dict) else payload[col] for col in payload if col != "id"]
        values.append(payload["id"])
        sql = f"UPDATE {table} SET {sets} WHERE id = %s"
        cur.execute(sql, values)
        cur.execute("SELECT metadata, updated_at FROM contact WHERE id = %s", [payload["id"]])
        updated_row = cur.fetchone()
        if updated_row:
            try:
                metadata = updated_row[0]
                if isinstance(metadata, str):
                    metadata = json.loads(metadata)
                address = metadata.get("address", "(ingen adress)")
            except Exception:
                address = "(kunde inte tolkas)"
            print(f"üßæ Efter UPDATE: {payload['id']} ‚Üí {address} @ {updated_row[1]}")
        else:
            print(f"‚ö†Ô∏è UPDATE-verifiering misslyckades: Inget resultat f√∂r {payload['id']}")
    elif operation == "DELETE":
        sql = f"DELETE FROM {table} WHERE id = %s"
        cur.execute(sql, [payload["id"]])

def sync():
    remote_conn = connect_db(REMOTE_DB_CONFIG)
    remote_cur = remote_conn.cursor()

    local_conn = connect_db(LOCAL_DB_CONFIG)
    local_cur = local_conn.cursor()

    remote_cur.execute("""
        SELECT id, table_name, record_id, operation, payload
        FROM (
            SELECT *, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
            FROM pending_changes
            WHERE direction = 'out' AND processed = false
              AND table_name IN ('contact', 'bookings')
        ) sub
        WHERE rn = 1
        ORDER BY created_at ASC, id
    """)
    rows = remote_cur.fetchall()

    remote_cur.execute("""
        DELETE FROM pending_changes
        WHERE id NOT IN (
            SELECT id FROM (
                SELECT id, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
                FROM pending_changes
                WHERE direction = 'out' AND processed = false
            ) sub
            WHERE rn = 1
        ) AND direction = 'out' AND processed = false AND operation = 'UPDATE';
    """)

    seen_record_ids = set()
    for row in rows:
        try:
            payload_preview = row[4] if isinstance(row[4], dict) else json.loads(row[4])
            rid = payload_preview.get("id")
            email = payload_preview.get("booking_email", "ok√§nd e-post")
            seen_record_ids.add(rid)
        except Exception as e:
            pass
    count = 0
    for row in rows:
        change_id, table, record_id, operation, payload_json = row
        try:
            payload = payload_json if isinstance(payload_json, dict) else json.loads(payload_json)
            if not isinstance(payload.get("id"), str) or "your-generated-id" in payload.get("id"):
                continue
            apply_change(local_cur, table, operation, payload)
            if table == "bookings" and operation == "INSERT":
                local_cur.execute(
                    """
                    UPDATE pending_changes
                    SET booking_id = %s
                    WHERE record_id = %s AND table_name = 'bookings' AND booking_id IS NULL
                    """,
                    (record_id, record_id)
                )
                local_conn.commit()
            if table == "contact":
                email = payload.get("booking_email", "(ok√§nd e-post)")
                meta = payload.get("metadata")
                if isinstance(meta, str):
                    try:
                        meta = json.loads(meta)
                    except Exception:
                        meta = {}
                elif not isinstance(meta, dict):
                    meta = {}
                address = meta.get("address", "(ok√§nd adress)")
                print(f"üì• Importerad kontakt: {email} ‚Üí {address}")
            if table == "bookings" and operation == "INSERT":
                pass  # Notis borttagen
            local_cur.execute("""
                INSERT INTO event_log (id, source, event_type, payload, received_at)
                VALUES (gen_random_uuid(), %s, %s, %s, now())
            """, ('sync', f"{operation.lower()}_{table}", json.dumps(payload)))
            remote_cur.execute("UPDATE pending_changes SET processed = true WHERE id = %s", [change_id])
            remote_conn.commit()
            count += 1
        except Exception as e:
            print(f"‚ùå Fel vid synk f√∂r {table} (id={change_id}): {e}")
            continue

    local_conn.commit()
    local_cur.close()
    remote_cur.close()
    local_conn.close()
    remote_conn.close()

if __name__ == "__main__":
    sync()
END: sync_from_cloud.py

====================
üìÑ Fil: sync_to_cloud.py
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üêç Python
üìÖ Senast √§ndrad: 2025-05-15 18:23:01
üìè Antal rader: 211
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 3 ‚Äì ['import psycopg2', 'import json', 'import traceback']
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 41
üß™ TODO/FIXME: 0
====================
START: sync_to_cloud.py
import psycopg2
import json
from datetime import datetime, timezone
from config import LOCAL_DB_CONFIG, REMOTE_DB_CONFIG

def connect_db(config):
    return psycopg2.connect(**config)

def fetch_pending_changes(conn):
    with conn.cursor() as cur:
        cur.execute("""
            SELECT id, table_name, record_id, operation, payload
            FROM (
                SELECT *, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
                FROM pending_changes
                WHERE direction = 'out' AND processed = false
                  AND table_name IN ('contact', 'bookings')
            ) sub
            WHERE rn = 1
            ORDER BY created_at ASC, id
        """)
        rows = cur.fetchall()

        # Rensa √§ldre UPDATE-poster med samma record_id
        cur.execute("""
            DELETE FROM pending_changes
            WHERE id NOT IN (
                SELECT id FROM (
                    SELECT id, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
                    FROM pending_changes
                    WHERE direction = 'out' AND processed = false
                ) sub
                WHERE rn = 1
            ) AND direction = 'out' AND processed = false AND operation = 'UPDATE';
        """)
        return rows

def mark_as_processed(conn, change_id):
    with conn.cursor() as cur:
        cur.execute("UPDATE pending_changes SET processed = true WHERE id = %s", (change_id,))
        conn.commit()

#
# üìù SYNC-BETEENDE: Hantering av metadata
#
# Viktigt att f√∂rst√• skillnaden:
#
# 1. √Ñndring av v√§rde:
#    - Exempel: "postal_code": "111 11" ‚Üí "115 32"
#    - Hanteras som en vanlig UPDATE (om updated_at √§r nyare)
#
# 2. √Ñndring av nyckel (etikett):
#    - Exempel: "postal_number" ‚Üí "postal_code"
#    - Molnet kommer *inte* ta bort "postal_number" utan force_resync
#    - L√§gg till `"force_resync": true` i metadata f√∂r att tvinga full √∂verskrivning
#
# Detta minskar risken att data i molnet raderas av misstag.

def apply_change(conn, change, local_conn):
    table_name, record_id, operation, payload = change[1], change[2], change[3], change[4]
    with conn.cursor() as cur:
        data = json.loads(payload) if isinstance(payload, str) else payload

        # Skip contact records with metadata.origin != 'klrab.se'
        if table_name == 'contact' and 'metadata' in data:
            meta = json.loads(data['metadata']) if isinstance(data['metadata'], str) else data['metadata']
            if meta.get('origin') != 'klrab.se':
                print(f"‚ö†Ô∏è Skickas ej: origin != klrab.se ‚Äì {data.get('booking_email')}")
                mark_as_processed(local_conn, change[0])
                return

        # Ensure all values are serializable to SQL
        for k, v in data.items():
            if isinstance(v, dict):
                data[k] = json.dumps(v)

        if 'updated_at' in data:
            if isinstance(data['updated_at'], str):
                # Parse and convert to UTC if it's a string
                try:
                    dt = datetime.fromisoformat(data['updated_at'])
                    data['updated_at'] = dt.astimezone(timezone.utc).isoformat()
                except Exception as e:
                    print(f"‚ö†Ô∏è Kunde inte tolka updated_at: {data['updated_at']} ({e})")
            elif isinstance(data['updated_at'], datetime):
                data['updated_at'] = data['updated_at'].astimezone(timezone.utc).isoformat()

        if operation == 'INSERT':
            columns = ', '.join(data.keys())
            placeholders = ', '.join(['%s'] * len(data))
            values = list(data.values())
            cur.execute(
                f"INSERT INTO {table_name} ({columns}) VALUES ({placeholders}) "
                f"ON CONFLICT (id) DO UPDATE SET "
                f"{', '.join([f'{k} = EXCLUDED.{k}' for k in data.keys() if k != 'id'])}",
                values
            )
            if table_name == 'bookings':
                with local_conn.cursor() as local_cur:
                    local_cur.execute(
                        """
                        UPDATE pending_changes
                        SET booking_id = %s
                        WHERE record_id = %s AND table_name = 'bookings' AND booking_id IS NULL
                        """,
                        (record_id, record_id)
                    )
                    local_conn.commit()
        if 'metadata' in data and table_name == 'contact':
            # Merge metadata with existing remote value and ensure JSON string
            cur.execute(f"SELECT metadata FROM {table_name} WHERE id = %s", (record_id,))
            row = cur.fetchone()
            if row and row[0]:
                if isinstance(row[0], dict):
                    existing_metadata = row[0]
                else:
                    existing_metadata = json.loads(row[0])
            else:
                existing_metadata = {}

            incoming_metadata = json.loads(data['metadata']) if isinstance(data['metadata'], str) else data['metadata']
            if existing_metadata == incoming_metadata:
                mark_as_processed(local_conn, change[0])
                return
            existing_metadata.update(incoming_metadata)
            changed_keys = [k for k in incoming_metadata if existing_metadata.get(k) != incoming_metadata[k]]
            if not changed_keys:
                mark_as_processed(local_conn, change[0])
                return
            data['metadata'] = json.dumps(existing_metadata)

        if operation == 'UPDATE':
            # F√∂rb√§ttrad hantering av tidsj√§mf√∂relse f√∂r updated_at
            if 'updated_at' in data:
                try:
                    # S√§kerst√§ll att local_ts √§r datetime i UTC
                    local_ts = data['updated_at']
                    if isinstance(local_ts, str):
                        local_ts = datetime.fromisoformat(local_ts)
                    if local_ts.tzinfo is None:
                        local_ts = local_ts.replace(tzinfo=timezone.utc)
                    else:
                        local_ts = local_ts.astimezone(timezone.utc)

                    cur.execute(f"SELECT updated_at FROM {table_name} WHERE id = %s", (record_id,))
                    row = cur.fetchone()
                    if row and row[0] and isinstance(row[0], datetime):
                        remote_ts = row[0]
                        if remote_ts.tzinfo is None:
                            remote_ts = remote_ts.replace(tzinfo=timezone.utc)
                        else:
                            remote_ts = remote_ts.astimezone(timezone.utc)

                        if local_ts <= remote_ts:
                            mark_as_processed(local_conn, change[0])
                            return
                except Exception:
                    pass

            if table_name == "contact" and "metadata" in data:
                local_meta = data["metadata"]
                if isinstance(local_meta, str):
                    local_meta = json.loads(local_meta)
                cur.execute("SELECT metadata FROM contact WHERE id = %s", (data["id"],))
                row = cur.fetchone()
                if row:
                    remote_meta = row[0]
                    if isinstance(remote_meta, str):
                        remote_meta = json.loads(remote_meta)
                    if remote_meta == local_meta:
                        mark_as_processed(local_conn, change[0])
                        return

            columns = ', '.join(data.keys())
            placeholders = ', '.join(['%s'] * len(data))
            values = list(data.values())
            update_keys = [k for k in data.keys() if k != 'id']
            update_set = ', '.join([f"{k} = %s" for k in update_keys])
            update_values = [data[k] for k in update_keys]
            update_values.append(record_id)
            cur.execute(
                f"UPDATE {table_name} SET {update_set} WHERE id = %s",
                update_values
            )
            cur.execute("SELECT metadata, updated_at FROM contact WHERE id = %s", [payload["id"]])
            updated_row = cur.fetchone()
        elif operation == 'DELETE':
            cur.execute(f"DELETE FROM {table_name} WHERE id = %s", (record_id,))
        conn.commit()
        mark_as_processed(local_conn, change[0])

def sync():
    import traceback
    local_conn = connect_db(LOCAL_DB_CONFIG)
    remote_conn = connect_db(REMOTE_DB_CONFIG)

    changes = fetch_pending_changes(local_conn)
    count = 0
    for change in changes:
        try:
            apply_change(remote_conn, change, local_conn)
            count += 1
        except Exception as e:
            print(f"‚ùå Misslyckades att applicera √§ndring p√• {change[1]} (id={change[2]}): {e}")
            traceback.print_exc()
    
    local_conn.close()
    remote_conn.close()

if __name__ == "__main__":
    sync()
END: sync_to_cloud.py

====================
üìÑ Fil: sync_static_tables.py
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üêç Python
üìÖ Senast √§ndrad: 2025-04-24 17:01:52
üìè Antal rader: 61
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ['import psycopg2', 'import json']
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 6
üß™ TODO/FIXME: 0
====================
START: sync_static_tables.py
from config import LOCAL_DB_CONFIG, REMOTE_DB_CONFIG
import psycopg2
import json
from datetime import datetime


TABLES = ["translation", "booking_settings"]


def connect_db(config):
    return psycopg2.connect(**config)


def fetch_all_from_local(conn, table):
    with conn.cursor() as cur:
        cur.execute(f"SELECT * FROM {table}")
        colnames = [desc[0] for desc in cur.description]
        rows = cur.fetchall()
        return colnames, rows


def clear_remote_table(conn, table):
    with conn.cursor() as cur:
        cur.execute(f"DELETE FROM {table}")
        conn.commit()


def insert_to_remote(conn, table, columns, rows):
    with conn.cursor() as cur:
        placeholders = ', '.join(['%s'] * len(columns))
        colnames = ', '.join(columns)
        for row in rows:
            # Hantera jsonb-v√§rden som json-str√§ngar
            formatted_row = []
            for i, col in enumerate(columns):
                value = row[i]
                if table == 'booking_settings' and col == 'value':
                    formatted_row.append(json.dumps(value))
                else:
                    formatted_row.append(value)
            cur.execute(f"INSERT INTO {table} ({colnames}) VALUES ({placeholders})", formatted_row)
        conn.commit()


def sync_static_tables():
    local_conn = connect_db(LOCAL_DB_CONFIG)
    remote_conn = connect_db(REMOTE_DB_CONFIG)

    for table in TABLES:
        print(f"\n‚è≥ Synkar tabell: {table}...")
        columns, rows = fetch_all_from_local(local_conn, table)
        clear_remote_table(remote_conn, table)
        insert_to_remote(remote_conn, table, columns, rows)
        print(f"‚úÖ Klar med tabell: {table} ({len(rows)} rader)")

    local_conn.close()
    remote_conn.close()


if __name__ == "__main__":
    sync_static_tables()

END: sync_static_tables.py

====================
üìÑ Fil: sync.py
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üêç Python
üìÖ Senast √§ndrad: 2025-05-14 15:43:17
üìè Antal rader: 82
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ['import psycopg2', 'import json']
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 10
üß™ TODO/FIXME: 0
====================
START: sync.py
import psycopg2
import json
from datetime import datetime
from config import LOCAL_DB_CONFIG

# Anslutning till lokal PostgreSQL
conn = psycopg2.connect(**LOCAL_DB_CONFIG)
cursor = conn.cursor()

# Rensa √§ldre UPDATE-rader (endast senaste beh√∂vs per record_id)
cursor.execute("""
    DELETE FROM pending_changes pc
    WHERE operation = 'UPDATE'
      AND processed = false
      AND direction = 'out'
      AND id NOT IN (
        SELECT id FROM (
          SELECT id,
                 ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at DESC) AS rn
          FROM pending_changes
          WHERE operation = 'UPDATE'
            AND processed = false
            AND direction = 'out'
        ) sub
        WHERE rn = 1
      );
""")

# H√§mta EN √§ndring per kontakt (record_id) ‚Äì endast senaste per kontakt exporteras med hj√§lp av ROW_NUMBER()
cursor.execute("""
    SELECT id, table_name, record_id, operation, payload, created_at
    FROM (
        SELECT *, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at DESC) as rn
        FROM pending_changes
        WHERE processed = false AND direction = 'out'
    ) sub
    WHERE rn = 1
""")

rows = cursor.fetchall()

# Filtrera bort poster d√§r metadata √§r identisk med befintlig kontakt
filtered_rows = []
for row in rows:
    change_id, table, record_id, operation, payload, created_at = row
    data = json.loads(payload) if isinstance(payload, str) else payload
    if table == "contact" and operation == "UPDATE":
        try:
            cursor.execute("SELECT metadata FROM contact WHERE id = %s", (record_id,))
            result = cursor.fetchone()
            if result:
                current_metadata = result[0] if isinstance(result[0], dict) else json.loads(result[0])
                incoming_metadata = data.get("metadata")
                if isinstance(incoming_metadata, str):
                    incoming_metadata = json.loads(incoming_metadata)
                if current_metadata == incoming_metadata:
                    continue
        except Exception as e:
            print(f"‚ö†Ô∏è Kunde inte j√§mf√∂ra metadata f√∂r {record_id}: {e}")
    filtered_rows.append(row)
rows = filtered_rows

# Skapa exportformat
export = []
for row in rows:
    change_id, table, record_id, operation, payload, created_at = row
    export.append({
        "change_id": str(change_id),
        "table": table,
        "operation": operation,
        "data": payload
    })

# Spara till JSON-fil med tidsst√§mpel
if export:
    first_type = export[0]["table"] if export else "unknown"
    filename = f"sync_outbox/{datetime.now().strftime('%Y%m%d_%H%M%S')}_{first_type}.json"
    with open(filename, "w", encoding="utf-8") as f:
        json.dump(export, f, indent=2, ensure_ascii=False)

cursor.close()
conn.close()

END: sync.py

====================
üìÑ Fil: sync_all.py
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üêç Python
üìÖ Senast √§ndrad: 2025-05-14 15:49:04
üìè Antal rader: 148
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 6 ‚Äì ['import os', 'import subprocess', 'import sys', 'import psycopg2', 'import socket', 'import traceback']
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 18
üß™ TODO/FIXME: 0
====================
START: sync_all.py
BASE = "/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot/macspot-api"

import os
import subprocess
from datetime import datetime
import sys
import psycopg2

log_dir = "/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot"
log_out = os.path.join(log_dir, "macspot_sync.log")
log_err = os.path.join(log_dir, "macspot_sync_error.log")

# Se till att loggfilerna existerar
for path in [log_out, log_err]:
    if not os.path.exists(path):
        with open(path, 'w'):
            pass

# Skriv ut manuell/automatisk k√∂rningsinfo till loggen
is_manual = sys.stdout.isatty()
sys.stdout = open(log_out, 'a')
sys.stderr = open(log_err, 'a')
if is_manual:
    print(f"üñêÔ∏è Manuell k√∂rning: {datetime.now().isoformat()}")
else:
    print(f"ü§ñ Automatisk k√∂rning via launchd: {datetime.now().isoformat()}")

def run_script(name, script_path):
    subprocess.run(["python", f"{BASE}/{script_path}"], check=True)

try:
    start_time = datetime.now()
    def is_database_online(host, port):
        import socket
        try:
            socket.create_connection((host, port), timeout=2)
            return True
        except:
            return False

    # Kontrollera att b√•da databaser √§r online innan sync startar
    if not is_database_online("localhost", 5433):
        print("‚ùå Lokal databas √§r inte tillg√§nglig (localhost:5433)")
        exit(1)

    if not is_database_online("macspotpg.postgres.database.azure.com", 5432):
        print("‚ùå Azure-databasen √§r inte tillg√§nglig (macspotpg.postgres.database.azure.com:5432)")
        exit(1)

    print(f"üìå K√∂rning initierad: {datetime.now().isoformat()}")

    print(f"\nüîÑ [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Startar fullst√§ndig synk...")

    scripts_part1 = [
        ("üü° K√∂r sync.py...", "sync.py"),
        ("üü¢ K√∂r sync_to_cloud.py...", "sync_to_cloud.py")
    ]

    for msg, script in scripts_part1:
        run_script(msg, script)

    scripts_part2 = [
        ("üîµ K√∂r sync_from_cloud.py...", "sync_from_cloud.py")
    ]

    for msg, script in scripts_part2:
        run_script(msg, script)

    today_prefix = datetime.now().strftime('%Y%m%d')
    outbox_dir = os.path.join(BASE, 'sync_outbox')
    files = [f for f in os.listdir(outbox_dir) if f.startswith(today_prefix)]
    files_with_type = [f for f in files if len(f.split("_")) >= 3]
    num_changes = len(files_with_type)

    if num_changes == 0:
        print("‚ÑπÔ∏è Ingen f√∂r√§ndring hittades att synka.")
        print("üì≠ Inga fler √§ndringar kvar i pending_changes.")
    else:
        print(f"üì§ Totalt {num_changes} √§ndring(ar) skickades till molnet:")
        files = [f for f in sorted(os.listdir(outbox_dir)) if f.startswith(today_prefix)]
        summary = {}
        for f in files:
            parts = f.split("_")
            if len(parts) >= 3:
                typ = parts[2].split(".")[0]
                summary[typ] = summary.get(typ, 0) + 1

        if summary:
            print("üßæ Sammanfattning per typ:")
            for typ, count in summary.items():
                print(f"   ‚Ä¢ {typ}: {count} st")

        print("üìä Kontroll av √•terst√•ende √§ndringar i pending_changes...")

        # Lokalt
        local = psycopg2.connect(
            dbname="macspot",
            user="postgres",
            host="localhost",
            port=5433
        )
        cur_local = local.cursor()
        cur_local.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
        """)
        out_local = cur_local.fetchone()[0]
        cur_local.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
            GROUP BY record_id
        """)
        print(f"   ‚Ä¢ Lokalt ‚Üí molnet: {out_local} √§ndring(ar) kvar √∂ver {cur_local.rowcount} kontakt(er).")
        cur_local.close()
        local.close()

        # Molnet
        cloud = psycopg2.connect(
            dbname="postgres",
            user="daniel",
            host="macspotpg.postgres.database.azure.com",
            port=5432
        )
        cur_cloud = cloud.cursor()
        cur_cloud.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
        """)
        out_cloud = cur_cloud.fetchone()[0]
        cur_cloud.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
            GROUP BY record_id
        """)
        cur_cloud.close()
        cloud.close()

    print(f"\n‚úÖ [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Fullst√§ndig synk k√∂rd.")

except Exception as e:
    import traceback
    print("‚ùå Ett ov√§ntat fel intr√§ffade under k√∂rningen:")
    print(traceback.format_exc())

finally:
    print(f"üèÅ K√∂rning avslutad: {datetime.now().isoformat()}")
    duration = datetime.now() - start_time
    print(f"‚è±Ô∏è Total k√∂rtid: {int(duration.total_seconds())} sekunder")
END: sync_all.py

====================
üìÑ Fil: macspot.sync.plist
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üìÑ Ok√§nt format
üìÖ Senast √§ndrad: 2025-05-28 22:59:14
üìè Antal rader: 39
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 0
üß™ TODO/FIXME: 0
====================
START: macspot.sync.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" 
  "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>com.macspot.sync</string>

  <key>ProgramArguments</key>
  <array>
    <string>/Users/danielkallberg/Documents/KLR_AI/venv/bin/python</string>
    <string>/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot/macspot-api/sync_all.py</string>
  </array>

  <key>StartCalendarInterval</key>
  <array>
    <dict><key>Minute</key><integer>0</integer></dict>
    <dict><key>Minute</key><integer>5</integer></dict>
    <dict><key>Minute</key><integer>10</integer></dict>
    <dict><key>Minute</key><integer>15</integer></dict>
    <dict><key>Minute</key><integer>20</integer></dict>
    <dict><key>Minute</key><integer>25</integer></dict>
    <dict><key>Minute</key><integer>30</integer></dict>
    <dict><key>Minute</key><integer>35</integer></dict>
    <dict><key>Minute</key><integer>40</integer></dict>
    <dict><key>Minute</key><integer>45</integer></dict>
    <dict><key>Minute</key><integer>50</integer></dict>
    <dict><key>Minute</key><integer>55</integer></dict>
  </array>

  <key>RunAtLoad</key>
  <true/>

  <key>StandardOutPath</key>
  <string>/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot/macspot_sync.log</string>
  <key>StandardErrorPath</key>
  <string>/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot/macspot_sync_error.log</string>
</dict>
</plist>
END: macspot.sync.plist

üìÅ KONFIGURATIONSFILER (function.json / host.json / package.json / .funcignore)
====================================

üìÑ .funcignore
   # Exclude dev-only files and folders
   .git
   .vscode
   .env
   *.log
   test/
   tests/
   
   # Explicitly include all required files and folders
   !host.json
   !package.json
   !package-lock.json
   
   !node_modules/
   !node_modules/**
   
   !shared/
   !shared/**
   
   !bookings/
   !bookings/**
   !getavailableslots/
   !getavailableslots/**
   !validate_contact/
   !validate_contact/**
   !meeting_types/
   !meeting_types/**
   !refreshCalendarOrigins/
   !refreshCalendarOrigins/**
   !refreshTravelTimes/
   !refreshTravelTimes/**
   !booking_settings/
   !booking_settings/**
   !test_azurecloud/
   !test_azurecloud/**
üìÑ booking_settings/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get"],
         "route": "booking_settings"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ bookings/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "bookings"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ getavailableslots/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "getavailableslots"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ host.json
   {
     "version": "2.0",
     "extensionBundle": {
       "id": "Microsoft.Azure.Functions.ExtensionBundle",
       "version": "[4.*, 5.0.0)"
     },
     "extensions": {
       "http": {
         "cors": {
           "allowedOrigins": [
             "https://www.klrab.se"
           ],
           "supportCredentials": false
         }
       }
     }
   }
üìÑ meeting_types/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": [ "get" ],
         "route": "meeting_types"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ package.json
   {
     "name": "macspot-api",
     "version": "1.0.0",
     "description": "Azure Functions backend f√∂r MacSpot CRM/ERP",
     "scripts": {
       "start": "func start",
       "dev": "func start --verbose",
       "deploy": "func azure functionapp publish macspotbackend",
       "build": "echo 'Nothing to build'"
     },
     "dependencies": {
       "@azure/functions": "^4.7.0",
       "@azure/msal-node": "^3.5.1",
       "@microsoft/microsoft-graph-client": "^3.0.0",
       "dav": "^1.8.0",
       "dotenv": "^16.5.0",
       "isomorphic-fetch": "^3.0.0",
       "jsonwebtoken": "^9.0.0",
       "luxon": "^3.4.4",
       "node-fetch": "^2.7.0",
       "node-ical": "^0.20.1",
       "p-limit": "^6.2.0",
       "pg": "^8.15.6",
       "uuid": "^9.0.0",
       "xml2js": "^0.6.2"
     }
   }

üìÑ refreshCalendarOrigins/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ refreshTravelTimes/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ test_azurecloud/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get"],
         "route": "test_azurecloud"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ validate_contact/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get", "post"],
         "route": "validate_contact"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìà SUMMERING AV ALLA JS-FILER
====================================
üìè Totalt antal rader kod: 682
üß© Totalt antal funktioner: 0
üß† Total komplexitetspo√§ng: 103
üß™ Antal TODO/FIXME totalt: 0

üìä Per fil:
fil,rader,funktioner,komplexitet,kommentarer,imports
sync_from_cloud.py,141,0,28,0,2
sync_to_cloud.py,211,0,41,0,3
sync_static_tables.py,61,0,6,0,2
sync.py,82,0,10,0,2
sync_all.py,148,0,18,0,6
macspot.sync.plist,39,0,0,0,0
üìä MOLNDATABAS (Azure) ‚Äì STRUKTUR & INNEH√ÖLL
====================================

üìÅ Tabell: available_slots_cache
  ‚Ä¢ id (uuid)
  ‚Ä¢ travel_time_min (integer)
  ‚Ä¢ generated_at (timestamp without time zone)
  ‚Ä¢ expires_at (timestamp without time zone)
  ‚Ä¢ meeting_length (integer)
  ‚Ä¢ slot_day (date)
  ‚Ä¢ slot_score (integer)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ slot_part (text)
  ‚Ä¢ slot_iso (text)
  üîë [p] available_slots_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: slot_cache
  ‚Ä¢ created_at (timestamp without time zone)
  ‚Ä¢ slot_day (date)
  ‚Ä¢ slots (jsonb)
  ‚Ä¢ id (uuid)
  ‚Ä¢ meeting_length (integer)
  ‚Ä¢ booking_email (text)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ slot_part (text)
  üîë [p] slot_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: calendar_origin_cache
  ‚Ä¢ created_at (timestamp without time zone)
  ‚Ä¢ timestamp (timestamp with time zone)
  ‚Ä¢ event_date (date)
  ‚Ä¢ id (integer)
  ‚Ä¢ end_time (timestamp without time zone)
  ‚Ä¢ address (text)
  ‚Ä¢ source (text)
  üîë [c] calendar_origin_cache_source_check: CHECK ((source = ANY (ARRAY['Apple Calendar'::text, 'Microsoft 365'::text])))
  üîë [p] calendar_origin_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: travel_time_cache
  ‚Ä¢ travel_minutes (integer)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ is_fallback (boolean)
  ‚Ä¢ hour (integer)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ to_address (text)
  ‚Ä¢ from_address (text)
  üîë [u] unique_travel_key: UNIQUE (from_address, to_address, hour)
  üß™ Topp 5 rader:
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=10, travel_minutes=21, created_at=2025-05-26 12:00:01.232984+00:00, updated_at=2025-05-26 12:00:01.232984+00:00, is_fallback=False
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=14, travel_minutes=21, created_at=2025-05-26 12:00:01.878755+00:00, updated_at=2025-05-26 12:00:01.878755+00:00, is_fallback=False

üìÅ Tabell: event_log
  ‚Ä¢ received_at (timestamp with time zone)
  ‚Ä¢ record_id (uuid)
  ‚Ä¢ timestamp (timestamp with time zone)
  ‚Ä¢ booking_id (uuid)
  ‚Ä¢ id (uuid)
  ‚Ä¢ payload (jsonb)
  ‚Ä¢ action (text)
  ‚Ä¢ event_type (text)
  ‚Ä¢ source (text)
  ‚Ä¢ table_name (text)
  üîë [p] event_log_pkey: PRIMARY KEY (id)
  üß™ Topp 5 rader:
    - source=None, event_type=None, payload=None, received_at=2025-05-26 11:30:25.115769+00:00, id=2ac4e176-edc2-4b4a-bebf-2e9d53c0b6db, action=INSERT, table_name=contact, record_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, timestamp=2025-05-26 11:30:25.115769+00:00, booking_id=None
    - source=None, event_type=booking_created, payload=None, received_at=2025-05-26 11:30:35.906268+00:00, id=e5120865-2baa-405b-970e-2c356ae1a877, action=None, table_name=None, record_id=None, timestamp=2025-05-26 11:30:35.906268+00:00, booking_id=2b69c259-7579-4310-9b48-88b565cdd7d0
    - source=None, event_type=booking_created, payload=None, received_at=2025-05-26 11:30:58.035990+00:00, id=e685e28c-0cbb-45fd-a2f9-213bd0847116, action=None, table_name=None, record_id=None, timestamp=2025-05-26 11:30:58.035990+00:00, booking_id=be391645-d37a-4f6d-a1d8-48dd08c4f382
    - source=None, event_type=booking_created, payload=None, received_at=2025-05-26 11:31:22.504101+00:00, id=9db1d894-7f83-48fc-a7d4-29d66dd5c8af, action=None, table_name=None, record_id=None, timestamp=2025-05-26 11:31:22.504101+00:00, booking_id=0b34a27f-fa2a-4185-95b1-60e64e5d12cd
    - source=None, event_type=None, payload=None, received_at=2025-05-26 11:31:55.898756+00:00, id=6597f521-fed0-447b-b303-eaeb38c7ddf0, action=UPDATE, table_name=contact, record_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, timestamp=2025-05-26 11:31:55.898756+00:00, booking_id=None

üìÅ Tabell: booking_settings
  ‚Ä¢ value (jsonb)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ key (text)
  ‚Ä¢ value_type (text)
  üîë [u] unique_key: UNIQUE (key)
  üß™ Topp 5 rader:
    - key=max_days_in_advance, value=30, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=required_fields, value={'base': ['first_name', 'last_name', 'phone', 'company'], 'zoom': [], 'teams': [], 'atclient': ['address', 'postal_code', 'city', 'country'], 'atoffice': [], 'facetime': []}, value_type=json, updated_at=2025-05-23 15:10:13.460480+00:00
    - key=default_meeting_subject, value=M√∂te med KLRA Ledningsr√•dgivning, value_type=string, updated_at=2025-05-25 10:37:53.619684+00:00
    - key=email_invite_template, value={'body': 'Hej {{first_name}},\n\nH√§r kommer en inbjudan till v√•rt m√∂te.\n\nMed v√§nliga h√§lsningar,\nKLRA', 'subject': 'M√∂te med {{company}}'}, value_type=json, updated_at=2025-05-25 10:37:53.619684+00:00
    - key=analytics_enabled, value=True, value_type=bool, updated_at=2025-05-25 10:37:53.619684+00:00

üìÅ Tabell: translation
  ‚Ä¢ key (character varying)
  ‚Ä¢ sv (text)
  ‚Ä¢ en (text)
  üß™ Topp 5 rader:
    - key=error_min_duration_fysiskt_kund, sv=M√∂testiden f√∂r 'Fysiskt hos kund' m√•ste vara minst {{minutes}} minuter. Du visste det redan., en=The meeting time for 'On-site at customer' must be at least {{minutes}} minutes. You knew that.
    - key=error_min_duration_fysiskt_mig, sv=M√∂testiden f√∂r 'Fysiskt hos mig' m√•ste vara minst {{minutes}} minuter. Annars hinner vi bara s√§ga hej., en=The meeting time for 'At my office' must be at least {{minutes}} minutes. Otherwise, we‚Äôll only have time to say hello.
    - key=email_body_booking_received, sv=Hej {{name}}! Vi har tagit emot din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}}. Ingen panik ‚Äì vi √•terkommer med bekr√§ftelse. / Daniel, en=Hello {{name}}, We‚Äôve received your booking for {{meeting_type}} between {{start_time}} and {{end_time}}. No need to panic ‚Äì we‚Äôll confirm shortly. / Daniel
    - key=email_body_booking_confirmed, sv=Hej {{name}}! Din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}} √§r nu spikad. Ser fram emot det! / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} is now locked in. Looking forward! / Daniel
    - key=email_body_booking_cancelled, sv=Hej {{name}}! Din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}} √§r avbokad. H√∂r av dig om du vill hitta en ny tid. / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} has been cancelled. Let me know if you'd like a new one. / Daniel

üìÅ Tabell: bookings
  ‚Ä¢ start_time (timestamp with time zone)
  ‚Ä¢ end_time (timestamp with time zone)
  ‚Ä¢ id (uuid)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ metadata (jsonb)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ contact_id (uuid)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ booking_email (text)
  üîë [p] bookings_pkey: PRIMARY KEY (id)
  üîë [f] fk_bookings_contact: FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE SET NULL
  üß™ Topp 5 rader:
    - start_time=2025-05-27 08:00:00+00:00, end_time=2025-05-27 08:10:00+00:00, meeting_type=zoom, metadata={'subject': 'M√∂te med KLRA Ledningsr√•dgivning', 'location': 'Online', 'meeting_id': 88409084527, 'online_link': 'https://us05web.zoom.us/j/88409084527?pwd=omCro2i8pgZlBZ8VJVSbgLtgucptOa.1', 'meeting_length': 10}, created_at=2025-05-26 11:30:34.562000+00:00, contact_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, id=2b69c259-7579-4310-9b48-88b565cdd7d0, updated_at=2025-05-26 11:30:34.562000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-05-28 08:00:00+00:00, end_time=2025-05-28 08:10:00+00:00, meeting_type=facetime, metadata={'meeting_length': 10}, created_at=2025-05-26 11:30:57.976000+00:00, contact_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, id=be391645-d37a-4f6d-a1d8-48dd08c4f382, updated_at=2025-05-26 11:30:57.976000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-05-29 08:00:00+00:00, end_time=2025-05-29 09:00:00+00:00, meeting_type=teams, metadata={'subject': 'M√∂te med KLRA Ledningsr√•dgivning', 'location': 'Online', 'online_link': 'https://teams.microsoft.com/l/meetup-join/19%3ameeting_MjY3NmVjNDgtODI2OS00NzUzLWI2MDctNTJkOTI2ZjU0NTY4%40thread.v2/0?context=%7b%22Tid%22%3a%226f2f8e0c-22fc-4d93-bf68-72a916e2f35f%22%2c%22Oid%22%3a%2285224b32-2747-4b0c-bc0f-3bb4e7192aa9%22%7d', 'meeting_length': 60}, created_at=2025-05-26 11:31:20.270000+00:00, contact_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, id=0b34a27f-fa2a-4185-95b1-60e64e5d12cd, updated_at=2025-05-26 11:31:20.270000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-05-30 08:00:00+00:00, end_time=2025-05-30 09:30:00+00:00, meeting_type=atclient, metadata={'subject': 'M√∂te med KLRA Ledningsr√•dgivning', 'location': 'Taxgatan 4, 115 45 Stockholm', 'meeting_length': 90}, created_at=2025-05-26 11:32:02.414000+00:00, contact_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, id=6ca102d7-1881-497a-a49c-c22b92bd42f7, updated_at=2025-05-26 11:32:02.414000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-06-03 08:00:00+00:00, end_time=2025-06-03 09:30:00+00:00, meeting_type=atoffice, metadata={'subject': 'M√∂te med KLRA Ledningsr√•dgivning', 'location': 'Maria Skolgata 79A, 118 53 Stockholm', 'meeting_length': 90}, created_at=2025-05-26 11:32:29.252000+00:00, contact_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, id=11e8d22a-1f83-4a4a-87c6-ca5beefce8aa, updated_at=2025-05-26 11:32:29.252000+00:00, booking_email=daniel.kallberg@mac.com

üìÅ Tabell: pending_changes
  ‚Ä¢ booking_id (uuid)
  ‚Ä¢ processed (boolean)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ payload (jsonb)
  ‚Ä¢ id (uuid)
  ‚Ä¢ record_id (uuid)
  ‚Ä¢ table_name (text)
  ‚Ä¢ operation (text)
  ‚Ä¢ change_type (text)
  ‚Ä¢ direction (text)
  üîë [p] pending_changes_pkey: PRIMARY KEY (id)
  üîë [f] fk_pending_changes_booking_id: FOREIGN KEY (booking_id) REFERENCES bookings(id) ON DELETE CASCADE
  üß™ Topp 5 rader:
    - id=3cf0bacb-d197-4879-a572-f20e54c43f2e, table_name=contact, record_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, change_type=INSERT, direction=out, processed=False, created_at=2025-05-26 11:30:25.115769+00:00, operation=INSERT, payload={'id': 'a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1', 'email': 'daniel.kallberg@mac.com', 'metadata': {'phone': '0709561480', 'company': 'Test AB', 'last_name': 'K√§llberg', 'first_name': 'Daniel'}, 'created_at': '2025-05-26T11:30:25.115769+00:00', 'updated_at': '2025-05-26T11:30:25.115769+00:00', 'booking_email': 'daniel.kallberg@mac.com'}, booking_id=None
    - id=a96553de-1ec2-46a3-ac30-d478a8532e94, table_name=bookings, record_id=2b69c259-7579-4310-9b48-88b565cdd7d0, change_type=INSERT, direction=out, processed=False, created_at=2025-05-26 11:30:35.854490+00:00, operation=INSERT, payload={'id': '2b69c259-7579-4310-9b48-88b565cdd7d0', 'end_time': '2025-05-27T08:10:00+00:00', 'metadata': {'subject': 'M√∂te med KLRA Ledningsr√•dgivning', 'location': 'Online', 'meeting_id': 88409084527, 'online_link': 'https://us05web.zoom.us/j/88409084527?pwd=omCro2i8pgZlBZ8VJVSbgLtgucptOa.1', 'meeting_length': 10}, 'contact_id': 'a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1', 'created_at': '2025-05-26T11:30:34.562+00:00', 'start_time': '2025-05-27T08:00:00+00:00', 'updated_at': '2025-05-26T11:30:34.562+00:00', 'meeting_type': 'zoom', 'booking_email': 'daniel.kallberg@mac.com'}, booking_id=2b69c259-7579-4310-9b48-88b565cdd7d0
    - id=898a2d09-d2ce-45b4-9ef7-e15297257725, table_name=bookings, record_id=2b69c259-7579-4310-9b48-88b565cdd7d0, change_type=INSERT, direction=cloud_to_local, processed=False, created_at=2025-05-26 11:30:35.881000+00:00, operation=None, payload=None, booking_id=2b69c259-7579-4310-9b48-88b565cdd7d0
    - id=6659c7c8-0d48-4eba-a6db-79243e66de8d, table_name=bookings, record_id=be391645-d37a-4f6d-a1d8-48dd08c4f382, change_type=INSERT, direction=out, processed=False, created_at=2025-05-26 11:30:57.977055+00:00, operation=INSERT, payload={'id': 'be391645-d37a-4f6d-a1d8-48dd08c4f382', 'end_time': '2025-05-28T08:10:00+00:00', 'metadata': {'meeting_length': 10}, 'contact_id': 'a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1', 'created_at': '2025-05-26T11:30:57.976+00:00', 'start_time': '2025-05-28T08:00:00+00:00', 'updated_at': '2025-05-26T11:30:57.976+00:00', 'meeting_type': 'facetime', 'booking_email': 'daniel.kallberg@mac.com'}, booking_id=be391645-d37a-4f6d-a1d8-48dd08c4f382
    - id=45a92537-32e6-4428-b599-bdcefe5007d8, table_name=bookings, record_id=be391645-d37a-4f6d-a1d8-48dd08c4f382, change_type=INSERT, direction=cloud_to_local, processed=False, created_at=2025-05-26 11:30:58.006000+00:00, operation=None, payload=None, booking_id=be391645-d37a-4f6d-a1d8-48dd08c4f382

üìÅ Tabell: contact
  ‚Ä¢ metadata (jsonb)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ id (uuid)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ booking_email (text)
  ‚Ä¢ email (text)
  üîë [p] contact_pkey: PRIMARY KEY (id)
  üß™ Topp 5 rader:
    - metadata={'city': 'STOCKHOLM', 'phone': '0709561480', 'address': 'Kungsgatan 4', 'company': 'Test AB', 'country': 'SVERGIE', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'postal_code': '112 45'}, created_at=2025-05-26 11:30:25.115769+00:00, id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, booking_email=daniel.kallberg@mac.com, updated_at=2025-05-26 11:31:55.898756+00:00, email=daniel.kallberg@mac.com

