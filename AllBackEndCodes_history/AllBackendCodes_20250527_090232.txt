üìÇ KODTR√ÑD
==========
‚îú‚îÄ‚îÄ bookings
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ getavailableslots
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ meeting_types
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ refreshCalendarOrigins
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ refreshTravelTimes
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ calendar
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ appleCalendar.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ getMsToken.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ msGraph.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resolveOrigin.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ zoomClient.js
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ settingsLoader.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ verifySettings.js
‚îÇ   ‚îú‚îÄ‚îÄ db
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pgPool.js
‚îÇ   ‚îú‚îÄ‚îÄ maps
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ appleMaps.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resolveTravelTime.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ returnTravelVerifier.js
‚îÇ   ‚îú‚îÄ‚îÄ notification
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sendMail.js
‚îÇ   ‚îú‚îÄ‚îÄ slots
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ slotEngine.js
‚îÇ   ‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ debugLogger.js
‚îú‚îÄ‚îÄ sync.py
‚îú‚îÄ‚îÄ sync_all.py
‚îú‚îÄ‚îÄ sync_from_cloud.py
‚îú‚îÄ‚îÄ sync_static_tables.py
‚îú‚îÄ‚îÄ sync_to_cloud.py
‚îú‚îÄ‚îÄ validate_contact
‚îÇ   ‚îú‚îÄ‚îÄ index.js
==========

====================
üìÑ Fil: meeting_types/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-22 19:37:45
üìè Antal rader: 47
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 1 rader (2.1%)
üì• Imports: 2 ‚Äì ["const pool = require('../shared/db/pgPool');", "const { getSettings } = require('../shared/config/settingsLoader');"]
üîç L√§ngsta funktion: 7 rader
üß† Komplexitetspo√§ng: 3
üß™ TODO/FIXME: 0
====================
START: index.js
const pool = require('../shared/db/pgPool');
const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, req) {
  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.log.error(`Missing environment variable: ${key}`);
      context.res = {
        status: 500,
        body: { error: `Missing environment variable: ${key}` }
      };
      return;
    }
  }

  try {
    const settings = await getSettings(context);

    const rawTypes = settings['meeting_types'];
    const meetingTypes = Array.isArray(rawTypes) ? rawTypes.map(t => t.toLowerCase()) : [];
    const lengths = {
      zoom: settings['default_meeting_length_digital'],
      facetime: settings['default_meeting_length_digital'],
      teams: settings['default_meeting_length_digital'],
      atclient: settings['default_meeting_length_atclient'],
      atoffice: settings['default_meeting_length_atoffice']
    };

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        types: meetingTypes,
        lengths
      })
    };
  } catch (error) {
    context.log.error('Database query failed:', error);
    context.res = {
      status: 500,
      body: { error: error.message }
    };
  } finally {
    // pool.end() tas bort ‚Äì vi √•teranv√§nder en delad pool mellan anrop
  }
};
END: index.js

====================
üìÑ Fil: validate_contact/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-24 18:36:04
üìè Antal rader: 182
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 5 rader (2.7%)
üì• Imports: 3 ‚Äì ["const { getSettings } = require('../shared/config/settingsLoader');", "const pool = require('../shared/db/pgPool');", "const { v4: uuidv4 } = require('uuid');"]
üîç L√§ngsta funktion: 1 rader
üß† Komplexitetspo√§ng: 28
üß™ TODO/FIXME: 0
====================
START: index.js
const { getSettings } = require('../shared/config/settingsLoader');
const pool = require('../shared/db/pgPool');
const { v4: uuidv4 } = require('uuid');

module.exports = async function (context, req) {
  try {
    const email = req.body?.email || req.query?.email;
    const meeting_type = req.body?.meeting_type || req.query?.meeting_type;

    if (process.env.DEBUG === 'true') {
      context.log.info('üõ† DEBUG MODE ENABLED');
    }

    if (process.env.DEBUG === 'true') {
      context.log.info('üì• validate_contact triggered with:', { email, meeting_type });
    }

    if (!email || !meeting_type) {
      context.res = { status: 400, body: { error: "email and meeting_type are required" } };
      return;
    }

    const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
    for (const key of requiredEnv) {
      if (!process.env[key]) throw new Error(`Missing environment variable: ${key}`);
    }

    const contactRes = await pool.query('SELECT * FROM contact WHERE booking_email = $1', [email]);
    const contact = contactRes.rows[0];

    if ((req.body?.write_if_valid || req.query?.write_if_valid) && contact) {
      // Update existing contact if needed, merging metadata
      let metadataFromClient = req.body?.metadata;
      if (typeof metadataFromClient === 'string') {
        try {
          metadataFromClient = JSON.parse(metadataFromClient);
        } catch {
          metadataFromClient = {};
        }
      }
      if (typeof metadataFromClient === 'object' && metadataFromClient !== null) {
        // Fetch existing metadata
        const existing = await pool.query('SELECT metadata FROM contact WHERE booking_email = $1', [email]);
        const old = existing.rows[0]?.metadata || {};
        const merged = { ...old, ...metadataFromClient };
        await pool.query(
          `UPDATE contact SET metadata = $1, updated_at = NOW() WHERE booking_email = $2`,
          [merged, email]
        );
        context.log.info('‚úèÔ∏è Befintlig kontakt uppdaterad via validate_contact');
      }
    }

    if ((req.body?.write_if_valid || req.query?.write_if_valid) && !contact) {
      let metadataFromClient = req.body?.metadata;
      if (typeof metadataFromClient === 'string') {
        try {
          metadataFromClient = JSON.parse(metadataFromClient);
        } catch {
          metadataFromClient = {};
        }
      }
      if (typeof metadataFromClient === 'object' && metadataFromClient !== null) {
        const newId = uuidv4();
        await pool.query(
          `INSERT INTO contact (id, email, booking_email, metadata, created_at) VALUES ($1, $2, $2, $3, NOW())`,
          [newId, email, metadataFromClient]
        );
        context.log.info('‚úÖ Ny kontakt skapad via validate_contact');

        if (process.env.DEBUG === 'true') {
          context.log.info('üì§ Svarar med status: created');
        }

        context.res = {
          status: 200,
          body: {
            status: "created",
            contact_id: newId
          }
        };
        return;
      }
    }

    let metadata = {};
    if (contact) {
      const refreshed = await pool.query('SELECT metadata FROM contact WHERE booking_email = $1', [email]);
      metadata = refreshed.rows[0]?.metadata || {};
    }

    if (typeof metadata === 'string') {
      try {
        metadata = JSON.parse(metadata);
      } catch {
        metadata = {};
      }
    }

    if (typeof metadata !== 'object' || metadata === null) metadata = {};

    if (process.env.DEBUG === 'true') {
      context.log.info('üßæ Metadata:', metadata);
    }

    const METADATA_KEYS = ['first_name', 'last_name', 'phone', 'company', 'address', 'postal_code', 'city', 'country'];
    const fullMetadata = Object.fromEntries(
      METADATA_KEYS.map(key => [key, metadata[key] ?? ''])
    );
    metadata = fullMetadata;

    const settings = await getSettings(context);
    const digitalTypes = Array.isArray(settings.meeting_digital) ? settings.meeting_digital : [];
    const isDigital = digitalTypes.map(t => t.toLowerCase()).includes(meeting_type.toLowerCase()) || meeting_type === 'atoffice';

    // Dynamically get required fields from booking_settings
    const allRequired = settings.required_fields || {};
    const requiredFields = Array.isArray(allRequired[meeting_type]) ? allRequired[meeting_type] : [];
    // Ber√§kna alltid missingFields fr√•n metadata som just l√§sts fr√•n databasen
    const missingFields = requiredFields.filter(
      field => !metadata[field] || typeof metadata[field] !== 'string' || metadata[field].trim() === ''
    );

    if (process.env.DEBUG === 'true') {
      context.log.info('üìå Saknade f√§lt:', missingFields);
    }

    if (!contact) {
      if (process.env.DEBUG === 'true') {
        context.log.info('üì§ Svarar med status: new_customer');
      }
      context.res = {
        status: 200,
        body: {
          status: "new_customer",
          missing_fields: missingFields
        }
      };
    } else if (missingFields.length > 0) {
      if (process.env.DEBUG === 'true') {
        context.log.info('üì§ Svarar med status: incomplete');
      }
      context.res = {
        status: 200,
        body: {
          status: "incomplete",
          contact_id: contact.id,
          booking_email: contact.booking_email,
          missing_fields: missingFields,
          metadata
        }
      };
    } else {
      if (process.env.DEBUG === 'true') {
        context.log.info('üì§ Svarar med status: existing_customer');
      }
      context.res = {
        status: 200,
        body: {
          status: "existing_customer",
          contact_id: contact.id,
          booking_email: contact.booking_email,
          metadata
        }
      };
    }

  } catch (error) {
    if (process.env.DEBUG === 'true') {
      context.log.error('‚ùå Error during validate_contact:', {
        message: error.message,
        stack: error.stack
      });
    }
    context.res = {
      status: 500,
      body: { error: error.message, stack: error.stack }
    };
  } finally {
    // Poolen √§r delad och √•teranv√§nds ‚Äì vi st√§nger den inte h√§r
  }
};
END: index.js

====================
üìÑ Fil: getavailableslots/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-26 22:13:30
üìè Antal rader: 191
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 2 rader (1.0%)
üì• Imports: 9 ‚Äì ['const db = require("../shared/db/pgPool");', "const createMsGraphClient = require('../shared/calendar/msGraph');", "const createAppleClient = require('../shared/calendar/appleCalendar');", "const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');", "const { createDebugLogger } = require('../shared/utils/debugLogger');", "require('../shared/config/verifySettings');", "const { getSettings } = require('../shared/config/settingsLoader');", "const verifyBookingSettings = require('../shared/config/verifySettings');", "generateSlotChunks = require('../shared/slots/slotEngine').generateSlotChunks;"]
üîç L√§ngsta funktion: 19 rader
üß† Komplexitetspo√§ng: 13
üß™ TODO/FIXME: 0
====================
START: index.js
const db = require("../shared/db/pgPool");
const createMsGraphClient = require('../shared/calendar/msGraph');
const createAppleClient = require('../shared/calendar/appleCalendar');
const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');
const { createDebugLogger } = require('../shared/utils/debugLogger');
console.log("‚úÖ getavailableslots/index.js laddad");
require('../shared/config/verifySettings');

module.exports = async function (context, req) {
  const appleClient = createAppleClient(context);
  const graphClient = createMsGraphClient();
  context.log("üß™ Azure Function entrypoint n√•dd");
  context.log("üß™ graphClient.getEvent:", typeof graphClient.getEvent === "function");
  context.log("üß™ appleClient.getEvent:", typeof appleClient.getEvent === "function");

  try {
    const client = await db.connect();

    if (!req || !req.body) {
      context.log("‚ùå Ingen request body mottagen");
      context.res = { status: 400, body: { error: "Missing request body" } };
      return;
    }

    const { email, meeting_type, meeting_length, contact_id } = req.body;
    context.log("‚úÖ Request body inneh√•ller:", { email, meeting_type });
    context.log("‚úÖ Steg 1: Anropar DB med contact_id:", contact_id);

    // Declare allBookings, days, and contact at the top-level scope of the outer try block
    let allBookings = [];
    let days = [];
    let contact;
    let bookingsByDay = {};

    try {
      const contactRes = await client.query("SELECT * FROM contact WHERE id = $1", [contact_id]);
      contact = contactRes.rows[0];
      if (contact) {
        context.log("‚úÖ Kontakt hittad:", contact.id);
      } else {
        context.log("‚ö†Ô∏è Ingen kontakt hittad f√∂r contact_id:", contact_id);
      }
    } catch (err) {
      context.log("üî• DB-fel:", err.message);
      context.res = { status: 500, body: { error: "DB error", detail: err.message } };
      client.release();
      return;
    }

    context.log("‚úÖ Steg 2: Laddar booking_settings...");

    const { getSettings } = require('../shared/config/settingsLoader');
    const verifyBookingSettings = require('../shared/config/verifySettings');

    let settings;
    try {
      settings = await getSettings(context);
      context.log("‚úÖ Steg 2a: Inst√§llningar laddade ‚Äì nycklar:", Object.keys(settings).join(', '));
      verifyBookingSettings(settings, context);
      context.log("‚úÖ Steg 2b: Inst√§llningar verifierade");

      context.log("‚úÖ Steg 3: Genererar days[] och laddar bokningar");

      const maxDays = settings.max_days_in_advance || 14;
      const today = new Date();
      days = Array.from({ length: maxDays }, (_, i) => {
        const date = new Date(today);
        date.setDate(today.getDate() + i);
        return date;
      });

      const startDateStr = days[0].toISOString().split('T')[0];
      const endDateStr = days[days.length - 1].toISOString().split('T')[0];

      const allBookingsRes = await client.query(
        'SELECT start_time, end_time, meeting_type FROM bookings WHERE start_time::date >= $1 AND start_time::date <= $2',
        [startDateStr, endDateStr]
      );
      context.log("üî¢ Antal bokningar h√§mtade:", allBookingsRes.rows.length);

      allBookings = allBookingsRes.rows.map(b => ({
        start: new Date(b.start_time).getTime(),
        end: new Date(b.end_time).getTime(),
        date: new Date(b.start_time).toISOString().split('T')[0],
        meeting_type: b.meeting_type
      }));

      for (const booking of allBookings) {
        if (!bookingsByDay[booking.date]) bookingsByDay[booking.date] = [];
        bookingsByDay[booking.date].push({ start: booking.start, end: booking.end });
      }

      context.log("‚úÖ Steg 3: Dagar genererade och bokningar summerade");

    } catch (err) {
      context.log("üî• Fel vid laddning/verifiering av settings:", err.message);
      context.res = { status: 500, body: { error: "Settings error", detail: err.message } };
      client.release();
      return;
    }

    let generateSlotChunks;
    try {
      generateSlotChunks = require('../shared/slots/slotEngine').generateSlotChunks;
      context.log("‚úÖ generateSlotChunks import ok");
    } catch (importErr) {
      context.log("‚ùå Misslyckades importera generateSlotChunks:", importErr.message);
      context.res = { status: 500, body: { error: "Import error", detail: importErr.message } };
      client.release();
      return;
    }

    const weeklyMinutesByType = {};
    const weekKey = (date) => {
      const start = new Date(date);
      start.setUTCHours(0, 0, 0, 0);
      start.setUTCDate(start.getUTCDate() - start.getUTCDay());
      return start.toISOString().split('T')[0];
    };
    for (const b of allBookings) {
      const type = b.meeting_type || 'unknown';
      const week = weekKey(b.start);
      weeklyMinutesByType[type] = weeklyMinutesByType[type] || {};
      weeklyMinutesByType[type][week] = (weeklyMinutesByType[type][week] || 0) + (b.end - b.start) / 60000;
    }

    const debugHelper = createDebugLogger(context);

    const appleMapsToken = await getAppleMapsAccessToken(context);
    if (appleMapsToken) {
      context.log("‚úÖ Apple Maps token h√§mtad ‚Äì l√§ngd:", appleMapsToken.length);
    } else {
      context.log("‚ö†Ô∏è Apple Maps token saknas ‚Äì fallback kommer att anv√§ndas");
    }

    // Riktigt anrop till generateSlotChunks
    const slotGroupPicked = {};
    const startSlotGen = Date.now();
    const chosenSlotsResult = await generateSlotChunks({
      days,
      context,
      contact,
      contact_id,
      meeting_type,
      meeting_length,
      bookingsByDay,
      weeklyMinutesByType,
      settings,
      graphClient,
      appleClient,
      travelCache: new Map(),
      accessToken: appleMapsToken,
      timezone: settings.timezone || 'Europe/Stockholm',
      debugHelper,
      client: client,
      slotGroupPicked,
      logSlotContext: true
    });
    const durationMs = Date.now() - startSlotGen;
    context.log(`‚è±Ô∏è Slotgenerering klar p√• ${durationMs} ms`);
    context.log("‚úÖ generateSlotChunks k√∂rdes utan fel");
    context.log("üì¶ Slotresultat:", JSON.stringify(chosenSlotsResult?.chosenSlots || [], null, 2));

    if (chosenSlotsResult?.chosenSlots?.length) {
      for (const slot of chosenSlotsResult.chosenSlots) {
        const slotHour = new Date(slot.slot_iso).getUTCHours();
        context.log(`üìÜ Slot: ${slot.slot_iso}, Part: ${slot.slot_part}, Origin: ${slot.origin}, Source: ${slot.source}`);
      }
    }

    context.log("üì§ Response skickas med antal slots:", (chosenSlotsResult?.chosenSlots || []).length);
    context.res = {
      status: 200,
      body: {
        message: "‚úÖ getavailableslots √§r kontaktbar och fungerar i full version",
        received: { email, meeting_type, meeting_length },
        slots: (chosenSlotsResult?.chosenSlots || []).map(slot => ({
          ...slot,
          score: slot.score ?? null
        }))
      }
    };
    client.release();
    context.log("‚úÖ Databasanslutning sl√§ppt");
  } catch (err) {
    context.log("üî• FEL i minimal testfunktion:", err.message);
    context.res = { status: 500, body: { error: err.message } };
  }
  context.log("üéØ Slut p√• exekvering av getavailableslots");
  context.log("‚úÖ getavailableslots/index.js ‚Äì HELA FUNKTIONEN K√ñRDES UTAN FEL");
};
END: index.js

====================
üìÑ Fil: refreshCalendarOrigins/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-22 19:34:31
üìè Antal rader: 36
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 4 ‚Äì ["const { DateTime } = require('luxon');", "const pool = require('../shared/db/pgPool');", "const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');", "const { getSettings } = require('../shared/config/settingsLoader');"]
üîç L√§ngsta funktion: 4 rader
üß† Komplexitetspo√§ng: 1
üß™ TODO/FIXME: 0
====================
START: index.js


const { DateTime } = require('luxon');
const pool = require('../shared/db/pgPool');
const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');

const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const today = new Date();
  const settings = await getSettings(context);
  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const date = new Date();
    date.setDate(today.getDate() + i);
    return date;
  });

  context.log(`üîÅ K√∂r refreshCalendarOrigins f√∂r ${days.length} dagar`);

  for (const date of days) {
    const slotTime = DateTime.fromJSDate(date).set({ hour: 10, minute: 0 }).toJSDate();
    const travelStart = new Date(slotTime.getTime() - (settings.fallback_travel_time_minutes || 20) * 60000);

    await resolveOriginAddress({
      eventId: slotTime.toISOString(),
      calendarId: 'system-refresh',
      pool,
      context,
      fallbackOrigin: settings.default_home_address,
      settings
    });
  }

  context.log('‚úÖ refreshCalendarOrigins f√§rdig');
};
END: index.js

====================
üìÑ Fil: refreshTravelTimes/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-22 19:35:16
üìè Antal rader: 112
üß© Antal funktioner: 4
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 6 ‚Äì ["const { DateTime } = require('luxon');", "const fetch = require('node-fetch');", "const pool = require('../shared/db/pgPool');", "const { getSettings } = require('../shared/config/settingsLoader');", "const jwt = require('jsonwebtoken');", "const fs = require('fs');"]
üîç L√§ngsta funktion: 10 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: index.js
const { DateTime } = require('luxon');
const fetch = require('node-fetch');
const pool = require('../shared/db/pgPool');
const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const settings = await getSettings(context);
  const fallbackTravelTime = settings.fallback_travel_time_minutes || 20;
  const today = new Date();
  const timezone = settings.timezone || 'Europe/Stockholm';

  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const d = new Date(today);
    d.setDate(today.getDate() + i);
    return d;
  });

  const destinations = [settings.default_office_address];
  const origins = [settings.default_home_address];

  for (const day of days) {
    for (const hour of [10, 14]) {
      const slotTime = DateTime.fromJSDate(day).set({ hour, minute: 0 }).toJSDate();

      for (const from of origins) {
        for (const to of destinations) {
          const hourKey = slotTime.getUTCHours();
          const key = `${from}|${to}|${hourKey}`;

          const res = await pool.query(
            `SELECT 1 FROM travel_time_cache
             WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
            [from, to, hourKey]
          );

          if (res.rows.length > 0) {
            context.log(`‚ö° Redan i cache: ${key}`);
            continue;
          }

          context.log(`‚è≥ Ber√§knar restid: ${key}`);
          try {
            const token = await getAppleMapsAccessToken(context);
            if (!token) throw new Error('Apple Maps-token saknas');

            const url = new URL('https://maps-api.apple.com/v1/directions');
            url.searchParams.append('origin', from);
            url.searchParams.append('destination', to);
            url.searchParams.append('transportType', 'automobile');
            url.searchParams.append('departureTime', slotTime.toISOString());

            const response = await fetch(url.toString(), {
              headers: { Authorization: `Bearer ${token}` }
            });
            const data = await response.json();

            const minutes = Math.round((data.routes?.[0]?.durationSeconds || fallbackTravelTime * 60) / 60);
            await pool.query(
              `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
               VALUES ($1, $2, $3, $4)
               ON CONFLICT (from_address, to_address, hour)
               DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes`,
              [from, to, hourKey, minutes]
            );
            context.log(`‚úÖ Sparad restid: ${minutes} min (${key})`);
          } catch (err) {
            context.log(`‚ö†Ô∏è Misslyckades h√§mta/spara restid f√∂r ${key}: ${err.message}`);
          }
        }
      }
    }
  }

  context.log('‚úÖ refreshTravelTimes f√§rdig');
};

async function getAppleMapsAccessToken(context) {
  try {
    const jwt = require('jsonwebtoken');
    const fs = require('fs');

    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n') ||
                       fs.readFileSync(process.env.APPLE_MAPS_KEY_PATH, 'utf8');

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context.log('‚ö†Ô∏è Misslyckades h√§mta Apple Maps token:', err.message);
    return null;
  }
}
END: index.js

====================
üìÑ Fil: shared/calendar/appleCalendar.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-26 22:13:30
üìè Antal rader: 190
üß© Antal funktioner: 7
üí¨ Kommentarst√§ckning: 2 rader (1.1%)
üì• Imports: 3 ‚Äì ['const fetch = require("node-fetch");', 'const xml2js = require("xml2js");', 'const { DateTime } = require("luxon");']
üîç L√§ngsta funktion: 8 rader
üß† Komplexitetspo√§ng: 14
üß™ TODO/FIXME: 0
====================
START: appleCalendar.js
console.log("üß™ appleCalendar.js laddades");
const fetch = require("node-fetch");
const xml2js = require("xml2js");
const { DateTime } = require("luxon");

function createAppleClient(context) {
  async function getEvent(calendarId, eventId) {
    context.log("üçè appleClient.getEvent() anropad med:", { calendarId, eventId });
    const caldavUrl = process.env.CALDAV_CALENDAR_URL;
    const username = process.env.CALDAV_USER;
    const password = process.env.CALDAV_PASSWORD;

    context.log("üß™ getEvent() kallas med:", { calendarId, eventId });
    context.log("üçè appleClient.getEvent() startar ‚Äì kontrollera om .ics-inneh√•ll inneh√•ller LOCATION och DTEND...");
    context.log("üåê caldavUrl:", caldavUrl);
    context.log("üë§ username:", username);

    context.log("üåê Kontroll: CALDAV_CALENDAR_URL =", caldavUrl);
    context.log("üë§ Kontroll: CALDAV_USER =", username);
    if (!caldavUrl || !username || !password) {
      context.log("‚ö†Ô∏è Missing CalDAV credentials");
      return null;
    }

    try {
      const eventUrl = `${caldavUrl.replace(/\/$/, '')}/${eventId}.ics`;
      const icsRes = await fetch(eventUrl, {
        method: "GET",
        headers: {
          "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64")
        }
      });

      if (!icsRes.ok) {
        context.log(`‚ö†Ô∏è Misslyckades h√§mta ICS-fil: ${eventUrl}`);
        return null;
      }

      const icsText = await icsRes.text();
      context.log("üßæ F√∂rhandsvisning av ICS-inneh√•ll (f√∂rsta 500 tecken):", icsText.slice(0, 500));
      context.log("üßæ Full ICS-inneh√•ll:");
      context.log(icsText);
      context.log("üîç locationMatch:", icsText.match(/LOCATION:(.*)/));
      context.log("üîç endTimeMatch:", icsText.match(/DTEND(?:;[^:]*)?:(.*)/));
      const locationMatch = icsText.match(/LOCATION:(.*)/);
      const endTimeMatch = icsText.match(/DTEND(?:;[^:]*)?:(.*)/);

      const location = locationMatch ? locationMatch[1].trim() : null;
      const endTime = endTimeMatch ? endTimeMatch[1].trim() : null;

      if (location && endTime) {
        context.log("‚úÖ Hittade event med location och endTime:", { location, endTime });
        return { location, endTime };
      }

      context.log("‚ö†Ô∏è Inget event med b√•de location och endTime hittades.");
      return null;

    } catch (err) {
      context.log("‚ö†Ô∏è Error i getEvent():", err.message);
      return null;
    }
  }

  // H√§mtar alla events i ett datumintervall via CalDAV REPORT
  async function fetchEventsByDateRange(startDate, endDate) {
    const caldavUrl = process.env.CALDAV_CALENDAR_URL;
    const username = process.env.CALDAV_USER;
    const password = process.env.CALDAV_PASSWORD;

    context.log("üß™ fetchEventsByDateRange() kallas med:", { startDate, endDate });
    context.log(`üçè fetchEventsByDateRange(): anv√§nder CALDAV_USER = ${process.env.CALDAV_USER}`);

    if (!caldavUrl || !username || !password) {
      context.log("‚ö†Ô∏è Missing CalDAV credentials");
      return [];
    }

    const formatToFloating = (dateObj) => DateTime.fromISO(dateObj).toFormat("yyyyMMdd'T'HHmmss");
    const rangeStart = formatToFloating(startDate);
    const rangeEnd = formatToFloating(endDate);

    const xmlBody = `
<C:calendar-query xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:caldav">
  <D:prop>
    <D:getetag/>
    <C:calendar-data content-type="text/calendar"/>
  </D:prop>
  <C:filter>
    <C:comp-filter name="VCALENDAR">
      <C:comp-filter name="VEVENT">
        <C:time-range start="${rangeStart}" end="${rangeEnd}"/>
      </C:comp-filter>
    </C:comp-filter>
  </C:filter>
</C:calendar-query>`.trim();

    try {
      const res = await fetch(caldavUrl, {
        method: "REPORT",
        headers: {
          "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64"),
          "Depth": "1",
          "Content-Type": "application/xml"
        },
        body: xmlBody
      });

      const xml = await res.text();
      context.log("üîé R√• XML-svar fr√•n CalDAV:");
      context.log(xml.slice(0, 2000)); // logga de f√∂rsta 2000 tecknen
      const parsed = await xml2js.parseStringPromise(xml, { explicitArray: false, tagNameProcessors: [xml2js.processors.stripPrefix] });
      const responses = parsed?.['multistatus']?.['response'] || parsed?.['D:multistatus']?.['D:response'];
      context.log("üì¶ Parsed CalDAV-respons:", JSON.stringify(responses, null, 2));
      if (!responses) return [];

      const items = Array.isArray(responses) ? responses : [responses];
      // Filtrera p√• exakt r√§tt kalender-href
      const targetPath = new URL(process.env.CALDAV_CALENDAR_URL.trim()).pathname;
      context.log("üéØ Filtrerar p√• exakt href-prefix:", targetPath);
      const filteredItems = items.filter(item => {
        const href = item['href'] || item['D:href'] || '';
        const match = href.trim().startsWith(targetPath);
        if (!match) context.log("‚õî Hoppar annan kalender:", href.trim());
        return match;
      });
      const results = [];

      for (const item of filteredItems) {
        let calendarData = item?.['propstat']?.['prop']?.['calendar-data'] || item?.['D:propstat']?.['D:prop']?.['C:calendar-data'];

        if (calendarData && typeof calendarData === 'object' && '_' in calendarData) {
          calendarData = calendarData._;
        }

        const href = item['href'] || item['D:href'];
        if (!calendarData || !calendarData.includes('VEVENT')) {
          const fullUrl = `${caldavUrl.replace(/\/$/, '')}${href}`;
          const fallbackRes = await fetch(fullUrl, {
            method: "GET",
            headers: {
              "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64")
            }
          });
          calendarData = await fallbackRes.text();
          if (!calendarData.includes("VEVENT")) continue;
        }

        const vevents = Array.from(calendarData.matchAll(/BEGIN:VEVENT[\s\S]*?END:VEVENT/g));
        for (const vevent of vevents) {
          const v = vevent[0];
          const summary = v.match(/SUMMARY:(.*)/)?.[1]?.trim() ?? "‚Äì";
          const dtstart = v.match(/DTSTART(?:;[^:]*)?:(\d{8}(T\d{6})?)/)?.[1]?.trim() ?? "‚Äì";
          const dtend = v.match(/DTEND(?:;[^:]*)?:(\d{8}(T\d{6})?)/)?.[1]?.trim() ?? "‚Äì";
          const location = v.match(/LOCATION:(.*)/)?.[1]?.trim() ?? "‚Äì";
          const uid = v.match(/UID:(.*)/)?.[1]?.trim() ?? "‚Äì";
          results.push({ summary, dtstart, dtend, location, uid });
        }
      }

      results.sort((a, b) => {
        const aTime = new Date(a.dtstart.replace(/^(\d{8})$/, '$1T000000')).getTime();
        const bTime = new Date(b.dtstart.replace(/^(\d{8})$/, '$1T000000')).getTime();
        return aTime - bTime;
      });

      context.log(`‚úÖ Hittade ${results.length} events totalt`);
      const now = new Date();
      const upcoming = results.filter(ev => {
        const dt = ev.dtstart.replace(/^(\d{8})$/, '$1T000000');
        return new Date(dt) > now;
      });
      return upcoming;
    } catch (err) {
      context.log("‚ùå Fel i fetchEventsByDateRange():", err.message);
      return [];
    }
  }

  return { getEvent, fetchEventsByDateRange };
}

const client = createAppleClient({ log: console.log });

if (process.env.NODE_ENV === 'test') {
  console.log("üß™ TEST appleClient:", typeof client.getEvent === 'function' ? '‚úÖ getEvent finns' : '‚ùå getEvent saknas');
  console.log("üß™ TEST appleClient:", typeof client.fetchEventsByDateRange === 'function' ? '‚úÖ fetchEventsByDateRange finns' : '‚ùå fetchEventsByDateRange saknas');
}

module.exports = () => client;
END: appleCalendar.js

====================
üìÑ Fil: shared/calendar/getMsToken.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-22 10:10:03
üìè Antal rader: 57
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ["require('dotenv').config(); // Ladda milj√∂variabler fr√•n .env", "const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 4 rader
üß† Komplexitetspo√§ng: 5
üß™ TODO/FIXME: 0
====================
START: getMsToken.js
require('dotenv').config(); // Ladda milj√∂variabler fr√•n .env
const fetch = require('node-fetch');

console.log("üß™ getMsToken.js laddades");

module.exports = async function getMsToken(context = { log: console.log }) {
  context.log("üß™ getMsToken() anropades ‚Äì initierar tokenh√§mtning");
  context.log("üîç MS365_CLIENT_ID:", process.env.MS365_CLIENT_ID?.slice(0, 8));
  context.log("üîç MS365_CLIENT_SECRET:", process.env.MS365_CLIENT_SECRET ? "[satt]" : "[saknas]");
  context.log("üîç MS365_TENANT_ID:", process.env.MS365_TENANT_ID?.slice(0, 8));
  if (!process.env.MS365_CLIENT_ID || !process.env.MS365_CLIENT_SECRET || !process.env.MS365_TENANT_ID) {
    context.log("‚ùå En eller flera milj√∂variabler f√∂r MS Graph saknas.");
    return null;
  }
  try {
    const tokenEndpoint = `https://login.microsoftonline.com/${process.env.MS365_TENANT_ID}/oauth2/v2.0/token`;
    const params = new URLSearchParams();
    params.append('client_id', process.env.MS365_CLIENT_ID);
    params.append('client_secret', process.env.MS365_CLIENT_SECRET);
    params.append('scope', 'https://graph.microsoft.com/.default');
    params.append('grant_type', 'client_credentials');

    context.log("üì° F√∂rs√∂ker h√§mta token fr√•n:", tokenEndpoint);

    const res = await fetch(tokenEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params
    });

    context.log(`üì¨ Response status: ${res.status}`);

    if (!res.ok) {
      const errorText = await res.text();
      context.log(`‚ö†Ô∏è Tokenh√§mtning misslyckades: ${res.status} ${res.statusText}\nSvar: ${errorText}`);
      context.log("ü™µ Fullst√§ndigt svar fr√•n Graph:", errorText);
      return null;
    }

    const data = await res.json();
    return data.access_token;
  } catch (err) {
    context.log(`‚ö†Ô∏è Tokenh√§mtning fel: ${err.message}`);
    return null;
  }
};

if (require.main === module) {
  (async () => {
    const token = await module.exports();
    if (token) {
      console.log("‚úÖ Token h√§mtad:", token.slice(0, 20) + "...");
    } else {
      console.log("‚ùå Kunde inte h√§mta token.");
    }
  })();
}
END: getMsToken.js

====================
üìÑ Fil: shared/calendar/msGraph.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-26 11:14:30
üìè Antal rader: 185
üß© Antal funktioner: 6
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 5 ‚Äì ['const { Client } = require("@microsoft/microsoft-graph-client");', 'require("isomorphic-fetch");', 'const fetch = require("node-fetch");', 'const { loadSettings } = require("../config/settingsLoader");', 'const getMsToken = require("./getMsToken");']
üîç L√§ngsta funktion: 6 rader
üß† Komplexitetspo√§ng: 15
üß™ TODO/FIXME: 0
====================
START: msGraph.js
const { Client } = require("@microsoft/microsoft-graph-client");
require("isomorphic-fetch");
const fetch = require("node-fetch");
const { loadSettings } = require("../config/settingsLoader");
const getMsToken = require("./getMsToken");

function createMsGraphClient() {

  async function getEvent(calendarId, eventId) {
    try {
      if (!calendarId || !eventId) {
        return null;
      }

      const authToken = await getMsToken({ log: console.log });
      if (!authToken) {
        throw new Error("üõë Tokenh√§mtning misslyckades ‚Äì accessToken saknas. Funktion avbryts.");
      }
      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      try {
        const result = await client
          .api(`/users/${calendarId}/events/${encodeURIComponent(eventId)}`)
          .select("subject,location,start,end")
          .get();

        const location = result.location?.displayName || null;
        const endTime = result.end?.dateTime || null;

        return { location, endTime };
      } catch (err) {
        if (err.statusCode === 404) {
          return { location: null, endTime: null, deleted: true };
        }
        console.error("‚ö†Ô∏è getEvent error (Graph):", err.message);
        return null;
      }
    } catch (err) {
      console.error("‚ö†Ô∏è getEvent error (Graph):", err.message);
      return null;
    }
  }

  async function listUpcomingEvents(daysAhead) {
    try {
      if (!daysAhead) {
        const settings = await loadSettings(null);
        daysAhead = settings.max_days_in_advance || 90;
      }
      const calendarId = process.env.MS365_USER_EMAIL;
      if (!calendarId) throw new Error("‚ùå MS365_USER_EMAIL saknas");

      const authToken = await getMsToken({ log: console.log });
      if (!authToken) {
        throw new Error("üõë Tokenh√§mtning misslyckades ‚Äì accessToken saknas. Funktion avbryts.");
      }
      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const now = new Date();
      const startDate = now.toISOString();
      const endDate = new Date(now.getTime() + daysAhead * 86400000).toISOString();

      const response = await client
        .api(`/users/${calendarId}/calendarView?startDateTime=${startDate}&endDateTime=${endDate}`)
        .top(100)
        .select("subject,start,end,id")
        .orderby("start/dateTime ASC")
        .get();

      const upcoming = response.value.filter(ev => new Date(ev.start.dateTime) > new Date());
      return upcoming.map(ev => ({
        subject: ev.subject,
        start: ev.start.dateTime,
        end: ev.end?.dateTime || null,
        id: ev.id
      }));
    } catch (err) {
      console.error("‚ö†Ô∏è listUpcomingEvents error (Graph):", err.message);
      return [];
    }
  }

  async function createEvent({ start, end, subject, location, attendees }) {
    try {
      const calendarId = process.env.MS365_USER_EMAIL;
      if (!calendarId) throw new Error("‚ùå MS365_USER_EMAIL saknas");

      const authToken = await getMsToken({ log: console.log });
      if (!authToken) throw new Error("üõë Tokenh√§mtning misslyckades");

      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const event = {
        subject: subject || "M√∂te",
        body: {
          contentType: "HTML",
          content: `Detta √§r en inbjudan till m√∂te: ${subject || "M√∂te"}`
        },
        start: {
          dateTime: start,
          timeZone: "Europe/Stockholm"
        },
        end: {
          dateTime: end,
          timeZone: "Europe/Stockholm"
        },
        location: {
          displayName: location || "Online"
        },
        attendees: (attendees || []).map(email => ({
          emailAddress: { address: email },
          type: "required"
        })),
        allowNewTimeProposals: true,
        isOnlineMeeting: true,
        onlineMeetingProvider: "teamsForBusiness"
      };

      const created = await client.api(`/users/${calendarId}/events`).post(event);

      return {
        eventId: created?.id || null,
        onlineMeetingUrl: created?.onlineMeeting?.joinUrl || null,
        subject: created?.subject || null,
        location: created?.location?.displayName || null,
        body: created?.body || null
      };
    } catch (err) {
      console.error("‚ùå createEvent error (Graph):", err.message || err);
      if (err.response?.text) {
        const raw = await err.response.text();
        console.error("üìÑ Graph response text:", raw);
      }
      console.error("üìÑ Detaljerat Graph-felobjekt:", JSON.stringify(err, null, 2));
      return null;
    }
  }

  async function sendEmailInvite({ to, subject, body }) {
    try {
      const senderEmail = process.env.MS365_USER_EMAIL;
      const authToken = await getMsToken({ log: console.log });
      if (!authToken) throw new Error("‚ùå Kunde inte h√§mta Graph-token");

      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const message = {
        message: {
          subject,
          body: {
            contentType: "HTML",
            content: body
          },
          toRecipients: [
            {
              emailAddress: {
                address: to
              }
            }
          ]
        },
        saveToSentItems: "true"
      };

      await client.api(`/users/${senderEmail}/sendMail`).post(message);
      return { status: "sent" };
    } catch (err) {
      console.error("‚ùå sendEmailInvite error:", err.message || err);
      return null;
    }
  }

  return { getEvent, listUpcomingEvents, createEvent, sendEmailInvite };
}

const client = createMsGraphClient();
module.exports = () => client;
END: msGraph.js

====================
üìÑ Fil: shared/calendar/resolveOrigin.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-22 14:30:40
üìè Antal rader: 235
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 21 rader (8.9%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 37
üß™ TODO/FIXME: 0
====================
START: resolveOrigin.js
/**
 * resolveOriginAddress
 * --------------------
 * H√§mtar origin-adress f√∂r ett kalender-event fr√•n:
 * 1. Memory-cache
 * 2. PostgreSQL-cache (om SKIP_DB inte √§r satt)
 * 3. MS Graph
 * 4. Apple Calendar
 * Fallback anv√§nds vid miss.
 *
 * Milj√∂variabler:
 * - SKIP_DB=true  ‚Üí hoppar √∂ver all databaslogik (l√§s/skriv)
 */
console.log("üß™ resolveOrigin.js laddades");
const memoryCache = {};

function cleanAddress(address) {
  return address.replace(/\n/g, ', ').replace(/\\,/g, ',').replace(/\+/g, ' ').trim();
}

async function resolveOriginAddress({ eventId, calendarId, pool, context, graphClient, appleClient, fallbackOrigin, settings, eventCache }) {
  const cacheKey = `${calendarId}:${eventId}`;
  const debugLog = (msg) => {
    if (process.env.DEBUG === 'true' && context?.log) context.log(msg);
  };
  debugLog(`üîç resolveOriginAddress ‚Üí calendarId: ${calendarId}, eventId: ${eventId}`);
  const eventDateOnly = eventId.split('T')[0];

  const useCacheEvents = eventCache?.has(eventDateOnly);
  const cachedEvents = useCacheEvents ? eventCache.get(eventDateOnly) : null;

  if (memoryCache[cacheKey]) {
    // Provide originEndTime as well
    let originEndTime = null;
    if (memoryCache[cacheKey].originSource === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = memoryCache[cacheKey].originEndTime || null;
    }
    debugLog(`‚úÖ Hittade origin fr√•n cache: ${memoryCache[cacheKey].origin}`);
    return {
      origin: cleanAddress(memoryCache[cacheKey].origin),
      originSource: memoryCache[cacheKey].originSource,
      originEndTime
    };
  }


  // Try database cache first
  let dbRes;
  if (!process.env.SKIP_DB) {
    try {
      dbRes = await pool.query(
        'SELECT address, source, end_time FROM calendar_origin_cache WHERE event_date = $1',
        [eventDateOnly]
      );
      debugLog(`üìÇ DB-kontroll: Hittade ${dbRes?.rows?.length || 0} rader f√∂r ${eventDateOnly}`);
    } catch (err) {
      context.log(`‚ö†Ô∏è DB error in resolveOriginAddress: ${err.message}`);
    }
  }
  if (dbRes && dbRes.rows && dbRes.rows.length > 0) {
    // Special case: if source is fallback, return immediately
    if (dbRes.rows[0].source === 'fallback') {
      const originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
      memoryCache[cacheKey] = {
        origin: dbRes.rows[0].address,
        originSource: dbRes.rows[0].source,
        originEndTime
      };
      debugLog(`üõë DB-tr√§ff var fallback ‚Äì hoppar √∂vriga f√∂rs√∂k`);
      return {
        origin: cleanAddress(dbRes.rows[0].address),
        originSource: dbRes.rows[0].source,
        originEndTime
      };
    }
    let originEndTime = null;
    if (dbRes.rows[0].source === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = dbRes.rows[0].end_time || null;
    }
    memoryCache[cacheKey] = {
      origin: dbRes.rows[0].address,
      originSource: dbRes.rows[0].source,
      originEndTime: originEndTime
    };
    debugLog(`‚úÖ Hittade origin fr√•n DB: ${dbRes.rows[0].address}`);
    return {
      origin: cleanAddress(dbRes.rows[0].address),
      originSource: dbRes.rows[0].source,
      originEndTime
    };
  }
  debugLog(`üï≥Ô∏è Inget cachetr√§ff i DB f√∂r ${eventDateOnly}`);

  let latestOrigin;
  let originEndTime = null;
  let originSource = 'unknown';

  if (!latestOrigin && memoryCache[`${calendarId}:${eventDateOnly}`]) {
    const { origin, originSource, originEndTime } = memoryCache[`${calendarId}:${eventDateOnly}`];
    debugLog(`üîÅ √Öteranv√§nder memoryCache f√∂r dag: ${eventDateOnly}`);
    return { origin: cleanAddress(origin), originSource, originEndTime };
  }
  if (graphClient && typeof graphClient.getEvent === 'function') {
    if (!latestOrigin && !memoryCache[`${calendarId}:${eventDateOnly}`]) {
      try {
        const graphCalendarId = settings.ms_sender_email;
        const appleCalendarId = process.env.CALDAV_USER;
        const msEvent = await graphClient.getEvent(graphCalendarId, eventId);
        if (msEvent && msEvent.location) {
          latestOrigin = msEvent.location;
          originSource = 'Microsoft 365';
          debugLog(`‚úÖ Hittade origin fr√•n MS Graph: ${latestOrigin}`);
        }
      } catch (err) {
        context.log(`‚ö†Ô∏è MS Graph error in resolveOriginAddress: ${err.message}`);
      }
    }
  } else if (graphClient) {
    context.log(`‚ö†Ô∏è graphClient saknar getEvent-metod eller √§r null`);
  }

  // Try fetching from Apple calendar if not found
  if (!latestOrigin && appleClient && typeof appleClient.fetchEventsByDateRange === 'function') {
    try {
      const startRange = `${eventDateOnly}T00:00:00Z`;
      const endRange = `${eventDateOnly}T23:59:59Z`;
      const appleCalendarId = process.env.CALDAV_USER;
      const events = cachedEvents || await appleClient.fetchEventsByDateRange(startRange, endRange, appleCalendarId);
      if (!cachedEvents && eventCache) eventCache.set(eventDateOnly, events);
      let mostRecent = null;
      const eventStartTime = new Date(eventId);
      for (const e of events) {
        const dtend = new Date(e.dtend || '');
        if (dtend && dtend <= eventStartTime) {
          if (!mostRecent || dtend > new Date(mostRecent.dtend || 0)) {
            mostRecent = e;
          }
        }
      }

      // Om ingen med location hittades, ta det senaste med dtend
      if (!mostRecent) {
        for (const e of events) {
          const dtend = new Date(e.dtend || '');
          if (dtend && dtend <= eventStartTime) {
            if (!mostRecent || dtend > new Date(mostRecent.dtend || 0)) {
              mostRecent = e;
            }
          }
        }
      }

      if (mostRecent) {
        latestOrigin = mostRecent.location || fallbackOrigin || '';
        originSource = mostRecent.location ? 'Apple Calendar' : 'fallback';
        debugLog(`‚úÖ Hittade origin fr√•n Apple (eller fallback): ${latestOrigin}`);

        if (mostRecent.dtend && typeof mostRecent.dtend === 'string') {
          const dt = mostRecent.dtend.replace(/[^0-9T]/g, '');
          const parsed = new Date(dt.length === 8 ? `${dt}T00:00:00Z` : dt);
          originEndTime = !isNaN(parsed.getTime())
            ? parsed
            : new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
        } else {
          originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
        }
      }
    } catch (err) {
      context.log(`‚ö†Ô∏è Apple error in resolveOriginAddress: ${err.message}`);
    }
  } else if (!latestOrigin && appleClient) {
    context.log(`‚ö†Ô∏è appleClient saknar fetchEventsByDateRange-metod eller √§r null`);
  }

  // Fallback if not found
  if (!latestOrigin) {
    if (originEndTime) {
      debugLog(`‚ö†Ô∏è LOCATION saknas men endTime finns ‚Äì anv√§nder fallback som origin`);
      latestOrigin = fallbackOrigin || '';
      originSource = 'fallback';
    } else {
      debugLog(`üö® Ingen tr√§ff i varken cache, DB, Graph eller Apple ‚Äì anv√§nder fallback`);
      latestOrigin = fallbackOrigin || '';
      originSource = 'fallback';
    }
    debugLog(`‚ö†Ô∏è Fallback anv√§nds som origin: ${latestOrigin}`);
  }

  memoryCache[`${calendarId}:${eventDateOnly}`] = {
    origin: latestOrigin,
    originSource,
    originEndTime
  };

  // Write to DB cache unless fallback
  originEndTime = originEndTime || null;
  if (originSource === 'fallback') {
    originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
  }
  // Ensure originEndTime fallback value before DB insert (unless fallback)
  if (!originEndTime && originSource !== 'fallback') {
    originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
  }
  if (!process.env.SKIP_DB && originSource !== 'fallback') {
    try {
      await pool.query(
        `INSERT INTO calendar_origin_cache (event_date, source, address, end_time)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT DO NOTHING`,
        [eventDateOnly, originSource, latestOrigin, originEndTime]
      );
    } catch (err) {
      context.log(`‚ö†Ô∏è DB write error in resolveOriginAddress: ${err.message}`);
    }
  }

  memoryCache[cacheKey] = {
    origin: latestOrigin,
    originSource,
    originEndTime
  };
  debugLog(`üß† resolveOriginAddress resultat: ${latestOrigin} (k√§lla: ${originSource})`);
  context.log(`üì§ resolveOriginAddress return: ${latestOrigin} (k√§lla: ${originSource}, endTime: ${originEndTime?.toISOString?.() || 'null'})`);
  return { origin: cleanAddress(latestOrigin), originSource, originEndTime };
}

module.exports = { resolveOriginAddress };

if (process.env.NODE_ENV === 'test') {
  module.exports._test = { memoryCache };
}
END: resolveOrigin.js

====================
üìÑ Fil: shared/config/settingsLoader.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-23 17:58:16
üìè Antal rader: 67
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 1 ‚Äì ['const pool = require("../db/pgPool");']
üîç L√§ngsta funktion: 8 rader
üß† Komplexitetspo√§ng: 11
üß™ TODO/FIXME: 0
====================
START: settingsLoader.js
const pool = require("../db/pgPool");
console.log("üß™ settingsLoader.js laddades");
async function getSettings(context) {
  try {
    const settings = {};
    const isDebug = process.env.DEBUG === 'true';
    const debugLog = (msg) => {
      if (isDebug && context && context.log) {
        context.log(msg);
      }
    };
    debugLog('‚öôÔ∏è B√∂rjar l√§sa booking_settings...');
    const settingsRes = await pool.query('SELECT key, value, value_type FROM booking_settings');
    debugLog(`üì¶ ${settingsRes.rows.length} inst√§llningar h√§mtade`);
    for (const row of settingsRes.rows) {
      debugLog(`üîë ${row.key} = ${row.value} (${row.value_type})`);
      if (
        row.value_type === 'json' ||
        row.value_type === 'array' ||
        (typeof row.value_type === 'string' && /\[\]$/.test(row.value_type))
      ) {
        try {
          settings[row.key] = JSON.parse(typeof row.value === 'string' ? row.value : JSON.stringify(row.value));
        } catch (_) {}
      } else if (row.value_type === 'int') {
        settings[row.key] = parseInt(row.value);
      } else if (row.value_type === 'bool') {
        settings[row.key] = row.value === 'true' || row.value === true;
      } else if (row.value_type === 'string') {
        settings[row.key] = String(row.value).replace(/^"(.*)"$/, '$1');
      } else {
        settings[row.key] = row.value;
      }
    }
    debugLog('‚úÖ Alla inst√§llningar tolkade och klara');
    settings.field_labels = {
      first_name: 'F√∂rnamn',
      last_name: 'Efternamn',
      phone: 'Telefonnummer',
      company: 'F√∂retag',
      address: 'Gatuadress',
      postal_code: 'Postnummer',
      city: 'Stad',
      country: 'Land'
    };
    return settings;
  } catch (err) {
    if (context && context.log) {
      context.log(`‚ö†Ô∏è Fel vid laddning av booking_settings: ${err.message}`);
    } else {
      console.warn(`‚ö†Ô∏è Fel vid laddning av booking_settings: ${err.message}`);
    }
    throw err;
  }
}

function getCloudSecretsOnly() {
  const secrets = {};
  for (const [key, value] of Object.entries(process.env)) {
    if (key.startsWith('MS365_')) {
      secrets[key] = value;
    }
  }
  return secrets;
}

module.exports = { getSettings, getCloudSecretsOnly };
END: settingsLoader.js

====================
üìÑ Fil: shared/config/verifySettings.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-20 12:15:11
üìè Antal rader: 52
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 24 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: verifySettings.js
console.log("üß™ verifySettings.js laddades");
function verifyBookingSettings(settings, context) {
  const expected = {
    default_office_address: 'string',
    default_home_address: 'string',
    fallback_travel_time_minutes: 'number',
    buffer_between_meetings: 'number',
    default_meeting_length_atoffice: 'array',
    default_meeting_length_atclient: 'array',
    default_meeting_length_digital: 'array',
    meeting_types: 'array',
    block_weekends: 'boolean',
    open_time: 'string',
    close_time: 'string',
    lunch_start: 'string',
    lunch_end: 'string',
    travel_time_window_start: 'string',
    travel_time_window_end: 'string',
    require_approval: 'boolean',
    max_days_in_advance: 'number',
    max_weekly_booking_minutes: 'number',
    cache_ttl_minutes: 'number',
    allowed_atclient_meeting_days: 'array',
    timezone: 'string'
  };

  const issues = [];
  for (const [key, type] of Object.entries(expected)) {
    const val = settings[key];
    if (val === undefined || val === null || (key === 'timezone' && String(val).trim() === '')) {
      issues.push(`‚ùå Saknar inst√§llning: ${key}`);
    } else if (key === 'allowed_atclient_meeting_days') {
      if (!Array.isArray(val) || !val.every(v => typeof v === 'string')) {
        issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: ska vara array av str√§ngar`);
      }
    } else if (key === 'require_approval') {
      if (typeof val !== 'boolean') {
        issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: ska vara boolean`);
      }
    } else if (type === 'array' ? !Array.isArray(val) : typeof val !== type) {
      issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: har ${typeof val}, f√∂rv√§ntade ${type}`);
    }
  }

  if (issues.length > 0) {
    const message = 'üõë Problem med booking_settings:\n' + issues.join('\n');
    context.log.warn(message);
    throw new Error(message);
  }
}

module.exports = verifyBookingSettings;
END: verifySettings.js

====================
üìÑ Fil: shared/db/pgPool.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-21 16:03:39
üìè Antal rader: 20
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ["const { Pool } = require('pg');", "require('dotenv').config();"]
üîç L√§ngsta funktion: 7 rader
üß† Komplexitetspo√§ng: 0
üß™ TODO/FIXME: 0
====================
START: pgPool.js
const { Pool } = require('pg');
require('dotenv').config();

const useSSL = process.env.PG_USE_SSL === 'true';
const sslConfig = useSSL ? { rejectUnauthorized: false } : false;

console.log("üß™ shared/db/pgPool.js laddades");
console.log("üîç PG_USE_SSL:", process.env.PG_USE_SSL);
console.log("üîç ssl config:", sslConfig);

const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: sslConfig
});

module.exports = pool;
END: pgPool.js

====================
üìÑ Fil: shared/maps/appleMaps.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-20 12:15:38
üìè Antal rader: 121
üß© Antal funktioner: 5
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ["const jwt = require('jsonwebtoken');", "const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 10 rader
üß† Komplexitetspo√§ng: 9
üß™ TODO/FIXME: 0
====================
START: appleMaps.js
console.log("üß™ appleMaps.js laddades");
const jwt = require('jsonwebtoken');
const fetch = require('node-fetch');

async function getAppleMapsAccessToken(context) {
  try {
    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n');

    if (!privateKey) {
      throw new Error('Apple Maps private key saknas ‚Äì kontrollera APPLE_MAPS_PRIVATE_KEY');
    }

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context?.log?.('‚ö†Ô∏è Misslyckades h√§mta Apple Maps token:', err.message);
    if (err.code === 'EAI_AGAIN') {
      context?.log?.('üåê DNS-fel (EAI_AGAIN) ‚Äì kunde inte n√• servern:', err.message);
    }
    return null;
  }
}


async function getTravelTimeInMinutes(origin, destination, departureTime, accessToken, context) {
  try {
    const url = `https://maps-api.apple.com/v1/directions?origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&departureTime=${encodeURIComponent(departureTime)}&transportType=automobile&includeTravelTimeBreakdown=true`;

    const res = await fetch(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });

    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`‚ùå Apple Maps-directions misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const travelTimeSeconds = data.routes?.[0]?.expectedTravelTime;
    return travelTimeSeconds ? Math.ceil(travelTimeSeconds / 60) : null;
  } catch (err) {
    context?.log?.(`‚ùå Fel vid directions-anrop: ${err.message}`);
    return null;
  }
}

async function getTravelTime(origin, destination, departureTime, context) {
  try {
    const token = await getAppleMapsAccessToken(context);
    if (!token) {
      context?.log?.('‚ö†Ô∏è Kunde inte h√§mta Apple Maps-token');
      return null;
    }
    return await getTravelTimeInMinutes(origin, destination, departureTime, token, context);
  } catch (err) {
    context?.log?.(`‚ùå Fel i getTravelTime: ${err.message}`);
    return null;
  }
}

async function safeGetTravelTime(origin, destination, departureTime, accessToken, context) {
  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', origin);
    url.searchParams.append('destination', destination);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', departureTime);

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 8000); // max 8s

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` },
      signal: controller.signal
    });

    clearTimeout(timeout);
    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`‚ùå Apple Maps misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const seconds = data.routes?.[0]?.durationSeconds || data.routes?.[0]?.expectedTravelTime;
    return seconds ? Math.round(seconds / 60) : null;
  } catch (err) {
    context?.log?.(`‚ö†Ô∏è safeGetTravelTime error: ${err.message}`);
    return null;
  }
}

module.exports = {
  getAppleMapsAccessToken,
  getTravelTimeInMinutes,
  getTravelTime,
  safeGetTravelTime
};
END: appleMaps.js

====================
üìÑ Fil: shared/maps/returnTravelVerifier.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-20 12:16:01
üìè Antal rader: 66
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 1 rader (1.5%)
üì• Imports: 1 ‚Äì ["const { URL } = require('url');"]
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 4
üß™ TODO/FIXME: 0
====================
START: returnTravelVerifier.js
console.log("üß™ returnTravelVerifier.js laddades");
const { URL } = require('url');

async function verifyReturnTravelFeasibility({
  previousBooking,
  contact,
  slotTime,
  settings,
  accessToken,
  db,
  context,
  travelCache
}) {
  const from = previousBooking.address || settings.default_office_address;
  const to = `${contact.metadata.address} ${contact.metadata.postal_code} ${contact.metadata.city}`;
  const prevEnd = new Date(previousBooking.end);

  if (from === to) {
    context.log(`üíæ Returrestid √§r 0 min (${from} ‚Üí ${to}) ‚Äì ingen cache beh√∂vs`);
    return { isFeasible: true };
  }

  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', from);
    url.searchParams.append('destination', to);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', prevEnd.toISOString());

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` }
    });

    const data = await res.json();
    const returnMinutes = Math.round((data.routes?.[0]?.durationSeconds || 0) / 60);
    const arrivalTime = new Date(prevEnd.getTime() + returnMinutes * 60000);

    // Cache return time in memory and DB
    const hour = prevEnd.getUTCHours();
    const returnCacheKey = `${from}|${to}|${hour}`;
    travelCache.set(returnCacheKey, returnMinutes);
    if (from && to) {
      await db.query(`
        INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (from_address, to_address, hour)
        DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes
      `, [from, to, hour, returnMinutes]);
      context.log(`üíæ Returrestid sparad: ${returnMinutes} min (${from} ‚Üí ${to} @ ${hour}:00)`);
    } else {
      context.log(`‚ö†Ô∏è Hoppar caching av retur ‚Äì saknar from_address (${from}) eller to_address (${to})`);
    }

    if (arrivalTime > slotTime) {
      context.log(`‚õî Slot ${slotTime.toISOString()} avvisad ‚Äì retur fr√•n tidigare m√∂te hinner inte fram i tid (ankomst ${arrivalTime.toISOString()})`);
      return { isFeasible: false, reason: 'retur hinner inte fram', arrivalTime };
    }

    return { isFeasible: true };
  } catch (err) {
    context.log(`‚ö†Ô∏è Kunde inte verifiera returrestid fr√•n tidigare m√∂te: ${err.message}`);
    return { isFeasible: true }; // fail open
  }
}

module.exports = { verifyReturnTravelFeasibility };
END: returnTravelVerifier.js

====================
üìÑ Fil: shared/maps/resolveTravelTime.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-20 20:22:50
üìè Antal rader: 72
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: resolveTravelTime.js
console.log("üß™ travelTimeResolver.js laddades");
async function resolveTravelTime({ origin, destination, hour, db, accessToken, context }) {
  let travelTimeMin = 20;
  const cacheKey = `${origin}|${destination}|${hour}`;
  let cacheHit = false;
  let isFallback = false;

  if (!origin || !destination) {
    context.log(`‚ö†Ô∏è Kan inte ber√§kna restid ‚Äì origin eller destination saknas`);
    return { travelTimeMin, cacheHit: false, isFallback };
  }

  if (!db || typeof db.query !== 'function') {
    context.log(`‚ùå db saknas eller saknar query-metod i resolveTravelTime`);
    return { travelTimeMin, cacheHit: false, isFallback: true };
  }

  try {
    const cacheRes = await db.query(
      `SELECT travel_minutes, is_fallback FROM travel_time_cache WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
      [origin, destination, hour]
    );
    if (cacheRes.rows.length > 0) {
      travelTimeMin = cacheRes.rows[0].travel_minutes;
      isFallback = cacheRes.rows[0].is_fallback === true;
      cacheHit = true;
      context.log(`‚ö° Cache hit (db): ${origin} ‚Üí ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
    }
  } catch (err) {
    context.log(`‚ö†Ô∏è Kunde inte l√§sa fr√•n travel_time_cache: ${err.message}`);
  }

  if (!accessToken) {
    context.log(`‚ö†Ô∏è accessToken saknas ‚Äì anv√§nder fallback`);
    return { travelTimeMin, cacheHit: false, isFallback: true };
  }

  if (!cacheHit && accessToken) {
    try {
      const url = new URL('https://maps-api.apple.com/v1/directions');
      url.searchParams.append('origin', origin);
      url.searchParams.append('destination', destination);
      url.searchParams.append('transportType', 'automobile');
      url.searchParams.append('departureTime', new Date().toISOString());

      const res = await fetch(url.toString(), {
        headers: { Authorization: `Bearer ${accessToken}` }
      });
      const data = await res.json();
      const travelSeconds = data.routes?.[0]?.durationSeconds;
      if (travelSeconds) {
        travelTimeMin = Math.round(travelSeconds / 60);
        await db.query(
          `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes, is_fallback)
           VALUES ($1, $2, $3, $4, false)
           ON CONFLICT (from_address, to_address, hour)
           DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes, is_fallback = false`,
          [origin, destination, hour, travelTimeMin]
        );
        context.log(`üíæ Sparade Apple Maps-restid i cache: ${origin} ‚Üí ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
      } else {
        context.log(`‚ö†Ô∏è Apple Maps-data saknas ‚Äì anv√§nder fallback`);
      }
    } catch (err) {
      context.log(`‚ö†Ô∏è Fel vid Apple Maps-anrop: ${err.message}`);
    }
  }

  return { travelTimeMin, cacheHit, isFallback };
}

module.exports = { resolveTravelTime };
END: resolveTravelTime.js

====================
üìÑ Fil: shared/calendar/zoomClient.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-26 11:07:48
üìè Antal rader: 63
üß© Antal funktioner: 3
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 1 ‚Äì ["const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 13 rader
üß† Komplexitetspo√§ng: 3
üß™ TODO/FIXME: 0
====================
START: zoomClient.js
const fetch = require('node-fetch');

function createZoomClient() {
  const clientId = process.env.ZOOM_CLIENT_ID;
  const clientSecret = process.env.ZOOM_CLIENT_SECRET;
  const accountId = process.env.ZOOM_ACCOUNT_ID;
  const userId = process.env.ZOOM_USER_ID || 'me';

  if (!clientId || !clientSecret || !accountId) {
    throw new Error("Missing Zoom OAuth credentials in environment variables");
  }

  async function getAccessToken() {
    const basicAuth = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
    const res = await fetch(`https://zoom.us/oauth/token?grant_type=account_credentials&account_id=${accountId}`, {
      method: 'POST',
      headers: {
        Authorization: `Basic ${basicAuth}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    });

    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Failed to get Zoom access token: ${text}`);
    }

    const data = await res.json();
    return data.access_token;
  }

  async function createMeeting({ topic, start, duration }) {
    const token = await getAccessToken();

    const res = await fetch(`https://api.zoom.us/v2/users/${userId}/meetings`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        topic,
        type: 2,
        start_time: start,
        duration,
        timezone: 'Europe/Stockholm'
      })
    });

    if (!res.ok) {
      const err = await res.text();
      throw new Error(`Zoom error: ${err}`);
    }

    const result = await res.json();
    console.log(`üìÖ Zoom-m√∂te skapat: ${result.join_url}`);
    return result;
  }

  return { createMeeting };
}

module.exports = createZoomClient;
END: zoomClient.js

====================
üìÑ Fil: shared/notification/sendMail.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-26 13:01:34
üìè Antal rader: 60
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 2 rader (3.3%)
üì• Imports: 1 ‚Äì ["const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 17 rader
üß† Komplexitetspo√§ng: 3
üß™ TODO/FIXME: 0
====================
START: sendMail.js


const fetch = require('node-fetch');

async function sendMail({ to, subject, body }) {
  const tenantId = process.env.MS365_TENANT_ID;
  const clientId = process.env.MS365_CLIENT_ID;
  const clientSecret = process.env.MS365_CLIENT_SECRET;
  const sender = process.env.MS365_USER_EMAIL;

  if (!tenantId || !clientId || !clientSecret || !sender) {
    throw new Error("‚ùå Saknar milj√∂variabler f√∂r Microsoft Graph");
  }

  // H√§mta token
  const tokenRes = await fetch(`https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      client_id: clientId,
      scope: 'https://graph.microsoft.com/.default',
      client_secret: clientSecret,
      grant_type: 'client_credentials'
    })
  });

  if (!tokenRes.ok) {
    const error = await tokenRes.text();
    throw new Error(`‚ùå Misslyckades h√§mta token: ${error}`);
  }

  const { access_token } = await tokenRes.json();

  // Skicka mejlet
  const mailRes = await fetch(`https://graph.microsoft.com/v1.0/users/${sender}/sendMail`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${access_token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      message: {
        subject,
        body: {
          contentType: 'Text',
          content: body
        },
        toRecipients: [{ emailAddress: { address: to } }]
      },
      saveToSentItems: false
    })
  });

  if (!mailRes.ok) {
    const error = await mailRes.text();
    throw new Error(`‚ùå Misslyckades skicka mail: ${error}`);
  }
}

module.exports = { sendMail };
END: sendMail.js

====================
üìÑ Fil: bookings/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-26 13:46:22
üìè Antal rader: 284
üß© Antal funktioner: 3
üí¨ Kommentarst√§ckning: 7 rader (2.5%)
üì• Imports: 7 ‚Äì ["const { getSettings } = require('../shared/config/settingsLoader');", "const pool = require('../shared/db/pgPool');", "const { v4: uuidv4 } = require('uuid');", "const { createDebugLogger } = require('../shared/utils/debugLogger');", "const graphClient = require('../shared/calendar/msGraph')();", "const createZoomClient = require('../shared/calendar/zoomClient');", "const { sendMail } = require('../shared/notification/sendMail');"]
üîç L√§ngsta funktion: 6 rader
üß† Komplexitetspo√§ng: 25
üß™ TODO/FIXME: 0
====================
START: index.js
const { getSettings } = require('../shared/config/settingsLoader');
const pool = require('../shared/db/pgPool');
const { v4: uuidv4 } = require('uuid');
const { createDebugLogger } = require('../shared/utils/debugLogger');
const graphClient = require('../shared/calendar/msGraph')();
const createZoomClient = require('../shared/calendar/zoomClient');
const zoomClient = createZoomClient();
const { sendMail } = require('../shared/notification/sendMail');

module.exports = async function (context, req) {
  context.log('üì• bookings/index.js startar');
  const requiredFields = ['meeting_type', 'meeting_length', 'slot_iso'];
  context.log('üîç req.body:', req.body);
  const missing = requiredFields.filter(k => !req.body?.[k]);
  context.log('üîç Saknade f√§lt:', missing);

  if (missing.length > 0) {
    context.log('‚ùå Avbryter pga saknade f√§lt');
    context.res = { status: 400, body: { error: `Missing fields: ${missing.join(', ')}` } };
    return;
  }

  const { email, meeting_type, meeting_length, slot_iso, contact_id, metadata = {} } = req.body;

  const parsedLength = parseInt(meeting_length, 10);
  if (isNaN(parsedLength) || parsedLength <= 0) {
    context.log('‚ùå Ogiltig m√∂tesl√§ngd:', meeting_length);
    context.res = { status: 400, body: { error: "Invalid meeting_length" } };
    return;
  }

  const parsedStart = new Date(slot_iso);
  if (isNaN(parsedStart.getTime())) {
    context.log('‚ùå Ogiltigt slot_iso:', slot_iso);
    context.res = { status: 400, body: { error: "Invalid slot_iso datetime" } };
    return;
  }

  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.log('‚ùå Saknar env:', key);
      context.res = { status: 500, body: { error: `Missing environment variable: ${key}` } };
      return;
    }
  }

  const db = await pool.connect();
  const debugHelper = createDebugLogger(context);
  const debugLog = debugHelper.debugLog;
  debugLog("üß† debugLogger aktiv ‚Äì DEBUG=" + process.env.DEBUG);
  try {
    // L√§s in booking_settings
    const settings = await getSettings(context);

    const id = uuidv4();
    // Kontrollera om en bokning redan finns
    const existing = await db.query(
      'SELECT id FROM bookings WHERE contact_id = $1 AND start_time = $2',
      [contact_id || null, parsedStart.toISOString()]
    );
    if (existing.rowCount > 0) {
      context.res = {
        status: 409,
        body: { error: 'Booking already exists for this time.' }
      };
      return;
    }
    const startTime = parsedStart;
    const endTime = new Date(startTime.getTime() + parsedLength * 60000);
    const created_at = new Date();
    const updated_at = created_at;


    metadata.meeting_length = meeting_length;

    let online_link = null;
    if (meeting_type.toLowerCase() === 'teams' && contact_id && email) {
      const subject = metadata.subject || settings.default_meeting_subject || 'M√∂te';
      const location = metadata.location || 'Online';
      try {
        const eventResult = await graphClient.createEvent({
          start: startTime.toISOString(),
          end: endTime.toISOString(),
          subject,
          location,
          attendees: [email]
        });
        if (!eventResult) {
          context.log("‚ö†Ô∏è createEvent returnerade null");
        } else {
          debugLog("üì® createEvent respons fr√•n Graph:", JSON.stringify(eventResult, null, 2));
        }
        if (eventResult?.onlineMeetingUrl) {
          online_link = eventResult.onlineMeetingUrl;
          metadata.online_link = online_link;
          metadata.subject = eventResult.subject || subject || settings.default_meeting_subject || 'M√∂te';
          metadata.location = eventResult.location || location || 'Online';
        }

        // Extrahera m√∂tesinfo fr√•n bodyPreview oavsett joinUrl
        const body = eventResult?.body?.content || '';
        const idMatch = body.match(/M√∂tes-ID:\s*(\d[\d\s]*)/);
        const pwMatch = body.match(/L√∂senord:\s*([A-Za-z0-9]+)/);

        if (idMatch) metadata.meeting_id = idMatch[1].trim();
        if (pwMatch) metadata.passcode = pwMatch[1].trim();
        if (body && !eventResult?.onlineMeetingUrl) {
          metadata.body_preview = body;
        }

        fields.synced_to_calendar = true;
      } catch (err) {
        debugLog('‚ö†Ô∏è createEvent misslyckades: ' + err.message);
        debugLog("‚ùå Detaljerat fel fr√•n createEvent:", err);
      }
    } else if (meeting_type.toLowerCase() === 'zoom') {
      try {
        const result = await zoomClient.createMeeting({
          topic: metadata.subject || settings.default_meeting_subject,
          start: startTime.toISOString(),
          duration: parsedLength
        });
        online_link = result.join_url;
        metadata.online_link = online_link;
        metadata.meeting_id = result.id;
        metadata.subject = result.topic;
        metadata.location = 'Online';

        // Generate email subject and body using settings and injected online_link
        const emailTemplate = settings.email_invite_template || {};
        const emailSubject =
          (emailTemplate.subject
            ? emailTemplate.subject.replace('{{company}}', metadata.company || 'din organisation')
            : 'M√∂te');
        const emailBody =
          (emailTemplate.body
            ? emailTemplate.body
                .replace('{{first_name}}', metadata.first_name || '')
                .replace('{{company}}', metadata.company || '')
                .concat(`\n\nüîó Zoom-l√§nk: ${online_link}`)
            : `Hej!\n\nH√§r kommer Zoom-l√§nken till v√•rt m√∂te:\n${online_link}`);

        // Skicka e-post via Graph (placeholder ‚Äì implementera din mailfunktion)
        try {
          await sendMail({
            to: email,
            subject: emailSubject,
            body: emailBody,
          });
          debugLog('‚úÖ Zoominbjudan skickad via e-post');
          debugLog(`üîó L√§nk som skickades: ${online_link}`);
        } catch (emailErr) {
          debugLog('‚ö†Ô∏è Misslyckades skicka e-post f√∂r Zoom:', emailErr.message);
        }

        fields.synced_to_calendar = true;
      } catch (err) {
        debugLog('‚ö†Ô∏è Zoom createMeeting failed:', err.message);
      }
    } else if (meeting_type.toLowerCase() === 'facetime') {
      if (metadata.phone) {
        online_link = `facetime:${metadata.phone}`;
        metadata.online_link = online_link;
        metadata.subject = metadata.subject || settings.default_meeting_subject || 'FaceTime';
        metadata.location = metadata.location || 'FaceTime';

        try {
          const emailTemplate = settings.email_invite_template || {};
          const emailSubject = emailTemplate.subject?.replace('{{company}}', metadata.company || 'din organisation') || 'FaceTime-m√∂te';
          const emailBody = `${emailTemplate.body?.replace('{{first_name}}', metadata.first_name || '').replace('{{company}}', metadata.company || '') || ''}\n\nüîó FaceTime-l√§nk: ${online_link}`;

          await sendMail({ to: email, subject: emailSubject, body: emailBody });
          debugLog('‚úÖ FaceTime-inbjudan skickad via e-post');
          debugLog(`üîó L√§nk som skickades: ${online_link}`);
        } catch (emailErr) {
          debugLog('‚ö†Ô∏è Misslyckades skicka e-post f√∂r FaceTime:', emailErr.message);
        }
      } else {
        debugLog('‚ö†Ô∏è Saknar telefonnummer f√∂r FaceTime ‚Äì ingen l√§nk skapad');
      }
    } else if (meeting_type.toLowerCase() === 'atclient') {
      metadata.location = metadata.location || metadata.address || settings.default_home_address || 'Hos kund';
      metadata.subject = metadata.subject || settings.default_meeting_subject || 'M√∂te hos kund';

      try {
        const emailTemplate = settings.email_invite_template || {};
        const emailSubject = emailTemplate.subject?.replace('{{company}}', metadata.company || 'din organisation') || 'M√∂te hos kund';
        const emailBody = `${emailTemplate.body?.replace('{{first_name}}', metadata.first_name || '').replace('{{company}}', metadata.company || '') || ''}\n\nüìç Adress: ${metadata.location}`;

        await sendMail({ to: email, subject: emailSubject, body: emailBody });
        debugLog('‚úÖ atClient-inbjudan skickad via e-post');
        debugLog(`üîó L√§nk som skickades: ${online_link}`);
      } catch (emailErr) {
        debugLog('‚ö†Ô∏è Misslyckades skicka e-post f√∂r atClient:', emailErr.message);
      }
    } else if (meeting_type.toLowerCase() === 'atoffice') {
      metadata.location = metadata.location || settings.default_office_address || 'Kontoret';
      metadata.subject = metadata.subject || settings.default_meeting_subject || 'M√∂te p√• kontoret';

      try {
        const emailTemplate = settings.email_invite_template || {};
        const emailSubject = emailTemplate.subject?.replace('{{company}}', metadata.company || 'din organisation') || 'M√∂te p√• kontoret';
        const emailBody = `${emailTemplate.body?.replace('{{first_name}}', metadata.first_name || '').replace('{{company}}', metadata.company || '') || ''}\n\nüìç Plats: ${metadata.location}`;

        await sendMail({ to: email, subject: emailSubject, body: emailBody });
        debugLog('‚úÖ atOffice-inbjudan skickad via e-post');
        debugLog(`üîó L√§nk som skickades: ${online_link}`);
      } catch (emailErr) {
        debugLog('‚ö†Ô∏è Misslyckades skicka e-post f√∂r atOffice:', emailErr.message);
      }
    }

    const fields = {
      id,
      start_time: startTime.toISOString(),
      end_time: endTime.toISOString(),
      meeting_type,
      metadata: metadata,
      created_at,
      updated_at,
      contact_id: contact_id || null,
      booking_email: email || null
    };

    const query = `
      INSERT INTO bookings (
        id, start_time, end_time, meeting_type,
        metadata, created_at, updated_at,
        contact_id, booking_email
      ) VALUES (
        $1, $2, $3, $4,
        $5, $6, $7,
        $8, $9
      )
    `;

    const values = Object.values(fields);
    await db.query(query, values);
    // Logga pending change f√∂r denna bokning
    await db.query(
      `INSERT INTO pending_changes (id, table_name, record_id, change_type, direction, processed, created_at, booking_id)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        uuidv4(),
        'bookings',
        id,
        'INSERT',
        'cloud_to_local',
        false,
        new Date(),
        id
      ]
    );
    // Simulera att kalendern synkades f√∂r denna demo
    await db.query(
      'INSERT INTO event_log (event_type, booking_id) VALUES ($1, $2)',
      ['booking_created', id]
    );
    debugLog(`‚úÖ Bokning skapad: ${id}, typ: ${meeting_type}, l√§ngd: ${meeting_length}`);

    context.res = {
      status: 200,
      body: {
        status: 'booked',
        booking_id: id,
        calendar_invite_sent: !!online_link
      }
    };
  } catch (err) {
    context.log.error("‚ùå Booking error:", err.message);
    context.log.error("‚ùå Fullt felobjekt:", err);
    context.res = {
      status: 500,
      body: {
        error: err.message,
        stack: err.stack,
        full: JSON.stringify(err, Object.getOwnPropertyNames(err))
      }
    };
  } finally {
    db.release();
  }
};
END: index.js

====================
üìÑ Fil: shared/utils/debugLogger.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-20 12:16:50
üìè Antal rader: 23
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 8 rader
üß† Komplexitetspo√§ng: 2
üß™ TODO/FIXME: 0
====================
START: debugLogger.js
console.log("üß™ debugLogger.js laddades");

function createDebugLogger(context) {
  const isDebug = process.env.DEBUG === 'true';
  const skipReasons = {};

  const debugLog = (msg) => {
    if (msg.startsWith('‚õî') || msg.startsWith('üçΩÔ∏è') || msg.startsWith('üìõ')) {
      const reason = msg.split(' ‚Äì ')[0];
      skipReasons[reason] = (skipReasons[reason] || 0) + 1;
    }
    if (isDebug && context?.log) {
      context.log(msg);
    }
  };

  return {
    debugLog,
    getSkipSummary: () => skipReasons
  };
}

module.exports = { createDebugLogger };
END: debugLogger.js

====================
üìÑ Fil: shared/slots/slotEngine.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-26 14:54:05
üìè Antal rader: 312
üß© Antal funktioner: 4
üí¨ Kommentarst√§ckning: 8 rader (2.6%)
üì• Imports: 6 ‚Äì ["const pool = require('../db/pgPool');", 'const { DateTime } = require("luxon");', 'const { resolveOriginAddress } = require("../calendar/resolveOrigin");', 'const { resolveTravelTime } = require("../maps/resolveTravelTime");', 'const msGraph = require("../calendar/msGraph");', 'const appleCalendar = require("../calendar/appleCalendar");']
üîç L√§ngsta funktion: 14 rader
üß† Komplexitetspo√§ng: 37
üß™ TODO/FIXME: 0
====================
START: slotEngine.js
console.log("üß™ slotEngine.js laddades");

const pool = require('../db/pgPool');

const { DateTime } = require("luxon");
const { resolveOriginAddress } = require("../calendar/resolveOrigin");
const { resolveTravelTime } = require("../maps/resolveTravelTime");
const msGraph = require("../calendar/msGraph");
const appleCalendar = require("../calendar/appleCalendar");

async function generateSlotCandidates({ day, settings, contact, pool, context, graphClient, appleClient, meeting_length, meeting_type, eventCache }) {
  const timezone = settings.timezone || "Europe/Stockholm";
  const hoursToTry = [8, 12]; // UTC ‚Üí 10:00 och 14:00 svensk tid
  const slots = [];

  for (const hour of hoursToTry) {
    const eventId = `${day}T${hour.toString().padStart(2, "0")}:00:00.000Z`;
    const dateObj = new Date(eventId);
    const weekday = dateObj.toLocaleDateString("en-US", { weekday: "long", timeZone: timezone }).toLowerCase();
    const slot_part = hour < 12 ? "fm" : "em";
    const slotHourStr = `${hour.toString().padStart(2, '0')}:00`;
    if (slotHourStr >= settings.lunch_start && slotHourStr < settings.lunch_end) {
      context.log(`üçΩÔ∏è Slot under lunch (${slotHourStr}) ‚Äì hoppar ${eventId}`);
      continue;
    }
    const isWeekend = ["saturday", "sunday"].includes(weekday);
    if (settings.block_weekends && isWeekend) {
      context.log(`‚õî Helg blockerad (${weekday}) ‚Äì hoppar ${eventId}`);
      continue;
    }
    if (meeting_type === 'atclient' && Array.isArray(settings.allowed_atclient_meeting_days)) {
      if (!settings.allowed_atclient_meeting_days.includes(weekday)) {
        context.log(`‚õî atclient till√•ts ej p√• ${weekday} ‚Äì hoppar ${eventId}`);
        continue;
      }
    }

    context.log(`üìß resolveOriginAddress anv√§nder settings.ms_sender_email (MS) och CALDAV_USER (Apple) ‚Äì calendarId s√§tts till 'system' som placeholder`);
    const originInfo = await resolveOriginAddress({
      eventId,
      calendarId: 'system',
      pool,
      context,
      graphClient,
      appleClient,
      fallbackOrigin: settings.default_home_address,
      settings,
      eventCache
    });

    if (!originInfo?.origin) {
      context.log(`‚ö†Ô∏è Kunde inte fastst√§lla origin f√∂r ${eventId}`);
      continue;
    }

    const destination = settings.default_office_address;
    const { travelTimeMin } = await resolveTravelTime({
      origin: originInfo.origin,
      destination,
      hour,
      db: pool,
      accessToken: context.accessToken || null,
      context
    });

    if (!travelTimeMin || typeof travelTimeMin !== "number") {
      context.log.warn(`‚ö†Ô∏è Ogiltig restid, hoppar slot: ${eventId}`);
      continue;
    }

    const endTime = new Date(dateObj.getTime() + meeting_length * 60000);
    const dayStart = new Date(dateObj);
    const dayEnd = new Date(dateObj);
    dayStart.setHours(parseInt(settings.open_time.split(':')[0], 10), parseInt(settings.open_time.split(':')[1], 10));
    dayEnd.setHours(parseInt(settings.close_time.split(':')[0], 10), parseInt(settings.close_time.split(':')[1], 10));

    if (endTime > dayEnd) {
      context.log(`‚õî Slot ${eventId} g√•r utanf√∂r √∂ppettid (${settings.close_time}) ‚Äì hoppar`);
      continue;
    }

    // Skip slots that are too soon to reach based on travel time and current time
    const now = Date.now();
    if (dateObj.getTime() - now < travelTimeMin * 60 * 1000) {
      context.log(`‚õî Slot ${eventId} √§r f√∂r n√§ra i tid ‚Äì restid ${travelTimeMin} min, nu=${new Date(now).toISOString()} ‚Äì hoppar`);
      continue;
    }

    // Build slot object
    const slot = {
      slot_iso: eventId,
      slot_local: DateTime.fromJSDate(dateObj).setZone(timezone).toISO(),
      travel_time_min: travelTimeMin,
      origin: originInfo.origin,
      originEndTime: originInfo.originEndTime,
      source: originInfo.originSource,
      require_approval: settings.require_approval,
      meeting_length,
      weekday,
      slot_part
    };

    // --- Score calculation logic ---
    // Anv√§nd context.bookingsByDay som k√§lla till befintliga bokningar per dag
    const bookingsByDay = (typeof context.bookingsByDay === "object" && context.bookingsByDay) ? context.bookingsByDay : {};
    const slotDateIso = dateObj.toISOString().split("T")[0];
    const slotStart = dateObj.getTime();
    const slotEnd = slotStart + meeting_length * 60000;

    const existing = bookingsByDay[slotDateIso] || [];
    let gapBefore = null;
    let gapAfter = null;

    for (const b of existing) {
      const bStart = b.start;
      const bEnd = b.end;

      if (bEnd <= slotStart) {
        gapBefore = slotStart - bEnd;
      } else if (bStart >= slotEnd && gapAfter === null) {
        gapAfter = bStart - slotEnd;
      }
    }

    const bufferMs = (settings.buffer_between_meetings || 0) * 60000;
    const hasConflict = existing.some(b => {
      return (
        b.start < slotEnd + bufferMs &&
        b.end > slotStart - bufferMs
      );
    });
    if (hasConflict) {
      context.log(`‚õî Slot ${eventId} krockar med m√∂te inom buffer ‚Äì hoppar`);
      continue;
    }

    // Standardpo√§ng √§r 10. Dra av po√§ng f√∂r stor lucka f√∂re eller efter.
    let fragmentationPenalty = 0;
    if ((gapBefore && gapBefore > 45 * 60000) || (gapAfter && gapAfter > 45 * 60000)) {
      fragmentationPenalty = 1;
    }

    slot.score = 10 - fragmentationPenalty;

    slots.push(slot);
  }

  return slots;
}


async function generateSlotChunks({
  days,
  context,
  contact,
  contact_id,
  meeting_type,
  meeting_length,
  bookingsByDay,
  weeklyMinutesByType,
  settings,
  graphClient,
  appleClient,
  travelCache,
  accessToken,
  timezone,
  debugHelper
}) {
  const { debugLog, skipReasons } = debugHelper || {};
  const chosen = [];

  if (days.length === 0) {
    const fallbackDate = new Date().toISOString().split('T')[0];
    const { rows } = await pool.query(
      'SELECT slots FROM slot_cache WHERE slot_day = $1 LIMIT 1',
      [fallbackDate]
    );
    if (rows.length > 0) {
      context.log(`üü° Anv√§nder slot_cache som fallback (${fallbackDate})`);
      return {
        chosenSlots: rows[0].slots || [],
        slotMapResult: {},
        slotLogSummary: { 'fallback_used': 1 }
      };
    }
  }

  const eventCache = new Map();

  // === L√ÑGG TILL EXTERNA BOKNINGAR (MS + Apple) I bookingsByDay ===
  const startIso = days[0].toISOString();
  const endIso = new Date(days[days.length - 1].getTime() + 86400000).toISOString(); // +1 dag

  // Microsoft Graph
  try {
    const msEvents = await graphClient.listUpcomingEvents?.(days.length + 1) || [];
    let msAddedCount = 0;
    for (const ev of msEvents) {
      const start = new Date(ev.start).getTime();
      const end = new Date(ev.end).getTime();
      if (isNaN(start) || isNaN(end)) continue;
      const date = new Date(ev.start).toISOString().split("T")[0];
      if (!bookingsByDay[date]) bookingsByDay[date] = [];
      bookingsByDay[date].push({ start, end });
      msAddedCount++;
    }
    context.log(`üìÜ MS Graph: ${msEvents.length} h√§ndelser analyserades, ${msAddedCount} lades till bookingsByDay`);
    context.log("üìã MS Graph ‚Äì alla h√§ndelser:");
    for (const ev of msEvents) {
      context.log(`  ‚Ä¢ ${ev.subject || '(utan titel)'}: ${ev.start} ‚Üí ${ev.end}`);
    }
  } catch (err) {
    context.log(`‚ö†Ô∏è Kunde inte ladda MS-bokningar: ${err.message}`);
  }

  // Apple Calendar
  try {
    const appleEvents = await appleClient.fetchEventsByDateRange?.(startIso, endIso) || [];
    let appleAddedCount = 0;
    for (const ev of appleEvents) {
      try {
        const start = new Date(ev.dtstart).getTime();
        const end = new Date(ev.dtend).getTime();
        if (isNaN(start) || isNaN(end)) continue;
        const date = new Date(ev.dtstart).toISOString().split("T")[0];
        if (!bookingsByDay[date]) bookingsByDay[date] = [];
        bookingsByDay[date].push({ start, end });
        appleAddedCount++;
      } catch (err) {
        context.log(`‚ö†Ô∏è Apple event parsing error: ${err.message}`);
      }
    }
    context.log(`üçè Apple Calendar: ${appleEvents.length} h√§ndelser analyserades`);
    context.log("üìã Apple Calendar ‚Äì alla h√§ndelser:");
    for (const ev of appleEvents) {
      context.log(`  ‚Ä¢ ${ev.summary || '(utan titel)'}: ${ev.dtstart} ‚Üí ${ev.dtend}`);
    }
  } catch (err) {
    context.log(`‚ö†Ô∏è Kunde inte ladda Apple-bokningar: ${err.message}`);
  }

  context.bookingsByDay = bookingsByDay;

  const slotCandidatePromises = days.map(day => {
    const dayStr = day.toISOString().split("T")[0];
    return generateSlotCandidates({
      day: dayStr,
      settings,
      contact,
      pool: context.client || pool,
      context,
      graphClient,
      appleClient,
      meeting_length,
      meeting_type,
      eventCache
    });
  });

  const slotCandidatesPerDay = await Promise.all(slotCandidatePromises);

  const slotMap = {};
  days.forEach((day, index) => {
    const dayStr = day.toISOString().split("T")[0];
    const slotCandidates = slotCandidatesPerDay[index];
    for (const slot of slotCandidates) {
      const key = `${dayStr}_${slot.slot_part}`;
      if (!slotMap[key]) slotMap[key] = [];
      slotMap[key].push(slot);
    }
  });

  const bestPerGroup = {};
  for (const [key, slots] of Object.entries(slotMap)) {
    if (slots.length === 0) continue;
    const [datePart, part] = key.split('_');
    if (!bestPerGroup[datePart]) bestPerGroup[datePart] = {};
    if (!bestPerGroup[datePart][part]) {
      bestPerGroup[datePart][part] = slots
        .sort((a, b) => {
          if ((b.score || 0) !== (a.score || 0)) return (b.score || 0) - (a.score || 0);
          return new Date(a.slot_iso) - new Date(b.slot_iso);
        })[0];
    }
  }

  for (const day in bestPerGroup) {
    for (const part in bestPerGroup[day]) {
      const slot = bestPerGroup[day][part];
      const weekKeyStr = day;
      const usedMinutes = (weeklyMinutesByType[meeting_type]?.[weekKeyStr] || 0);
      if (usedMinutes + slot.meeting_length <= settings.max_weekly_booking_minutes) {
        chosen.push(slot);
      } else {
        debugLog?.(`‚õî √ñverskrider veckokvot (${usedMinutes + slot.meeting_length} > ${settings.max_weekly_booking_minutes}) ‚Äì hoppar ${day}_${part}`);
      }
    }
  }

  const durationMs = Date.now() - context.startTime;
  context.log(`‚è±Ô∏è Slotgenerering klar p√• ${durationMs} ms`);
  return {
    chosenSlots: chosen.sort((a, b) => new Date(a.slot_iso) - new Date(b.slot_iso)),
    slotMapResult: slotMap,
    slotLogSummary: skipReasons
  };
}

module.exports = {
  generateSlotCandidates,
  generateSlotChunks
};
END: slotEngine.js

====================
üìÑ Fil: sync_from_cloud.py
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üêç Python
üìÖ Senast √§ndrad: 2025-05-15 18:23:27
üìè Antal rader: 141
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ['import psycopg2', 'import json']
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 28
üß™ TODO/FIXME: 0
====================
START: sync_from_cloud.py
import psycopg2
import json
from config import LOCAL_DB_CONFIG, REMOTE_DB_CONFIG

def connect_db(config):
    return psycopg2.connect(**config)

def apply_change(cur, table, operation, payload):
    if operation == "INSERT":
        cols = ", ".join(payload.keys())
        placeholders = ", ".join(["%s"] * len(payload))
        sql = f"INSERT INTO {table} ({cols}) VALUES ({placeholders}) ON CONFLICT (id) DO NOTHING"
        cur.execute(sql, [json.dumps(v) if isinstance(v, dict) else v for v in payload.values()])
    elif operation == "UPDATE":
        if table == "contact" and "metadata" in payload:
            local_meta = payload["metadata"]
            if isinstance(local_meta, str):
                local_meta = json.loads(local_meta)
            cur.execute("SELECT metadata FROM contact WHERE id = %s", (payload["id"],))
            row = cur.fetchone()
            if row:
                remote_meta = row[0]
                if isinstance(remote_meta, str):
                    remote_meta = json.loads(remote_meta)
                if remote_meta == local_meta:
                    print(f"‚ôªÔ∏è Ingen skillnad i metadata f√∂r {payload['id']}, hoppar UPDATE och markerar som klar.")
                    return
        sets = ", ".join([f"{col} = %s" for col in payload if col != "id"])
        values = [json.dumps(payload[col]) if isinstance(payload[col], dict) else payload[col] for col in payload if col != "id"]
        values.append(payload["id"])
        sql = f"UPDATE {table} SET {sets} WHERE id = %s"
        cur.execute(sql, values)
        cur.execute("SELECT metadata, updated_at FROM contact WHERE id = %s", [payload["id"]])
        updated_row = cur.fetchone()
        if updated_row:
            try:
                metadata = updated_row[0]
                if isinstance(metadata, str):
                    metadata = json.loads(metadata)
                address = metadata.get("address", "(ingen adress)")
            except Exception:
                address = "(kunde inte tolkas)"
            print(f"üßæ Efter UPDATE: {payload['id']} ‚Üí {address} @ {updated_row[1]}")
        else:
            print(f"‚ö†Ô∏è UPDATE-verifiering misslyckades: Inget resultat f√∂r {payload['id']}")
    elif operation == "DELETE":
        sql = f"DELETE FROM {table} WHERE id = %s"
        cur.execute(sql, [payload["id"]])

def sync():
    remote_conn = connect_db(REMOTE_DB_CONFIG)
    remote_cur = remote_conn.cursor()

    local_conn = connect_db(LOCAL_DB_CONFIG)
    local_cur = local_conn.cursor()

    remote_cur.execute("""
        SELECT id, table_name, record_id, operation, payload
        FROM (
            SELECT *, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
            FROM pending_changes
            WHERE direction = 'out' AND processed = false
              AND table_name IN ('contact', 'bookings')
        ) sub
        WHERE rn = 1
        ORDER BY created_at ASC, id
    """)
    rows = remote_cur.fetchall()

    remote_cur.execute("""
        DELETE FROM pending_changes
        WHERE id NOT IN (
            SELECT id FROM (
                SELECT id, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
                FROM pending_changes
                WHERE direction = 'out' AND processed = false
            ) sub
            WHERE rn = 1
        ) AND direction = 'out' AND processed = false AND operation = 'UPDATE';
    """)

    seen_record_ids = set()
    for row in rows:
        try:
            payload_preview = row[4] if isinstance(row[4], dict) else json.loads(row[4])
            rid = payload_preview.get("id")
            email = payload_preview.get("booking_email", "ok√§nd e-post")
            seen_record_ids.add(rid)
        except Exception as e:
            pass
    count = 0
    for row in rows:
        change_id, table, record_id, operation, payload_json = row
        try:
            payload = payload_json if isinstance(payload_json, dict) else json.loads(payload_json)
            if not isinstance(payload.get("id"), str) or "your-generated-id" in payload.get("id"):
                continue
            apply_change(local_cur, table, operation, payload)
            if table == "bookings" and operation == "INSERT":
                local_cur.execute(
                    """
                    UPDATE pending_changes
                    SET booking_id = %s
                    WHERE record_id = %s AND table_name = 'bookings' AND booking_id IS NULL
                    """,
                    (record_id, record_id)
                )
                local_conn.commit()
            if table == "contact":
                email = payload.get("booking_email", "(ok√§nd e-post)")
                meta = payload.get("metadata")
                if isinstance(meta, str):
                    try:
                        meta = json.loads(meta)
                    except Exception:
                        meta = {}
                elif not isinstance(meta, dict):
                    meta = {}
                address = meta.get("address", "(ok√§nd adress)")
                print(f"üì• Importerad kontakt: {email} ‚Üí {address}")
            if table == "bookings" and operation == "INSERT":
                pass  # Notis borttagen
            local_cur.execute("""
                INSERT INTO event_log (id, source, event_type, payload, received_at)
                VALUES (gen_random_uuid(), %s, %s, %s, now())
            """, ('sync', f"{operation.lower()}_{table}", json.dumps(payload)))
            remote_cur.execute("UPDATE pending_changes SET processed = true WHERE id = %s", [change_id])
            remote_conn.commit()
            count += 1
        except Exception as e:
            print(f"‚ùå Fel vid synk f√∂r {table} (id={change_id}): {e}")
            continue

    local_conn.commit()
    local_cur.close()
    remote_cur.close()
    local_conn.close()
    remote_conn.close()

if __name__ == "__main__":
    sync()
END: sync_from_cloud.py

====================
üìÑ Fil: sync_to_cloud.py
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üêç Python
üìÖ Senast √§ndrad: 2025-05-15 18:23:01
üìè Antal rader: 211
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 3 ‚Äì ['import psycopg2', 'import json', 'import traceback']
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 41
üß™ TODO/FIXME: 0
====================
START: sync_to_cloud.py
import psycopg2
import json
from datetime import datetime, timezone
from config import LOCAL_DB_CONFIG, REMOTE_DB_CONFIG

def connect_db(config):
    return psycopg2.connect(**config)

def fetch_pending_changes(conn):
    with conn.cursor() as cur:
        cur.execute("""
            SELECT id, table_name, record_id, operation, payload
            FROM (
                SELECT *, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
                FROM pending_changes
                WHERE direction = 'out' AND processed = false
                  AND table_name IN ('contact', 'bookings')
            ) sub
            WHERE rn = 1
            ORDER BY created_at ASC, id
        """)
        rows = cur.fetchall()

        # Rensa √§ldre UPDATE-poster med samma record_id
        cur.execute("""
            DELETE FROM pending_changes
            WHERE id NOT IN (
                SELECT id FROM (
                    SELECT id, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
                    FROM pending_changes
                    WHERE direction = 'out' AND processed = false
                ) sub
                WHERE rn = 1
            ) AND direction = 'out' AND processed = false AND operation = 'UPDATE';
        """)
        return rows

def mark_as_processed(conn, change_id):
    with conn.cursor() as cur:
        cur.execute("UPDATE pending_changes SET processed = true WHERE id = %s", (change_id,))
        conn.commit()

#
# üìù SYNC-BETEENDE: Hantering av metadata
#
# Viktigt att f√∂rst√• skillnaden:
#
# 1. √Ñndring av v√§rde:
#    - Exempel: "postal_code": "111 11" ‚Üí "115 32"
#    - Hanteras som en vanlig UPDATE (om updated_at √§r nyare)
#
# 2. √Ñndring av nyckel (etikett):
#    - Exempel: "postal_number" ‚Üí "postal_code"
#    - Molnet kommer *inte* ta bort "postal_number" utan force_resync
#    - L√§gg till `"force_resync": true` i metadata f√∂r att tvinga full √∂verskrivning
#
# Detta minskar risken att data i molnet raderas av misstag.

def apply_change(conn, change, local_conn):
    table_name, record_id, operation, payload = change[1], change[2], change[3], change[4]
    with conn.cursor() as cur:
        data = json.loads(payload) if isinstance(payload, str) else payload

        # Skip contact records with metadata.origin != 'klrab.se'
        if table_name == 'contact' and 'metadata' in data:
            meta = json.loads(data['metadata']) if isinstance(data['metadata'], str) else data['metadata']
            if meta.get('origin') != 'klrab.se':
                print(f"‚ö†Ô∏è Skickas ej: origin != klrab.se ‚Äì {data.get('booking_email')}")
                mark_as_processed(local_conn, change[0])
                return

        # Ensure all values are serializable to SQL
        for k, v in data.items():
            if isinstance(v, dict):
                data[k] = json.dumps(v)

        if 'updated_at' in data:
            if isinstance(data['updated_at'], str):
                # Parse and convert to UTC if it's a string
                try:
                    dt = datetime.fromisoformat(data['updated_at'])
                    data['updated_at'] = dt.astimezone(timezone.utc).isoformat()
                except Exception as e:
                    print(f"‚ö†Ô∏è Kunde inte tolka updated_at: {data['updated_at']} ({e})")
            elif isinstance(data['updated_at'], datetime):
                data['updated_at'] = data['updated_at'].astimezone(timezone.utc).isoformat()

        if operation == 'INSERT':
            columns = ', '.join(data.keys())
            placeholders = ', '.join(['%s'] * len(data))
            values = list(data.values())
            cur.execute(
                f"INSERT INTO {table_name} ({columns}) VALUES ({placeholders}) "
                f"ON CONFLICT (id) DO UPDATE SET "
                f"{', '.join([f'{k} = EXCLUDED.{k}' for k in data.keys() if k != 'id'])}",
                values
            )
            if table_name == 'bookings':
                with local_conn.cursor() as local_cur:
                    local_cur.execute(
                        """
                        UPDATE pending_changes
                        SET booking_id = %s
                        WHERE record_id = %s AND table_name = 'bookings' AND booking_id IS NULL
                        """,
                        (record_id, record_id)
                    )
                    local_conn.commit()
        if 'metadata' in data and table_name == 'contact':
            # Merge metadata with existing remote value and ensure JSON string
            cur.execute(f"SELECT metadata FROM {table_name} WHERE id = %s", (record_id,))
            row = cur.fetchone()
            if row and row[0]:
                if isinstance(row[0], dict):
                    existing_metadata = row[0]
                else:
                    existing_metadata = json.loads(row[0])
            else:
                existing_metadata = {}

            incoming_metadata = json.loads(data['metadata']) if isinstance(data['metadata'], str) else data['metadata']
            if existing_metadata == incoming_metadata:
                mark_as_processed(local_conn, change[0])
                return
            existing_metadata.update(incoming_metadata)
            changed_keys = [k for k in incoming_metadata if existing_metadata.get(k) != incoming_metadata[k]]
            if not changed_keys:
                mark_as_processed(local_conn, change[0])
                return
            data['metadata'] = json.dumps(existing_metadata)

        if operation == 'UPDATE':
            # F√∂rb√§ttrad hantering av tidsj√§mf√∂relse f√∂r updated_at
            if 'updated_at' in data:
                try:
                    # S√§kerst√§ll att local_ts √§r datetime i UTC
                    local_ts = data['updated_at']
                    if isinstance(local_ts, str):
                        local_ts = datetime.fromisoformat(local_ts)
                    if local_ts.tzinfo is None:
                        local_ts = local_ts.replace(tzinfo=timezone.utc)
                    else:
                        local_ts = local_ts.astimezone(timezone.utc)

                    cur.execute(f"SELECT updated_at FROM {table_name} WHERE id = %s", (record_id,))
                    row = cur.fetchone()
                    if row and row[0] and isinstance(row[0], datetime):
                        remote_ts = row[0]
                        if remote_ts.tzinfo is None:
                            remote_ts = remote_ts.replace(tzinfo=timezone.utc)
                        else:
                            remote_ts = remote_ts.astimezone(timezone.utc)

                        if local_ts <= remote_ts:
                            mark_as_processed(local_conn, change[0])
                            return
                except Exception:
                    pass

            if table_name == "contact" and "metadata" in data:
                local_meta = data["metadata"]
                if isinstance(local_meta, str):
                    local_meta = json.loads(local_meta)
                cur.execute("SELECT metadata FROM contact WHERE id = %s", (data["id"],))
                row = cur.fetchone()
                if row:
                    remote_meta = row[0]
                    if isinstance(remote_meta, str):
                        remote_meta = json.loads(remote_meta)
                    if remote_meta == local_meta:
                        mark_as_processed(local_conn, change[0])
                        return

            columns = ', '.join(data.keys())
            placeholders = ', '.join(['%s'] * len(data))
            values = list(data.values())
            update_keys = [k for k in data.keys() if k != 'id']
            update_set = ', '.join([f"{k} = %s" for k in update_keys])
            update_values = [data[k] for k in update_keys]
            update_values.append(record_id)
            cur.execute(
                f"UPDATE {table_name} SET {update_set} WHERE id = %s",
                update_values
            )
            cur.execute("SELECT metadata, updated_at FROM contact WHERE id = %s", [payload["id"]])
            updated_row = cur.fetchone()
        elif operation == 'DELETE':
            cur.execute(f"DELETE FROM {table_name} WHERE id = %s", (record_id,))
        conn.commit()
        mark_as_processed(local_conn, change[0])

def sync():
    import traceback
    local_conn = connect_db(LOCAL_DB_CONFIG)
    remote_conn = connect_db(REMOTE_DB_CONFIG)

    changes = fetch_pending_changes(local_conn)
    count = 0
    for change in changes:
        try:
            apply_change(remote_conn, change, local_conn)
            count += 1
        except Exception as e:
            print(f"‚ùå Misslyckades att applicera √§ndring p√• {change[1]} (id={change[2]}): {e}")
            traceback.print_exc()
    
    local_conn.close()
    remote_conn.close()

if __name__ == "__main__":
    sync()
END: sync_to_cloud.py

====================
üìÑ Fil: sync_static_tables.py
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üêç Python
üìÖ Senast √§ndrad: 2025-04-24 17:01:52
üìè Antal rader: 61
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ['import psycopg2', 'import json']
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 6
üß™ TODO/FIXME: 0
====================
START: sync_static_tables.py
from config import LOCAL_DB_CONFIG, REMOTE_DB_CONFIG
import psycopg2
import json
from datetime import datetime


TABLES = ["translation", "booking_settings"]


def connect_db(config):
    return psycopg2.connect(**config)


def fetch_all_from_local(conn, table):
    with conn.cursor() as cur:
        cur.execute(f"SELECT * FROM {table}")
        colnames = [desc[0] for desc in cur.description]
        rows = cur.fetchall()
        return colnames, rows


def clear_remote_table(conn, table):
    with conn.cursor() as cur:
        cur.execute(f"DELETE FROM {table}")
        conn.commit()


def insert_to_remote(conn, table, columns, rows):
    with conn.cursor() as cur:
        placeholders = ', '.join(['%s'] * len(columns))
        colnames = ', '.join(columns)
        for row in rows:
            # Hantera jsonb-v√§rden som json-str√§ngar
            formatted_row = []
            for i, col in enumerate(columns):
                value = row[i]
                if table == 'booking_settings' and col == 'value':
                    formatted_row.append(json.dumps(value))
                else:
                    formatted_row.append(value)
            cur.execute(f"INSERT INTO {table} ({colnames}) VALUES ({placeholders})", formatted_row)
        conn.commit()


def sync_static_tables():
    local_conn = connect_db(LOCAL_DB_CONFIG)
    remote_conn = connect_db(REMOTE_DB_CONFIG)

    for table in TABLES:
        print(f"\n‚è≥ Synkar tabell: {table}...")
        columns, rows = fetch_all_from_local(local_conn, table)
        clear_remote_table(remote_conn, table)
        insert_to_remote(remote_conn, table, columns, rows)
        print(f"‚úÖ Klar med tabell: {table} ({len(rows)} rader)")

    local_conn.close()
    remote_conn.close()


if __name__ == "__main__":
    sync_static_tables()

END: sync_static_tables.py

====================
üìÑ Fil: sync.py
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üêç Python
üìÖ Senast √§ndrad: 2025-05-14 15:43:17
üìè Antal rader: 82
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ['import psycopg2', 'import json']
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 10
üß™ TODO/FIXME: 0
====================
START: sync.py
import psycopg2
import json
from datetime import datetime
from config import LOCAL_DB_CONFIG

# Anslutning till lokal PostgreSQL
conn = psycopg2.connect(**LOCAL_DB_CONFIG)
cursor = conn.cursor()

# Rensa √§ldre UPDATE-rader (endast senaste beh√∂vs per record_id)
cursor.execute("""
    DELETE FROM pending_changes pc
    WHERE operation = 'UPDATE'
      AND processed = false
      AND direction = 'out'
      AND id NOT IN (
        SELECT id FROM (
          SELECT id,
                 ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at DESC) AS rn
          FROM pending_changes
          WHERE operation = 'UPDATE'
            AND processed = false
            AND direction = 'out'
        ) sub
        WHERE rn = 1
      );
""")

# H√§mta EN √§ndring per kontakt (record_id) ‚Äì endast senaste per kontakt exporteras med hj√§lp av ROW_NUMBER()
cursor.execute("""
    SELECT id, table_name, record_id, operation, payload, created_at
    FROM (
        SELECT *, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at DESC) as rn
        FROM pending_changes
        WHERE processed = false AND direction = 'out'
    ) sub
    WHERE rn = 1
""")

rows = cursor.fetchall()

# Filtrera bort poster d√§r metadata √§r identisk med befintlig kontakt
filtered_rows = []
for row in rows:
    change_id, table, record_id, operation, payload, created_at = row
    data = json.loads(payload) if isinstance(payload, str) else payload
    if table == "contact" and operation == "UPDATE":
        try:
            cursor.execute("SELECT metadata FROM contact WHERE id = %s", (record_id,))
            result = cursor.fetchone()
            if result:
                current_metadata = result[0] if isinstance(result[0], dict) else json.loads(result[0])
                incoming_metadata = data.get("metadata")
                if isinstance(incoming_metadata, str):
                    incoming_metadata = json.loads(incoming_metadata)
                if current_metadata == incoming_metadata:
                    continue
        except Exception as e:
            print(f"‚ö†Ô∏è Kunde inte j√§mf√∂ra metadata f√∂r {record_id}: {e}")
    filtered_rows.append(row)
rows = filtered_rows

# Skapa exportformat
export = []
for row in rows:
    change_id, table, record_id, operation, payload, created_at = row
    export.append({
        "change_id": str(change_id),
        "table": table,
        "operation": operation,
        "data": payload
    })

# Spara till JSON-fil med tidsst√§mpel
if export:
    first_type = export[0]["table"] if export else "unknown"
    filename = f"sync_outbox/{datetime.now().strftime('%Y%m%d_%H%M%S')}_{first_type}.json"
    with open(filename, "w", encoding="utf-8") as f:
        json.dump(export, f, indent=2, ensure_ascii=False)

cursor.close()
conn.close()

END: sync.py

====================
üìÑ Fil: sync_all.py
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üêç Python
üìÖ Senast √§ndrad: 2025-05-14 15:49:04
üìè Antal rader: 148
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 6 ‚Äì ['import os', 'import subprocess', 'import sys', 'import psycopg2', 'import socket', 'import traceback']
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 18
üß™ TODO/FIXME: 0
====================
START: sync_all.py
BASE = "/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot/macspot-api"

import os
import subprocess
from datetime import datetime
import sys
import psycopg2

log_dir = "/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot"
log_out = os.path.join(log_dir, "macspot_sync.log")
log_err = os.path.join(log_dir, "macspot_sync_error.log")

# Se till att loggfilerna existerar
for path in [log_out, log_err]:
    if not os.path.exists(path):
        with open(path, 'w'):
            pass

# Skriv ut manuell/automatisk k√∂rningsinfo till loggen
is_manual = sys.stdout.isatty()
sys.stdout = open(log_out, 'a')
sys.stderr = open(log_err, 'a')
if is_manual:
    print(f"üñêÔ∏è Manuell k√∂rning: {datetime.now().isoformat()}")
else:
    print(f"ü§ñ Automatisk k√∂rning via launchd: {datetime.now().isoformat()}")

def run_script(name, script_path):
    subprocess.run(["python", f"{BASE}/{script_path}"], check=True)

try:
    start_time = datetime.now()
    def is_database_online(host, port):
        import socket
        try:
            socket.create_connection((host, port), timeout=2)
            return True
        except:
            return False

    # Kontrollera att b√•da databaser √§r online innan sync startar
    if not is_database_online("localhost", 5433):
        print("‚ùå Lokal databas √§r inte tillg√§nglig (localhost:5433)")
        exit(1)

    if not is_database_online("macspotpg.postgres.database.azure.com", 5432):
        print("‚ùå Azure-databasen √§r inte tillg√§nglig (macspotpg.postgres.database.azure.com:5432)")
        exit(1)

    print(f"üìå K√∂rning initierad: {datetime.now().isoformat()}")

    print(f"\nüîÑ [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Startar fullst√§ndig synk...")

    scripts_part1 = [
        ("üü° K√∂r sync.py...", "sync.py"),
        ("üü¢ K√∂r sync_to_cloud.py...", "sync_to_cloud.py")
    ]

    for msg, script in scripts_part1:
        run_script(msg, script)

    scripts_part2 = [
        ("üîµ K√∂r sync_from_cloud.py...", "sync_from_cloud.py")
    ]

    for msg, script in scripts_part2:
        run_script(msg, script)

    today_prefix = datetime.now().strftime('%Y%m%d')
    outbox_dir = os.path.join(BASE, 'sync_outbox')
    files = [f for f in os.listdir(outbox_dir) if f.startswith(today_prefix)]
    files_with_type = [f for f in files if len(f.split("_")) >= 3]
    num_changes = len(files_with_type)

    if num_changes == 0:
        print("‚ÑπÔ∏è Ingen f√∂r√§ndring hittades att synka.")
        print("üì≠ Inga fler √§ndringar kvar i pending_changes.")
    else:
        print(f"üì§ Totalt {num_changes} √§ndring(ar) skickades till molnet:")
        files = [f for f in sorted(os.listdir(outbox_dir)) if f.startswith(today_prefix)]
        summary = {}
        for f in files:
            parts = f.split("_")
            if len(parts) >= 3:
                typ = parts[2].split(".")[0]
                summary[typ] = summary.get(typ, 0) + 1

        if summary:
            print("üßæ Sammanfattning per typ:")
            for typ, count in summary.items():
                print(f"   ‚Ä¢ {typ}: {count} st")

        print("üìä Kontroll av √•terst√•ende √§ndringar i pending_changes...")

        # Lokalt
        local = psycopg2.connect(
            dbname="macspot",
            user="postgres",
            host="localhost",
            port=5433
        )
        cur_local = local.cursor()
        cur_local.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
        """)
        out_local = cur_local.fetchone()[0]
        cur_local.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
            GROUP BY record_id
        """)
        print(f"   ‚Ä¢ Lokalt ‚Üí molnet: {out_local} √§ndring(ar) kvar √∂ver {cur_local.rowcount} kontakt(er).")
        cur_local.close()
        local.close()

        # Molnet
        cloud = psycopg2.connect(
            dbname="postgres",
            user="daniel",
            host="macspotpg.postgres.database.azure.com",
            port=5432
        )
        cur_cloud = cloud.cursor()
        cur_cloud.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
        """)
        out_cloud = cur_cloud.fetchone()[0]
        cur_cloud.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
            GROUP BY record_id
        """)
        cur_cloud.close()
        cloud.close()

    print(f"\n‚úÖ [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Fullst√§ndig synk k√∂rd.")

except Exception as e:
    import traceback
    print("‚ùå Ett ov√§ntat fel intr√§ffade under k√∂rningen:")
    print(traceback.format_exc())

finally:
    print(f"üèÅ K√∂rning avslutad: {datetime.now().isoformat()}")
    duration = datetime.now() - start_time
    print(f"‚è±Ô∏è Total k√∂rtid: {int(duration.total_seconds())} sekunder")
END: sync_all.py

üìÅ KONFIGURATIONSFILER (function.json / host.json / package.json / .funcignore)
====================================

üìÑ .funcignore
   # Exclude dev-only files and folders
   .git
   .vscode
   .env
   *.log
   test/
   tests/
   
   # Explicitly include all required files and folders
   !host.json
   !package.json
   !package-lock.json
   
   !node_modules/
   !node_modules/**
   
   !shared/
   !shared/**
   
   !bookings/
   !bookings/**
   !getavailableslots/
   !getavailableslots/**
   !validate_contact/
   !validate_contact/**
   !meeting_types/
   !meeting_types/**
   !refreshCalendarOrigins/
   !refreshCalendarOrigins/**
   !refreshTravelTimes/
   !refreshTravelTimes/**
   !booking_settings/
   !booking_settings/**
   !test_azurecloud/
   !test_azurecloud/**
üìÑ booking_settings/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get"],
         "route": "booking_settings"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ bookings/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "bookings"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ getavailableslots/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "getavailableslots"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ host.json
   {
     "version": "2.0",
     "extensionBundle": {
       "id": "Microsoft.Azure.Functions.ExtensionBundle",
       "version": "[4.*, 5.0.0)"
     },
     "extensions": {
       "http": {
         "cors": {
           "allowedOrigins": [
             "https://www.klrab.se"
           ],
           "supportCredentials": false
         }
       }
     }
   }
üìÑ meeting_types/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": [ "get" ],
         "route": "meeting_types"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ package.json
   {
     "name": "macspot-api",
     "version": "1.0.0",
     "description": "Azure Functions backend f√∂r MacSpot CRM/ERP",
     "scripts": {
       "start": "func start",
       "dev": "func start --verbose",
       "deploy": "func azure functionapp publish macspotbackend",
       "build": "echo 'Nothing to build'"
     },
     "dependencies": {
       "@azure/functions": "^4.7.0",
       "@azure/msal-node": "^3.5.1",
       "@microsoft/microsoft-graph-client": "^3.0.0",
       "dav": "^1.8.0",
       "dotenv": "^16.5.0",
       "isomorphic-fetch": "^3.0.0",
       "jsonwebtoken": "^9.0.0",
       "luxon": "^3.4.4",
       "node-fetch": "^2.7.0",
       "node-ical": "^0.20.1",
       "p-limit": "^6.2.0",
       "pg": "^8.15.6",
       "uuid": "^9.0.0",
       "xml2js": "^0.6.2"
     }
   }

üìÑ refreshCalendarOrigins/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ refreshTravelTimes/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ test_azurecloud/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get"],
         "route": "test_azurecloud"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ validate_contact/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get", "post"],
         "route": "validate_contact"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìà SUMMERING AV ALLA JS-FILER
====================================
üìè Totalt antal rader kod: 3018
üß© Totalt antal funktioner: 50
üß† Total komplexitetspo√§ng: 337
üß™ Antal TODO/FIXME totalt: 0

üìä Per fil:
fil,rader,funktioner,komplexitet,kommentarer,imports
index.js,47,1,3,1,2
index.js,182,1,28,5,3
index.js,191,2,13,2,9
index.js,36,1,1,0,4
index.js,112,4,8,0,6
appleCalendar.js,190,7,14,2,3
getMsToken.js,57,1,5,0,2
msGraph.js,185,6,15,0,5
resolveOrigin.js,235,2,37,21,0
settingsLoader.js,67,2,11,0,1
verifySettings.js,52,1,8,0,0
pgPool.js,20,1,0,0,2
appleMaps.js,121,5,9,0,2
returnTravelVerifier.js,66,1,4,1,1
resolveTravelTime.js,72,1,8,0,0
zoomClient.js,63,3,3,0,1
sendMail.js,60,2,3,2,1
index.js,284,3,25,7,7
debugLogger.js,23,2,2,0,0
slotEngine.js,312,4,37,8,6
sync_from_cloud.py,141,0,28,0,2
sync_to_cloud.py,211,0,41,0,3
sync_static_tables.py,61,0,6,0,2
sync.py,82,0,10,0,2
sync_all.py,148,0,18,0,6
üìä MOLNDATABAS (Azure) ‚Äì STRUKTUR & INNEH√ÖLL
====================================

üìÅ Tabell: available_slots_cache
  ‚Ä¢ id (uuid)
  ‚Ä¢ travel_time_min (integer)
  ‚Ä¢ generated_at (timestamp without time zone)
  ‚Ä¢ expires_at (timestamp without time zone)
  ‚Ä¢ meeting_length (integer)
  ‚Ä¢ slot_day (date)
  ‚Ä¢ slot_score (integer)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ slot_part (text)
  ‚Ä¢ slot_iso (text)
  üîë [p] available_slots_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: slot_cache
  ‚Ä¢ created_at (timestamp without time zone)
  ‚Ä¢ slot_day (date)
  ‚Ä¢ slots (jsonb)
  ‚Ä¢ id (uuid)
  ‚Ä¢ meeting_length (integer)
  ‚Ä¢ booking_email (text)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ slot_part (text)
  üîë [p] slot_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: calendar_origin_cache
  ‚Ä¢ created_at (timestamp without time zone)
  ‚Ä¢ timestamp (timestamp with time zone)
  ‚Ä¢ event_date (date)
  ‚Ä¢ id (integer)
  ‚Ä¢ end_time (timestamp without time zone)
  ‚Ä¢ address (text)
  ‚Ä¢ source (text)
  üîë [c] calendar_origin_cache_source_check: CHECK ((source = ANY (ARRAY['Apple Calendar'::text, 'Microsoft 365'::text])))
  üîë [p] calendar_origin_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: travel_time_cache
  ‚Ä¢ travel_minutes (integer)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ is_fallback (boolean)
  ‚Ä¢ hour (integer)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ to_address (text)
  ‚Ä¢ from_address (text)
  üîë [u] unique_travel_key: UNIQUE (from_address, to_address, hour)
  üß™ Topp 5 rader:
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=10, travel_minutes=21, created_at=2025-05-26 12:00:01.232984+00:00, updated_at=2025-05-26 12:00:01.232984+00:00, is_fallback=False
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=14, travel_minutes=21, created_at=2025-05-26 12:00:01.878755+00:00, updated_at=2025-05-26 12:00:01.878755+00:00, is_fallback=False

üìÅ Tabell: event_log
  ‚Ä¢ received_at (timestamp with time zone)
  ‚Ä¢ record_id (uuid)
  ‚Ä¢ timestamp (timestamp with time zone)
  ‚Ä¢ booking_id (uuid)
  ‚Ä¢ id (uuid)
  ‚Ä¢ payload (jsonb)
  ‚Ä¢ action (text)
  ‚Ä¢ event_type (text)
  ‚Ä¢ source (text)
  ‚Ä¢ table_name (text)
  üîë [p] event_log_pkey: PRIMARY KEY (id)
  üß™ Topp 5 rader:
    - source=None, event_type=None, payload=None, received_at=2025-05-26 11:30:25.115769+00:00, id=2ac4e176-edc2-4b4a-bebf-2e9d53c0b6db, action=INSERT, table_name=contact, record_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, timestamp=2025-05-26 11:30:25.115769+00:00, booking_id=None
    - source=None, event_type=booking_created, payload=None, received_at=2025-05-26 11:30:35.906268+00:00, id=e5120865-2baa-405b-970e-2c356ae1a877, action=None, table_name=None, record_id=None, timestamp=2025-05-26 11:30:35.906268+00:00, booking_id=2b69c259-7579-4310-9b48-88b565cdd7d0
    - source=None, event_type=booking_created, payload=None, received_at=2025-05-26 11:30:58.035990+00:00, id=e685e28c-0cbb-45fd-a2f9-213bd0847116, action=None, table_name=None, record_id=None, timestamp=2025-05-26 11:30:58.035990+00:00, booking_id=be391645-d37a-4f6d-a1d8-48dd08c4f382
    - source=None, event_type=booking_created, payload=None, received_at=2025-05-26 11:31:22.504101+00:00, id=9db1d894-7f83-48fc-a7d4-29d66dd5c8af, action=None, table_name=None, record_id=None, timestamp=2025-05-26 11:31:22.504101+00:00, booking_id=0b34a27f-fa2a-4185-95b1-60e64e5d12cd
    - source=None, event_type=None, payload=None, received_at=2025-05-26 11:31:55.898756+00:00, id=6597f521-fed0-447b-b303-eaeb38c7ddf0, action=UPDATE, table_name=contact, record_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, timestamp=2025-05-26 11:31:55.898756+00:00, booking_id=None

üìÅ Tabell: booking_settings
  ‚Ä¢ value (jsonb)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ key (text)
  ‚Ä¢ value_type (text)
  üîë [u] unique_key: UNIQUE (key)
  üß™ Topp 5 rader:
    - key=max_days_in_advance, value=30, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=required_fields, value={'base': ['first_name', 'last_name', 'phone', 'company'], 'zoom': [], 'teams': [], 'atclient': ['address', 'postal_code', 'city', 'country'], 'atoffice': [], 'facetime': []}, value_type=json, updated_at=2025-05-23 15:10:13.460480+00:00
    - key=default_meeting_subject, value=M√∂te med KLRA Ledningsr√•dgivning, value_type=string, updated_at=2025-05-25 10:37:53.619684+00:00
    - key=email_invite_template, value={'body': 'Hej {{first_name}},\n\nH√§r kommer en inbjudan till v√•rt m√∂te.\n\nMed v√§nliga h√§lsningar,\nKLRA', 'subject': 'M√∂te med {{company}}'}, value_type=json, updated_at=2025-05-25 10:37:53.619684+00:00
    - key=analytics_enabled, value=True, value_type=bool, updated_at=2025-05-25 10:37:53.619684+00:00

üìÅ Tabell: translation
  ‚Ä¢ key (character varying)
  ‚Ä¢ sv (text)
  ‚Ä¢ en (text)
  üß™ Topp 5 rader:
    - key=error_min_duration_fysiskt_kund, sv=M√∂testiden f√∂r 'Fysiskt hos kund' m√•ste vara minst {{minutes}} minuter. Du visste det redan., en=The meeting time for 'On-site at customer' must be at least {{minutes}} minutes. You knew that.
    - key=error_min_duration_fysiskt_mig, sv=M√∂testiden f√∂r 'Fysiskt hos mig' m√•ste vara minst {{minutes}} minuter. Annars hinner vi bara s√§ga hej., en=The meeting time for 'At my office' must be at least {{minutes}} minutes. Otherwise, we‚Äôll only have time to say hello.
    - key=email_body_booking_received, sv=Hej {{name}}! Vi har tagit emot din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}}. Ingen panik ‚Äì vi √•terkommer med bekr√§ftelse. / Daniel, en=Hello {{name}}, We‚Äôve received your booking for {{meeting_type}} between {{start_time}} and {{end_time}}. No need to panic ‚Äì we‚Äôll confirm shortly. / Daniel
    - key=email_body_booking_confirmed, sv=Hej {{name}}! Din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}} √§r nu spikad. Ser fram emot det! / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} is now locked in. Looking forward! / Daniel
    - key=email_body_booking_cancelled, sv=Hej {{name}}! Din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}} √§r avbokad. H√∂r av dig om du vill hitta en ny tid. / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} has been cancelled. Let me know if you'd like a new one. / Daniel

üìÅ Tabell: bookings
  ‚Ä¢ start_time (timestamp with time zone)
  ‚Ä¢ end_time (timestamp with time zone)
  ‚Ä¢ id (uuid)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ metadata (jsonb)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ contact_id (uuid)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ booking_email (text)
  üîë [p] bookings_pkey: PRIMARY KEY (id)
  üîë [f] fk_bookings_contact: FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE SET NULL
  üß™ Topp 5 rader:
    - start_time=2025-05-27 08:00:00+00:00, end_time=2025-05-27 08:10:00+00:00, meeting_type=zoom, metadata={'subject': 'M√∂te med KLRA Ledningsr√•dgivning', 'location': 'Online', 'meeting_id': 88409084527, 'online_link': 'https://us05web.zoom.us/j/88409084527?pwd=omCro2i8pgZlBZ8VJVSbgLtgucptOa.1', 'meeting_length': 10}, created_at=2025-05-26 11:30:34.562000+00:00, contact_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, id=2b69c259-7579-4310-9b48-88b565cdd7d0, updated_at=2025-05-26 11:30:34.562000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-05-28 08:00:00+00:00, end_time=2025-05-28 08:10:00+00:00, meeting_type=facetime, metadata={'meeting_length': 10}, created_at=2025-05-26 11:30:57.976000+00:00, contact_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, id=be391645-d37a-4f6d-a1d8-48dd08c4f382, updated_at=2025-05-26 11:30:57.976000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-05-29 08:00:00+00:00, end_time=2025-05-29 09:00:00+00:00, meeting_type=teams, metadata={'subject': 'M√∂te med KLRA Ledningsr√•dgivning', 'location': 'Online', 'online_link': 'https://teams.microsoft.com/l/meetup-join/19%3ameeting_MjY3NmVjNDgtODI2OS00NzUzLWI2MDctNTJkOTI2ZjU0NTY4%40thread.v2/0?context=%7b%22Tid%22%3a%226f2f8e0c-22fc-4d93-bf68-72a916e2f35f%22%2c%22Oid%22%3a%2285224b32-2747-4b0c-bc0f-3bb4e7192aa9%22%7d', 'meeting_length': 60}, created_at=2025-05-26 11:31:20.270000+00:00, contact_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, id=0b34a27f-fa2a-4185-95b1-60e64e5d12cd, updated_at=2025-05-26 11:31:20.270000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-05-30 08:00:00+00:00, end_time=2025-05-30 09:30:00+00:00, meeting_type=atclient, metadata={'subject': 'M√∂te med KLRA Ledningsr√•dgivning', 'location': 'Taxgatan 4, 115 45 Stockholm', 'meeting_length': 90}, created_at=2025-05-26 11:32:02.414000+00:00, contact_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, id=6ca102d7-1881-497a-a49c-c22b92bd42f7, updated_at=2025-05-26 11:32:02.414000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-06-03 08:00:00+00:00, end_time=2025-06-03 09:30:00+00:00, meeting_type=atoffice, metadata={'subject': 'M√∂te med KLRA Ledningsr√•dgivning', 'location': 'Maria Skolgata 79A, 118 53 Stockholm', 'meeting_length': 90}, created_at=2025-05-26 11:32:29.252000+00:00, contact_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, id=11e8d22a-1f83-4a4a-87c6-ca5beefce8aa, updated_at=2025-05-26 11:32:29.252000+00:00, booking_email=daniel.kallberg@mac.com

üìÅ Tabell: pending_changes
  ‚Ä¢ booking_id (uuid)
  ‚Ä¢ processed (boolean)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ payload (jsonb)
  ‚Ä¢ id (uuid)
  ‚Ä¢ record_id (uuid)
  ‚Ä¢ table_name (text)
  ‚Ä¢ operation (text)
  ‚Ä¢ change_type (text)
  ‚Ä¢ direction (text)
  üîë [p] pending_changes_pkey: PRIMARY KEY (id)
  üîë [f] fk_pending_changes_booking_id: FOREIGN KEY (booking_id) REFERENCES bookings(id) ON DELETE CASCADE
  üß™ Topp 5 rader:
    - id=3cf0bacb-d197-4879-a572-f20e54c43f2e, table_name=contact, record_id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, change_type=INSERT, direction=out, processed=False, created_at=2025-05-26 11:30:25.115769+00:00, operation=INSERT, payload={'id': 'a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1', 'email': 'daniel.kallberg@mac.com', 'metadata': {'phone': '0709561480', 'company': 'Test AB', 'last_name': 'K√§llberg', 'first_name': 'Daniel'}, 'created_at': '2025-05-26T11:30:25.115769+00:00', 'updated_at': '2025-05-26T11:30:25.115769+00:00', 'booking_email': 'daniel.kallberg@mac.com'}, booking_id=None
    - id=a96553de-1ec2-46a3-ac30-d478a8532e94, table_name=bookings, record_id=2b69c259-7579-4310-9b48-88b565cdd7d0, change_type=INSERT, direction=out, processed=False, created_at=2025-05-26 11:30:35.854490+00:00, operation=INSERT, payload={'id': '2b69c259-7579-4310-9b48-88b565cdd7d0', 'end_time': '2025-05-27T08:10:00+00:00', 'metadata': {'subject': 'M√∂te med KLRA Ledningsr√•dgivning', 'location': 'Online', 'meeting_id': 88409084527, 'online_link': 'https://us05web.zoom.us/j/88409084527?pwd=omCro2i8pgZlBZ8VJVSbgLtgucptOa.1', 'meeting_length': 10}, 'contact_id': 'a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1', 'created_at': '2025-05-26T11:30:34.562+00:00', 'start_time': '2025-05-27T08:00:00+00:00', 'updated_at': '2025-05-26T11:30:34.562+00:00', 'meeting_type': 'zoom', 'booking_email': 'daniel.kallberg@mac.com'}, booking_id=2b69c259-7579-4310-9b48-88b565cdd7d0
    - id=898a2d09-d2ce-45b4-9ef7-e15297257725, table_name=bookings, record_id=2b69c259-7579-4310-9b48-88b565cdd7d0, change_type=INSERT, direction=cloud_to_local, processed=False, created_at=2025-05-26 11:30:35.881000+00:00, operation=None, payload=None, booking_id=2b69c259-7579-4310-9b48-88b565cdd7d0
    - id=6659c7c8-0d48-4eba-a6db-79243e66de8d, table_name=bookings, record_id=be391645-d37a-4f6d-a1d8-48dd08c4f382, change_type=INSERT, direction=out, processed=False, created_at=2025-05-26 11:30:57.977055+00:00, operation=INSERT, payload={'id': 'be391645-d37a-4f6d-a1d8-48dd08c4f382', 'end_time': '2025-05-28T08:10:00+00:00', 'metadata': {'meeting_length': 10}, 'contact_id': 'a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1', 'created_at': '2025-05-26T11:30:57.976+00:00', 'start_time': '2025-05-28T08:00:00+00:00', 'updated_at': '2025-05-26T11:30:57.976+00:00', 'meeting_type': 'facetime', 'booking_email': 'daniel.kallberg@mac.com'}, booking_id=be391645-d37a-4f6d-a1d8-48dd08c4f382
    - id=45a92537-32e6-4428-b599-bdcefe5007d8, table_name=bookings, record_id=be391645-d37a-4f6d-a1d8-48dd08c4f382, change_type=INSERT, direction=cloud_to_local, processed=False, created_at=2025-05-26 11:30:58.006000+00:00, operation=None, payload=None, booking_id=be391645-d37a-4f6d-a1d8-48dd08c4f382

üìÅ Tabell: contact
  ‚Ä¢ metadata (jsonb)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ id (uuid)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ booking_email (text)
  ‚Ä¢ email (text)
  üîë [p] contact_pkey: PRIMARY KEY (id)
  üß™ Topp 5 rader:
    - metadata={'city': 'STOCKHOLM', 'phone': '0709561480', 'address': 'Kungsgatan 4', 'company': 'Test AB', 'country': 'SVERGIE', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'postal_code': '112 45'}, created_at=2025-05-26 11:30:25.115769+00:00, id=a2e0ae07-b2ff-43a0-b044-5ef5f3915ce1, booking_email=daniel.kallberg@mac.com, updated_at=2025-05-26 11:31:55.898756+00:00, email=daniel.kallberg@mac.com

