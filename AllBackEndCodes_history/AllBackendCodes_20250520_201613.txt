üìÇ KODTR√ÑD
==========
‚îú‚îÄ‚îÄ bookings
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ getavailableslots
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ meeting_types
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ refreshCalendarOrigins
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ refreshTravelTimes
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ calendar
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ appleCalendar.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ getMsToken.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ msGraph.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resolveOrigin.js
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ settingsLoader.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ verifySettings.js
‚îÇ   ‚îú‚îÄ‚îÄ db
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pgPool.js
‚îÇ   ‚îú‚îÄ‚îÄ maps
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ appleMaps.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resolveTravelTime.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ returnTravelVerifier.js
‚îÇ   ‚îú‚îÄ‚îÄ slots
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ slotEngine.js
‚îÇ   ‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ debugLogger.js
‚îú‚îÄ‚îÄ validate_contact
‚îÇ   ‚îú‚îÄ‚îÄ index.js
==========

====================
üìÑ Fil: meeting_types/index.js
üìÖ Senast √§ndrad: 2025-05-19 09:56:12
üìè Antal rader: 66
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 1 rader (1.5%)
üì• Imports: 1 ‚Äì ["const { Pool } = require('pg');"]
üîç L√§ngsta funktion: 7 rader
üß† Komplexitetspo√§ng: 5
üß™ TODO/FIXME: 0
====================
START: index.js
const { Pool } = require('pg');

const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: { rejectUnauthorized: false }
});

module.exports = async function (context, req) {
  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.log.error(`Missing environment variable: ${key}`);
      context.res = {
        status: 500,
        body: { error: `Missing environment variable: ${key}` }
      };
      return;
    }
  }

  try {
    const settingsRes = await pool.query(
      "select key, value from booking_settings where key in ('meeting_types', 'default_meeting_length_atclient', 'default_meeting_length_atoffice', 'default_meeting_length_digital')"
    );

    const settings = {};
    for (const row of settingsRes.rows) {
      try {
        settings[row.key] = JSON.parse(row.value);
      } catch {
        settings[row.key] = row.value;
      }
    }

    const rawTypes = settings['meeting_types'];
    const meetingTypes = Array.isArray(rawTypes) ? rawTypes.map(t => t.toLowerCase()) : [];
    const lengths = {
      zoom: settings['default_meeting_length_digital'],
      facetime: settings['default_meeting_length_digital'],
      teams: settings['default_meeting_length_digital'],
      atclient: settings['default_meeting_length_atclient'],
      atoffice: settings['default_meeting_length_atoffice']
    };

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        types: meetingTypes,
        lengths
      })
    };
  } catch (error) {
    context.log.error('Database query failed:', error);
    context.res = {
      status: 500,
      body: { error: error.message }
    };
  } finally {
    // pool.end() tas bort ‚Äì vi √•teranv√§nder en delad pool mellan anrop
  }
};
END: index.js

====================
üìÑ Fil: validate_contact/index.js
üìÖ Senast √§ndrad: 2025-05-15 10:15:41
üìè Antal rader: 128
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 1 rader (0.8%)
üì• Imports: 2 ‚Äì ["const { Pool } = require('pg');", "const { v4: uuidv4 } = require('uuid');"]
üîç L√§ngsta funktion: 7 rader
üß† Komplexitetspo√§ng: 14
üß™ TODO/FIXME: 0
====================
START: index.js
const { Pool } = require('pg');
const { v4: uuidv4 } = require('uuid');
const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: { rejectUnauthorized: false }
});

module.exports = async function (context, req) {
  try {
    const email = req.body?.email || req.query?.email;
    const meeting_type = req.body?.meeting_type || req.query?.meeting_type;
    context.log.info('üì• validate_contact triggered with:', { email, meeting_type });

    if (!email || !meeting_type) {
      context.res = { status: 400, body: { error: "email and meeting_type are required" } };
      return;
    }

    const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
    for (const key of requiredEnv) {
      if (!process.env[key]) throw new Error(`Missing environment variable: ${key}`);
    }

    const contactRes = await pool.query('SELECT * FROM contact WHERE booking_email = $1', [email]);
    const contact = contactRes.rows[0];
    let metadata = contact?.metadata || {};

    if (typeof metadata === 'string') {
      try {
        metadata = JSON.parse(metadata);
      } catch {
        metadata = {};
      }
    }

    if (typeof metadata !== 'object' || metadata === null) metadata = {};

    const settingsRes = await pool.query('SELECT value FROM booking_settings WHERE key = $1', ['meeting_digital']);
    const raw = settingsRes.rows[0]?.value;
    const digitalTypes = Array.isArray(raw) ? raw : JSON.parse(raw || '[]');
    const isDigital = digitalTypes.map(t => t.toLowerCase()).includes(meeting_type.toLowerCase()) || meeting_type === 'atoffice';

    const alwaysRequired = ['first_name', 'last_name', 'phone', 'company'];
    const addressRequired = ['address', 'postal_code', 'city', 'country'];
    const requiredFields = [...alwaysRequired, ...(isDigital ? [] : addressRequired)];
    const missingFields = requiredFields.filter(
      field => !metadata[field] || typeof metadata[field] !== 'string' || metadata[field].trim() === ''
    );

    if ((req.body?.write_if_valid || req.query?.write_if_valid) && missingFields.length > 0) {
      let metadataFromClient = req.body?.metadata;
      if (typeof metadataFromClient === 'string') {
        try {
          metadataFromClient = JSON.parse(metadataFromClient);
        } catch {
          metadataFromClient = {};
        }
      }
      if (typeof metadataFromClient === 'object' && metadataFromClient !== null) {
        if (!contact) {
          const newId = uuidv4();
          await pool.query(
            `INSERT INTO contact (id, booking_email, metadata, created_at) VALUES ($1, $2, $3, NOW())`,
            [newId, email, metadataFromClient]
          );
          context.log.info('‚úÖ Ny kontakt skapad via validate_contact');

          context.res = {
            status: 200,
            body: {
              status: "created",
              contact_id: newId
            }
          };
          return;
        } else {
          await pool.query(
            `UPDATE contact SET metadata = $1, updated_at = NOW() WHERE booking_email = $2`,
            [metadataFromClient, email]
          );
          context.log.info('‚úèÔ∏è Befintlig kontakt uppdaterad via validate_contact');
        }
      }
    }

    if (!contact) {
      context.res = {
        status: 200,
        body: {
          status: "new_customer",
          missing_fields: missingFields
        }
      };
    } else if (missingFields.length > 0) {
      context.res = {
        status: 200,
        body: {
          status: "incomplete",
          missing_fields: missingFields
        }
      };
    } else {
      context.res = {
        status: 200,
        body: {
          status: "existing_customer",
          contact_id: contact.id
        }
      };
    }

  } catch (error) {
    context.log.error('‚ùå Error during validate_contact:', {
      message: error.message,
      stack: error.stack
    });
    context.res = {
      status: 500,
      body: { error: error.message, stack: error.stack }
    };
  } finally {
    // Poolen √§r delad och √•teranv√§nds ‚Äì vi st√§nger den inte h√§r
  }
};
END: index.js

====================
üìÑ Fil: getavailableslots/index.js
üìÖ Senast √§ndrad: 2025-05-20 19:49:33
üìè Antal rader: 154
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 2 rader (1.3%)
üì• Imports: 5 ‚Äì ['const db = require("../shared/db/pgPool");', "require('../shared/config/verifySettings');", "const loadSettings = require('../shared/config/settingsLoader');", "const verifyBookingSettings = require('../shared/config/verifySettings');", "generateSlotChunks = require('../shared/slots/slotEngine').generateSlotChunks;"]
üîç L√§ngsta funktion: 17 rader
üß† Komplexitetspo√§ng: 10
üß™ TODO/FIXME: 0
====================
START: index.js
const db = require("../shared/db/pgPool");
console.log("‚úÖ getavailableslots/index.js laddad");
require('../shared/config/verifySettings');

module.exports = async function (context, req) {
  context.log("üß™ Azure Function entrypoint n√•dd");

  try {
    const client = await db.connect();

    if (!req || !req.body) {
      context.log("‚ùå Ingen request body mottagen");
      context.res = { status: 400, body: { error: "Missing request body" } };
      return;
    }

    const { email, meeting_type } = req.body;
    const { contact_id } = req.body;
    context.log("‚úÖ Request body inneh√•ller:", { email, meeting_type });
    context.log("‚úÖ Steg 1: Anropar DB med contact_id:", contact_id);

    // Declare allBookings, days, and contact at the top-level scope of the outer try block
    let allBookings = [];
    let days = [];
    let contact;
    let bookingsByDay = {};

    try {
      const contactRes = await client.query("SELECT * FROM contact WHERE id = $1", [contact_id]);
      contact = contactRes.rows[0];
      if (contact) {
        context.log("‚úÖ Kontakt hittad:", contact.id);
      } else {
        context.log("‚ö†Ô∏è Ingen kontakt hittad f√∂r contact_id:", contact_id);
      }
    } catch (err) {
      context.log("üî• DB-fel:", err.message);
      context.res = { status: 500, body: { error: "DB error", detail: err.message } };
      client.release();
      return;
    }

    context.log("‚úÖ Steg 2: Laddar booking_settings...");

    const loadSettings = require('../shared/config/settingsLoader');
    const verifyBookingSettings = require('../shared/config/verifySettings');

    let settings;
    try {
      settings = await loadSettings(db, context);
      context.log("‚úÖ Steg 2a: Inst√§llningar laddade ‚Äì nycklar:", Object.keys(settings).join(', '));
      verifyBookingSettings(settings, context);
      context.log("‚úÖ Steg 2b: Inst√§llningar verifierade");

      context.log("‚úÖ Steg 3: Genererar days[] och laddar bokningar");

      const maxDays = settings.max_days_in_advance || 14;
      const today = new Date();
      days = Array.from({ length: maxDays }, (_, i) => {
        const date = new Date(today);
        date.setDate(today.getDate() + i);
        return date;
      });

      const startDateStr = days[0].toISOString().split('T')[0];
      const endDateStr = days[days.length - 1].toISOString().split('T')[0];

      const allBookingsRes = await client.query(
        'SELECT start_time, end_time, meeting_type FROM bookings WHERE start_time::date >= $1 AND start_time::date <= $2',
        [startDateStr, endDateStr]
      );
      context.log("üî¢ Antal bokningar h√§mtade:", allBookingsRes.rows.length);

      allBookings = allBookingsRes.rows.map(b => ({
        start: new Date(b.start_time).getTime(),
        end: new Date(b.end_time).getTime(),
        date: new Date(b.start_time).toISOString().split('T')[0],
        meeting_type: b.meeting_type
      }));

      for (const booking of allBookings) {
        if (!bookingsByDay[booking.date]) bookingsByDay[booking.date] = [];
        bookingsByDay[booking.date].push({ start: booking.start, end: booking.end });
      }

      context.log("‚úÖ Steg 3: Dagar genererade och bokningar summerade");

    } catch (err) {
      context.log("üî• Fel vid laddning/verifiering av settings:", err.message);
      context.res = { status: 500, body: { error: "Settings error", detail: err.message } };
      client.release();
      return;
    }

    let generateSlotChunks;
    try {
      generateSlotChunks = require('../shared/slots/slotEngine').generateSlotChunks;
      context.log("‚úÖ generateSlotChunks import ok");
    } catch (importErr) {
      context.log("‚ùå Misslyckades importera generateSlotChunks:", importErr.message);
      context.res = { status: 500, body: { error: "Import error", detail: importErr.message } };
      client.release();
      return;
    }

    const weeklyMinutesByType = {};
    const weekKey = (date) => {
      const start = new Date(date);
      start.setUTCHours(0, 0, 0, 0);
      start.setUTCDate(start.getUTCDate() - start.getUTCDay());
      return start.toISOString().split('T')[0];
    };
    for (const b of allBookings) {
      const type = b.meeting_type || 'unknown';
      const week = weekKey(b.start);
      weeklyMinutesByType[type] = weeklyMinutesByType[type] || {};
      weeklyMinutesByType[type][week] = (weeklyMinutesByType[type][week] || 0) + (b.end - b.start) / 60000;
    }

    // Riktigt anrop till generateSlotChunks
    const chosenSlotsResult = await generateSlotChunks({
      days,
      context,
      contact,
      contact_id,
      meeting_type,
      meeting_length: 20,
      bookingsByDay,
      weeklyMinutesByType,
      settings,
      graphClient: null,
      appleClient: null,
      travelCache: new Map(),
      accessToken: null,
      timezone: settings.timezone || 'Europe/Stockholm',
      debugHelper: { debugLog: context.log, skipReasons: {} },
      client: client
    });
    context.log("‚úÖ generateSlotChunks k√∂rdes utan fel");

    context.res = {
      status: 200,
      body: {
        message: "‚úÖ getavailableslots √§r kontaktbar och fungerar i minimal version",
        received: { email, meeting_type }
      }
    };
    client.release();
  } catch (err) {
    context.log("üî• FEL i minimal testfunktion:", err.message);
    context.res = { status: 500, body: { error: err.message } };
  }
  context.log("‚úÖ getavailableslots/index.js ‚Äì HELA FUNKTIONEN K√ñRDES UTAN FEL");
};
END: index.js

====================
üìÑ Fil: refreshCalendarOrigins/index.js
üìÖ Senast √§ndrad: 2025-05-19 15:57:39
üìè Antal rader: 35
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 4 ‚Äì ["const { DateTime } = require('luxon');", "const pool = require('../shared/db/pgPool');", "const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');", "const settingsLoader = require('../shared/config/settingsLoader');"]
üîç L√§ngsta funktion: 4 rader
üß† Komplexitetspo√§ng: 1
üß™ TODO/FIXME: 0
====================
START: index.js


const { DateTime } = require('luxon');
const pool = require('../shared/db/pgPool');
const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');
const settingsLoader = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const today = new Date();
  const settings = await settingsLoader(pool, context);
  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const date = new Date();
    date.setDate(today.getDate() + i);
    return date;
  });

  context.log(`üîÅ K√∂r refreshCalendarOrigins f√∂r ${days.length} dagar`);

  for (const date of days) {
    const slotTime = DateTime.fromJSDate(date).set({ hour: 10, minute: 0 }).toJSDate();
    const travelStart = new Date(slotTime.getTime() - (settings.fallback_travel_time_minutes || 20) * 60000);

    await resolveOriginAddress({
      eventId: slotTime.toISOString(),
      calendarId: 'system-refresh',
      pool,
      context,
      fallbackOrigin: settings.default_home_address,
      settings
    });
  }

  context.log('‚úÖ refreshCalendarOrigins f√§rdig');
};
END: index.js

====================
üìÑ Fil: refreshTravelTimes/index.js
üìÖ Senast √§ndrad: 2025-05-19 15:56:23
üìè Antal rader: 112
üß© Antal funktioner: 4
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 6 ‚Äì ["const { DateTime } = require('luxon');", "const fetch = require('node-fetch');", "const pool = require('../shared/db/pgPool');", "const loadSettings = require('../shared/config/settingsLoader');", "const jwt = require('jsonwebtoken');", "const fs = require('fs');"]
üîç L√§ngsta funktion: 10 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: index.js
const { DateTime } = require('luxon');
const fetch = require('node-fetch');
const pool = require('../shared/db/pgPool');
const loadSettings = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const settings = await loadSettings(pool, context);
  const fallbackTravelTime = settings.fallback_travel_time_minutes || 20;
  const today = new Date();
  const timezone = settings.timezone || 'Europe/Stockholm';

  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const d = new Date(today);
    d.setDate(today.getDate() + i);
    return d;
  });

  const destinations = [settings.default_office_address];
  const origins = [settings.default_home_address];

  for (const day of days) {
    for (const hour of [10, 14]) {
      const slotTime = DateTime.fromJSDate(day).set({ hour, minute: 0 }).toJSDate();

      for (const from of origins) {
        for (const to of destinations) {
          const hourKey = slotTime.getUTCHours();
          const key = `${from}|${to}|${hourKey}`;

          const res = await pool.query(
            `SELECT 1 FROM travel_time_cache
             WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
            [from, to, hourKey]
          );

          if (res.rows.length > 0) {
            context.log(`‚ö° Redan i cache: ${key}`);
            continue;
          }

          context.log(`‚è≥ Ber√§knar restid: ${key}`);
          try {
            const token = await getAppleMapsAccessToken(context);
            if (!token) throw new Error('Apple Maps-token saknas');

            const url = new URL('https://maps-api.apple.com/v1/directions');
            url.searchParams.append('origin', from);
            url.searchParams.append('destination', to);
            url.searchParams.append('transportType', 'automobile');
            url.searchParams.append('departureTime', slotTime.toISOString());

            const response = await fetch(url.toString(), {
              headers: { Authorization: `Bearer ${token}` }
            });
            const data = await response.json();

            const minutes = Math.round((data.routes?.[0]?.durationSeconds || fallbackTravelTime * 60) / 60);
            await pool.query(
              `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
               VALUES ($1, $2, $3, $4)
               ON CONFLICT (from_address, to_address, hour)
               DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes`,
              [from, to, hourKey, minutes]
            );
            context.log(`‚úÖ Sparad restid: ${minutes} min (${key})`);
          } catch (err) {
            context.log(`‚ö†Ô∏è Misslyckades h√§mta/spara restid f√∂r ${key}: ${err.message}`);
          }
        }
      }
    }
  }

  context.log('‚úÖ refreshTravelTimes f√§rdig');
};

async function getAppleMapsAccessToken(context) {
  try {
    const jwt = require('jsonwebtoken');
    const fs = require('fs');

    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n') ||
                       fs.readFileSync(process.env.APPLE_MAPS_KEY_PATH, 'utf8');

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context.log('‚ö†Ô∏è Misslyckades h√§mta Apple Maps token:', err.message);
    return null;
  }
}
END: index.js

====================
üìÑ Fil: shared/calendar/appleCalendar.js
üìÖ Senast √§ndrad: 2025-05-20 12:13:20
üìè Antal rader: 76
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ['const fetch = require("node-fetch");', 'const xml2js = require("xml2js");']
üîç L√§ngsta funktion: 14 rader
üß† Komplexitetspo√§ng: 7
üß™ TODO/FIXME: 0
====================
START: appleCalendar.js
console.log("üß™ appleCalendar.js laddades");
const fetch = require("node-fetch");
const xml2js = require("xml2js");

function createAppleClient(context) {
  return {
    async getEvent(calendarId, eventId) {
      const caldavUrl = process.env.CALDAV_CALENDAR_URL;
      const username = process.env.CALDAV_USER;
      const password = process.env.CALDAV_PASSWORD;

      if (!caldavUrl || !username || !password) {
        context.log("‚ö†Ô∏è Missing CalDAV credentials");
        return null;
      }

      try {
        const res = await fetch(caldavUrl, {
          method: "PROPFIND",
          headers: {
            "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64"),
            "Content-Type": "application/xml",
            "Depth": "1"
          },
          body: `<?xml version="1.0"?>
            <d:propfind xmlns:d="DAV:">
              <d:prop>
                <d:getetag/>
                <d:calendar-data xmlns="urn:ietf:params:xml:ns:caldav"/>
              </d:prop>
            </d:propfind>`
        });

        if (!res.ok) {
          context.log("‚ö†Ô∏è CalDAV fetch failed:", res.statusText);
          return null;
        }

        const xml = await res.text();
        const parsed = await xml2js.parseStringPromise(xml, { explicitArray: false });
        const responses = parsed['d:multistatus']?.['d:response'];
        let calendarData;

        if (Array.isArray(responses)) {
          for (const response of responses) {
            const data = response['d:propstat']?.['d:prop']?.['cal:calendar-data'];
            if (data) {
              calendarData = data;
              break;
            }
          }
        } else {
          calendarData = responses?.['d:propstat']?.['d:prop']?.['cal:calendar-data'];
        }

        if (!calendarData) {
          context.log("‚ö†Ô∏è No calendar-data found in CalDAV response.");
          return null;
        }

        const locationMatch = calendarData.match(/LOCATION:(.*)/);
        const endTimeMatch = calendarData.match(/DTEND(?:;[^:]*)?:(.*)/);

        const location = locationMatch ? locationMatch[1].trim() : null;
        const endTime = endTimeMatch ? endTimeMatch[1].trim() : null;

        return { location, endTime };
      } catch (err) {
        context.log("‚ö†Ô∏è Error parsing CalDAV response:", err.message);
        return null;
      }
    }
  };
}

module.exports = createAppleClient;
END: appleCalendar.js

====================
üìÑ Fil: shared/calendar/getMsToken.js
üìÖ Senast √§ndrad: 2025-05-20 12:13:32
üìè Antal rader: 30
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 1 ‚Äì ["const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 4 rader
üß† Komplexitetspo√§ng: 2
üß™ TODO/FIXME: 0
====================
START: getMsToken.js
console.log("üß™ getMsToken.js laddades");
const fetch = require('node-fetch');

module.exports = async function getMsToken(context) {
  try {
    const tokenEndpoint = `https://login.microsoftonline.com/${process.env.MS365_TENANT_ID}/oauth2/v2.0/token`;
    const params = new URLSearchParams();
    params.append('client_id', process.env.MS365_CLIENT_ID);
    params.append('client_secret', process.env.MS365_CLIENT_SECRET);
    params.append('scope', 'https://graph.microsoft.com/.default');
    params.append('grant_type', 'client_credentials');

    const res = await fetch(tokenEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params
    });

    if (!res.ok) {
      context.log(`‚ö†Ô∏è Tokenh√§mtning misslyckades: ${res.statusText}`);
      return null;
    }

    const data = await res.json();
    return data.access_token;
  } catch (err) {
    context.log(`‚ö†Ô∏è Tokenh√§mtning fel: ${err.message}`);
    return null;
  }
};
END: getMsToken.js

====================
üìÑ Fil: shared/calendar/msGraph.js
üìÖ Senast √§ndrad: 2025-05-20 12:13:51
üìè Antal rader: 65
üß© Antal funktioner: 3
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 3 ‚Äì ['const { Client } = require("@microsoft/microsoft-graph-client");', 'require("isomorphic-fetch");', 'const fetch = require("node-fetch");']
üîç L√§ngsta funktion: 3 rader
üß† Komplexitetspo√§ng: 3
üß™ TODO/FIXME: 0
====================
START: msGraph.js
console.log("üß™ msGraph.js laddades");
const { Client } = require("@microsoft/microsoft-graph-client");
require("isomorphic-fetch");
const fetch = require("node-fetch");

function createMsGraphClient() {
  let token = null;

  async function getAccessToken() {
    const tenantId = process.env.MS365_TENANT_ID;
    const clientId = process.env.MS365_CLIENT_ID;
    const clientSecret = process.env.MS365_CLIENT_SECRET;

    const tokenEndpoint = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`;
    const params = new URLSearchParams();
    params.append("client_id", clientId);
    params.append("client_secret", clientSecret);
    params.append("scope", "https://graph.microsoft.com/.default");
    params.append("grant_type", "client_credentials");

    const res = await fetch(tokenEndpoint, {
      method: "POST",
      body: params
    });

    if (!res.ok) {
      console.error(`‚ö†Ô∏è Token fetch failed: ${res.statusText}`);
      throw new Error(`Token fetch failed: ${res.statusText}`);
    }
    const data = await res.json();
    token = data.access_token;
    return token;
  }

  async function getEvent(calendarId, eventId) {
    try {
      if (!calendarId || !eventId) {
        console.warn("‚ùå getEvent missing calendarId or eventId (Graph)");
        return null;
      }

      const authToken = token || await getAccessToken();
      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const result = await client
        .api(`/users/${calendarId}/events/${encodeURIComponent(eventId)}`)
        .select("location,end")
        .get();

      const location = result.location?.displayName || null;
      const endTime = result.end?.dateTime || null;

      return { location, endTime };
    } catch (err) {
      console.error("‚ö†Ô∏è getEvent error (Graph):", err.message);
      return null;
    }
  }

  return { getEvent };
}

module.exports = createMsGraphClient;
END: msGraph.js

====================
üìÑ Fil: shared/calendar/resolveOrigin.js
üìÖ Senast √§ndrad: 2025-05-20 12:14:46
üìè Antal rader: 134
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 6 rader (4.5%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 21
üß™ TODO/FIXME: 0
====================
START: resolveOrigin.js
console.log("üß™ resolveOrigin.js laddades");
const memoryCache = {};

async function resolveOriginAddress({ eventId, calendarId, pool, context, graphClient, appleClient, fallbackOrigin, settings }) {
  const cacheKey = `${calendarId}:${eventId}`;
  const debugLog = (msg) => {
    if (process.env.DEBUG === 'true' && context?.log) context.log(msg);
  };
  debugLog(`üîç resolveOriginAddress ‚Üí calendarId: ${calendarId}, eventId: ${eventId}`);
  const eventDateOnly = eventId.split('T')[0];
  if (memoryCache[cacheKey]) {
    // Provide originEndTime as well
    let originEndTime = null;
    if (memoryCache[cacheKey].originSource === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = memoryCache[cacheKey].originEndTime || null;
    }
    debugLog(`‚úÖ Hittade origin fr√•n cache: ${memoryCache[cacheKey].origin}`);
    return {
      origin: memoryCache[cacheKey].origin,
      originSource: memoryCache[cacheKey].originSource,
      originEndTime
    };
  }


  // Try database cache first
  let dbRes;
  try {
    dbRes = await pool.query(
      'SELECT address, source, end_time FROM calendar_origin_cache WHERE event_date = $1',
      [eventDateOnly]
    );
    debugLog(`üìÇ DB-kontroll: Hittade ${dbRes?.rows?.length || 0} rader f√∂r ${eventDateOnly}`);
  } catch (err) {
    context.log(`‚ö†Ô∏è DB error in resolveOriginAddress: ${err.message}`);
  }
  if (dbRes && dbRes.rows && dbRes.rows.length > 0) {
    let originEndTime = null;
    if (dbRes.rows[0].source === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = dbRes.rows[0].end_time || null;
    }
    memoryCache[cacheKey] = {
      origin: dbRes.rows[0].address,
      originSource: dbRes.rows[0].source,
      originEndTime: originEndTime
    };
    debugLog(`‚úÖ Hittade origin fr√•n DB: ${dbRes.rows[0].address}`);
    return {
      origin: dbRes.rows[0].address,
      originSource: dbRes.rows[0].source,
      originEndTime
    };
  }
  debugLog(`üï≥Ô∏è Inget cachetr√§ff i DB f√∂r ${eventDateOnly}`);

  // Try fetching from MS Graph
  let latestOrigin;
  let originSource = 'unknown';
  if (graphClient && typeof graphClient.getEvent === 'function') {
    try {
      const msEvent = await graphClient.getEvent(calendarId, eventId);
      if (msEvent && msEvent.location) {
        latestOrigin = msEvent.location;
        originSource = 'msgraph';
        debugLog(`‚úÖ Hittade origin fr√•n MS Graph: ${latestOrigin}`);
      }
    } catch (err) {
      context.log(`‚ö†Ô∏è MS Graph error in resolveOriginAddress: ${err.message}`);
    }
  } else if (graphClient) {
    context.log(`‚ö†Ô∏è graphClient saknar getEvent-metod eller √§r null`);
  }

  // Try fetching from Apple calendar if not found
  if (!latestOrigin && appleClient && typeof appleClient.getEvent === 'function') {
    try {
      const appleEvent = await appleClient.getEvent(calendarId, eventId);
      if (appleEvent && appleEvent.location) {
        latestOrigin = appleEvent.location;
        originSource = 'apple';
        debugLog(`‚úÖ Hittade origin fr√•n Apple: ${latestOrigin}`);
      }
    } catch (err) {
      context.log(`‚ö†Ô∏è Apple error in resolveOriginAddress: ${err.message}`);
    }
  } else if (!latestOrigin && appleClient) {
    context.log(`‚ö†Ô∏è appleClient saknar getEvent-metod eller √§r null`);
  }

  // Fallback if not found
  if (!latestOrigin) {
    debugLog(`üö® Ingen tr√§ff i varken cache, DB, Graph eller Apple ‚Äì anv√§nder fallback`);
    latestOrigin = fallbackOrigin || '';
    originSource = 'fallback';
    debugLog(`‚ö†Ô∏è Fallback anv√§nds som origin: ${latestOrigin}`);
  }

  // Write to DB cache unless fallback
  let originEndTime = null;
  if (originSource === 'fallback') {
    originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
  }
  if (originSource !== 'fallback') {
    try {
      await pool.query(
        `INSERT INTO calendar_origin_cache (event_date, source, address, end_time)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT DO NOTHING`,
        [eventDateOnly, originSource, latestOrigin, originEndTime]
      );
    } catch (err) {
      context.log(`‚ö†Ô∏è DB write error in resolveOriginAddress: ${err.message}`);
    }
  }

  memoryCache[cacheKey] = {
    origin: latestOrigin,
    originSource,
    originEndTime
  };
  debugLog(`üß† resolveOriginAddress resultat: ${latestOrigin} (k√§lla: ${originSource})`);
  context.log(`üì§ resolveOriginAddress return: ${latestOrigin} (k√§lla: ${originSource}, endTime: ${originEndTime?.toISOString?.() || 'null'})`);
  return { origin: latestOrigin, originSource, originEndTime };
}

module.exports = { resolveOriginAddress };

if (process.env.NODE_ENV === 'test') {
  module.exports._test = { memoryCache };
}
END: resolveOrigin.js

====================
üìÑ Fil: shared/config/settingsLoader.js
üìÖ Senast √§ndrad: 2025-05-20 12:15:12
üìè Antal rader: 40
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 4 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: settingsLoader.js
console.log("üß™ settingsLoader.js laddades");
module.exports = async function loadSettings(pool, context) {
  try {
    const settings = {};
    const isDebug = process.env.DEBUG === 'true';
    const debugLog = (msg) => {
      if (isDebug && context && context.log) {
        context.log(msg);
      }
    };
    debugLog('‚öôÔ∏è B√∂rjar l√§sa booking_settings...');
    const settingsRes = await pool.query('SELECT key, value, value_type FROM booking_settings');
    debugLog(`üì¶ ${settingsRes.rows.length} inst√§llningar h√§mtade`);
    for (const row of settingsRes.rows) {
      debugLog(`üîë ${row.key} = ${row.value} (${row.value_type})`);
      if (
        row.value_type === 'json' ||
        row.value_type === 'array' ||
        (typeof row.value_type === 'string' && /\[\]$/.test(row.value_type))
      ) {
        try {
          settings[row.key] = JSON.parse(typeof row.value === 'string' ? row.value : JSON.stringify(row.value));
        } catch (_) {}
      } else if (row.value_type === 'int') {
        settings[row.key] = parseInt(row.value);
      } else if (row.value_type === 'bool') {
        settings[row.key] = row.value === 'true' || row.value === true;
      } else if (row.value_type === 'string') {
        settings[row.key] = String(row.value).replace(/^"(.*)"$/, '$1');
      } else {
        settings[row.key] = row.value;
      }
    }
    debugLog('‚úÖ Alla inst√§llningar tolkade och klara');
    return settings;
  } catch (err) {
    context.log(`‚ö†Ô∏è Fel vid laddning av booking_settings: ${err.message}`);
    throw err;
  }
};
END: settingsLoader.js

====================
üìÑ Fil: shared/config/verifySettings.js
üìÖ Senast √§ndrad: 2025-05-20 12:15:11
üìè Antal rader: 52
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 24 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: verifySettings.js
console.log("üß™ verifySettings.js laddades");
function verifyBookingSettings(settings, context) {
  const expected = {
    default_office_address: 'string',
    default_home_address: 'string',
    fallback_travel_time_minutes: 'number',
    buffer_between_meetings: 'number',
    default_meeting_length_atoffice: 'array',
    default_meeting_length_atclient: 'array',
    default_meeting_length_digital: 'array',
    meeting_types: 'array',
    block_weekends: 'boolean',
    open_time: 'string',
    close_time: 'string',
    lunch_start: 'string',
    lunch_end: 'string',
    travel_time_window_start: 'string',
    travel_time_window_end: 'string',
    require_approval: 'boolean',
    max_days_in_advance: 'number',
    max_weekly_booking_minutes: 'number',
    cache_ttl_minutes: 'number',
    allowed_atclient_meeting_days: 'array',
    timezone: 'string'
  };

  const issues = [];
  for (const [key, type] of Object.entries(expected)) {
    const val = settings[key];
    if (val === undefined || val === null || (key === 'timezone' && String(val).trim() === '')) {
      issues.push(`‚ùå Saknar inst√§llning: ${key}`);
    } else if (key === 'allowed_atclient_meeting_days') {
      if (!Array.isArray(val) || !val.every(v => typeof v === 'string')) {
        issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: ska vara array av str√§ngar`);
      }
    } else if (key === 'require_approval') {
      if (typeof val !== 'boolean') {
        issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: ska vara boolean`);
      }
    } else if (type === 'array' ? !Array.isArray(val) : typeof val !== type) {
      issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: har ${typeof val}, f√∂rv√§ntade ${type}`);
    }
  }

  if (issues.length > 0) {
    const message = 'üõë Problem med booking_settings:\n' + issues.join('\n');
    context.log.warn(message);
    throw new Error(message);
  }
}

module.exports = verifyBookingSettings;
END: verifySettings.js

====================
üìÑ Fil: shared/db/pgPool.js
üìÖ Senast √§ndrad: 2025-05-20 12:09:51
üìè Antal rader: 14
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 1 ‚Äì ["const { Pool } = require('pg');"]
üîç L√§ngsta funktion: 7 rader
üß† Komplexitetspo√§ng: 0
üß™ TODO/FIXME: 0
====================
START: pgPool.js
const { Pool } = require('pg');

console.log("üß™ shared/db/pgPool.js laddades");

const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: { rejectUnauthorized: false }
});

module.exports = pool;
END: pgPool.js

====================
üìÑ Fil: shared/maps/appleMaps.js
üìÖ Senast √§ndrad: 2025-05-20 12:15:38
üìè Antal rader: 121
üß© Antal funktioner: 5
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ["const jwt = require('jsonwebtoken');", "const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 10 rader
üß† Komplexitetspo√§ng: 9
üß™ TODO/FIXME: 0
====================
START: appleMaps.js
console.log("üß™ appleMaps.js laddades");
const jwt = require('jsonwebtoken');
const fetch = require('node-fetch');

async function getAppleMapsAccessToken(context) {
  try {
    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n');

    if (!privateKey) {
      throw new Error('Apple Maps private key saknas ‚Äì kontrollera APPLE_MAPS_PRIVATE_KEY');
    }

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context?.log?.('‚ö†Ô∏è Misslyckades h√§mta Apple Maps token:', err.message);
    if (err.code === 'EAI_AGAIN') {
      context?.log?.('üåê DNS-fel (EAI_AGAIN) ‚Äì kunde inte n√• servern:', err.message);
    }
    return null;
  }
}


async function getTravelTimeInMinutes(origin, destination, departureTime, accessToken, context) {
  try {
    const url = `https://maps-api.apple.com/v1/directions?origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&departureTime=${encodeURIComponent(departureTime)}&transportType=automobile&includeTravelTimeBreakdown=true`;

    const res = await fetch(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });

    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`‚ùå Apple Maps-directions misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const travelTimeSeconds = data.routes?.[0]?.expectedTravelTime;
    return travelTimeSeconds ? Math.ceil(travelTimeSeconds / 60) : null;
  } catch (err) {
    context?.log?.(`‚ùå Fel vid directions-anrop: ${err.message}`);
    return null;
  }
}

async function getTravelTime(origin, destination, departureTime, context) {
  try {
    const token = await getAppleMapsAccessToken(context);
    if (!token) {
      context?.log?.('‚ö†Ô∏è Kunde inte h√§mta Apple Maps-token');
      return null;
    }
    return await getTravelTimeInMinutes(origin, destination, departureTime, token, context);
  } catch (err) {
    context?.log?.(`‚ùå Fel i getTravelTime: ${err.message}`);
    return null;
  }
}

async function safeGetTravelTime(origin, destination, departureTime, accessToken, context) {
  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', origin);
    url.searchParams.append('destination', destination);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', departureTime);

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 8000); // max 8s

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` },
      signal: controller.signal
    });

    clearTimeout(timeout);
    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`‚ùå Apple Maps misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const seconds = data.routes?.[0]?.durationSeconds || data.routes?.[0]?.expectedTravelTime;
    return seconds ? Math.round(seconds / 60) : null;
  } catch (err) {
    context?.log?.(`‚ö†Ô∏è safeGetTravelTime error: ${err.message}`);
    return null;
  }
}

module.exports = {
  getAppleMapsAccessToken,
  getTravelTimeInMinutes,
  getTravelTime,
  safeGetTravelTime
};
END: appleMaps.js

====================
üìÑ Fil: shared/maps/returnTravelVerifier.js
üìÖ Senast √§ndrad: 2025-05-20 12:16:01
üìè Antal rader: 66
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 1 rader (1.5%)
üì• Imports: 1 ‚Äì ["const { URL } = require('url');"]
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 4
üß™ TODO/FIXME: 0
====================
START: returnTravelVerifier.js
console.log("üß™ returnTravelVerifier.js laddades");
const { URL } = require('url');

async function verifyReturnTravelFeasibility({
  previousBooking,
  contact,
  slotTime,
  settings,
  accessToken,
  db,
  context,
  travelCache
}) {
  const from = previousBooking.address || settings.default_office_address;
  const to = `${contact.metadata.address} ${contact.metadata.postal_code} ${contact.metadata.city}`;
  const prevEnd = new Date(previousBooking.end);

  if (from === to) {
    context.log(`üíæ Returrestid √§r 0 min (${from} ‚Üí ${to}) ‚Äì ingen cache beh√∂vs`);
    return { isFeasible: true };
  }

  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', from);
    url.searchParams.append('destination', to);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', prevEnd.toISOString());

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` }
    });

    const data = await res.json();
    const returnMinutes = Math.round((data.routes?.[0]?.durationSeconds || 0) / 60);
    const arrivalTime = new Date(prevEnd.getTime() + returnMinutes * 60000);

    // Cache return time in memory and DB
    const hour = prevEnd.getUTCHours();
    const returnCacheKey = `${from}|${to}|${hour}`;
    travelCache.set(returnCacheKey, returnMinutes);
    if (from && to) {
      await db.query(`
        INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (from_address, to_address, hour)
        DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes
      `, [from, to, hour, returnMinutes]);
      context.log(`üíæ Returrestid sparad: ${returnMinutes} min (${from} ‚Üí ${to} @ ${hour}:00)`);
    } else {
      context.log(`‚ö†Ô∏è Hoppar caching av retur ‚Äì saknar from_address (${from}) eller to_address (${to})`);
    }

    if (arrivalTime > slotTime) {
      context.log(`‚õî Slot ${slotTime.toISOString()} avvisad ‚Äì retur fr√•n tidigare m√∂te hinner inte fram i tid (ankomst ${arrivalTime.toISOString()})`);
      return { isFeasible: false, reason: 'retur hinner inte fram', arrivalTime };
    }

    return { isFeasible: true };
  } catch (err) {
    context.log(`‚ö†Ô∏è Kunde inte verifiera returrestid fr√•n tidigare m√∂te: ${err.message}`);
    return { isFeasible: true }; // fail open
  }
}

module.exports = { verifyReturnTravelFeasibility };
END: returnTravelVerifier.js

====================
üìÑ Fil: shared/maps/resolveTravelTime.js
üìÖ Senast √§ndrad: 2025-05-20 20:15:18
üìè Antal rader: 67
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 7
üß™ TODO/FIXME: 0
====================
START: resolveTravelTime.js
console.log("üß™ travelTimeResolver.js laddades");
async function resolveTravelTime({ origin, destination, hour, db, accessToken, context }) {
  let travelTimeMin = 20;
  const cacheKey = `${origin}|${destination}|${hour}`;
  let cacheHit = false;
  let isFallback = false;

  if (!origin || !destination) {
    context.log(`‚ö†Ô∏è Kan inte ber√§kna restid ‚Äì origin eller destination saknas`);
    return { travelTimeMin, cacheHit: false, isFallback };
  }

  if (!db || typeof db.query !== 'function') {
    context.log(`‚ùå db saknas eller saknar query-metod i resolveTravelTime`);
    return { travelTimeMin, cacheHit: false, isFallback: true };
  }

  try {
    const cacheRes = await db.query(
      `SELECT travel_minutes, is_fallback FROM travel_time_cache WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
      [origin, destination, hour]
    );
    if (cacheRes.rows.length > 0) {
      travelTimeMin = cacheRes.rows[0].travel_minutes;
      isFallback = cacheRes.rows[0].is_fallback === true;
      cacheHit = true;
      context.log(`‚ö° Cache hit (db): ${origin} ‚Üí ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
    }
  } catch (err) {
    context.log(`‚ö†Ô∏è Kunde inte l√§sa fr√•n travel_time_cache: ${err.message}`);
  }

  if (!cacheHit && accessToken) {
    try {
      const url = new URL('https://maps-api.apple.com/v1/directions');
      url.searchParams.append('origin', origin);
      url.searchParams.append('destination', destination);
      url.searchParams.append('transportType', 'automobile');
      url.searchParams.append('departureTime', new Date().toISOString());

      const res = await fetch(url.toString(), {
        headers: { Authorization: `Bearer ${accessToken}` }
      });
      const data = await res.json();
      const travelSeconds = data.routes?.[0]?.durationSeconds;
      if (travelSeconds) {
        travelTimeMin = Math.round(travelSeconds / 60);
        await db.query(
          `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes, is_fallback)
           VALUES ($1, $2, $3, $4, false)
           ON CONFLICT (from_address, to_address, hour)
           DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes, is_fallback = false`,
          [origin, destination, hour, travelTimeMin]
        );
        context.log(`üíæ Sparade Apple Maps-restid i cache: ${origin} ‚Üí ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
      } else {
        context.log(`‚ö†Ô∏è Apple Maps-data saknas ‚Äì anv√§nder fallback`);
      }
    } catch (err) {
      context.log(`‚ö†Ô∏è Fel vid Apple Maps-anrop: ${err.message}`);
    }
  }

  return { travelTimeMin, cacheHit, isFallback };
}

module.exports = { resolveTravelTime };
END: resolveTravelTime.js

====================
üìÑ Fil: bookings/index.js
üìÖ Senast √§ndrad: 2025-05-19 09:53:06
üìè Antal rader: 233
üß© Antal funktioner: 5
üí¨ Kommentarst√§ckning: 6 rader (2.6%)
üì• Imports: 3 ‚Äì ["const { Pool } = require('pg');", "const { v4: uuidv4 } = require('uuid');", "const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 8 rader
üß† Komplexitetspo√§ng: 19
üß™ TODO/FIXME: 0
====================
START: index.js
const { Pool } = require('pg');
const { v4: uuidv4 } = require('uuid');

module.exports = async function (context, req) {
  const requiredFields = ['meeting_type', 'meeting_length', 'slot_iso'];
  const missing = requiredFields.filter(k => !req.body?.[k]);

  if (missing.length > 0) {
    context.res = { status: 400, body: { error: `Missing fields: ${missing.join(', ')}` } };
    return;
  }

  const { email, meeting_type, meeting_length, slot_iso, metadata = {} } = req.body;

  const parsedLength = parseInt(meeting_length, 10);
  if (isNaN(parsedLength) || parsedLength <= 0) {
    context.res = { status: 400, body: { error: "Invalid meeting_length" } };
    return;
  }

  const parsedStart = new Date(slot_iso);
  if (isNaN(parsedStart.getTime())) {
    context.res = { status: 400, body: { error: "Invalid slot_iso datetime" } };
    return;
  }

  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.res = { status: 500, body: { error: `Missing environment variable: ${key}` } };
      return;
    }
  }

  const pool = new Pool({
    user: process.env.PGUSER,
    host: process.env.PGHOST,
    database: process.env.PGDATABASE,
    password: process.env.PGPASSWORD,
    port: parseInt(process.env.PGPORT || '5432', 10),
    ssl: { rejectUnauthorized: false }
  });

  const db = await pool.connect();
  try {
    // L√§s in booking_settings
    const settingsRes = await db.query('SELECT key, value, value_type FROM booking_settings');
    const settings = {};
    for (const row of settingsRes.rows) {
      let val = row.value;
      if (row.value_type === 'int') {
        val = parseInt(val);
      } else if (row.value_type === 'bool') {
        val = val === 'true' || val === true;
      } else if (row.value_type === 'json' || row.value_type === 'array') {
        try {
          val = JSON.parse(typeof val === 'string' ? val : JSON.stringify(val));
        } catch (_) {}
      } else if (typeof val === 'string') {
        val = val.replace(/^"(.*)"$/, '$1'); // trimma citattecken
      }
      settings[row.key] = val;
    }

    const id = uuidv4();
    // Kontrollera om en bokning redan finns
    const existing = await db.query(
      'SELECT id FROM bookings WHERE contact_id = $1 AND start_time = $2',
      [metadata.contact_id || null, parsedStart.toISOString()]
    );
    if (existing.rowCount > 0) {
      context.res = {
        status: 409,
        body: { error: 'Booking already exists for this time.' }
      };
      return;
    }
    const startTime = parsedStart;
    const endTime = new Date(startTime.getTime() + parsedLength * 60000);
    const created_at = new Date();
    const updated_at = created_at;

    // Bygg meeting_link dynamiskt
    let meeting_link = null;
    if (meeting_type.toLowerCase() === 'teams') {
      meeting_link = 'https://teams.microsoft.com/l/meetup-join/...'; // placeholder
    } else if (meeting_type.toLowerCase() === 'zoom') {
      meeting_link = 'https://zoom.us/j/1234567890'; // placeholder
    } else if (meeting_type.toLowerCase() === 'facetime' && metadata.phone) {
      meeting_link = `facetime:${metadata.phone}`;
    }

    const fields = {
      id,
      start_time: startTime.toISOString(),
      end_time: endTime.toISOString(),
      meeting_type,
      metadata: JSON.stringify(metadata),
      created_at,
      updated_at,
      contact_id: metadata.contact_id || null,
      booking_email: email || null
    };

    const query = `
      INSERT INTO bookings (
        id, start_time, end_time, meeting_type,
        metadata, created_at, updated_at,
        contact_id, booking_email
      ) VALUES (
        $1, $2, $3, $4,
        $5, $6, $7,
        $8, $9
      )
    `;

    const values = Object.values(fields);
    await db.query(query, values);
    // Logga pending change f√∂r denna bokning
    await db.query(
      `INSERT INTO pending_changes (id, table_name, record_id, change_type, direction, processed, created_at, booking_id)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        uuidv4(),
        'bookings',
        id,
        'INSERT',
        'cloud_to_local',
        false,
        new Date(),
        id
      ]
    );
    // Simulera att kalendern synkades f√∂r denna demo
    fields.synced_to_calendar = true;
    await db.query(
      'INSERT INTO event_log (event_type, booking_id) VALUES ($1, $2)',
      ['booking_created', id]
    );

    context.res = {
      status: 200,
      body: {
        status: 'booked',
        booking_id: id,
        calendar_invite_sent: false // kan uppdateras om Graph-mail l√§ggs in h√§r
      }
    };
  } catch (err) {
    context.res = {
      status: 500,
      body: { error: err.message }
    };
  } finally {
    db.release();
  }
};

// --- Send confirmation email via Microsoft Graph ---
const fetch = require('node-fetch');

async function sendConfirmationEmail({ to, startTime, endTime, meeting_type, meeting_link, first_name, sender_email }) {
  const token = await getGraphAccessToken();

  const subject = `Din bokning √§r bekr√§ftad ‚Äì ${meeting_type}`;
  const content = `
    <p>Hej ${first_name || ''},</p>
    <p>Din bokning den ${startTime.toLocaleDateString()} kl ${startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} √§r nu bekr√§ftad.</p>
    <p><strong>M√∂testyp:</strong> ${meeting_type}</p>
    <p><strong>L√§nk:</strong> <a href="${meeting_link}">${meeting_link}</a></p>
    <p>Vi ser fram emot att ses!</p>
    <p>V√§nligen,<br/>Daniel</p>
  `;

  const body = {
    message: {
      subject,
      body: {
        contentType: 'HTML',
        content
      },
      toRecipients: [
        {
          emailAddress: {
            address: to
          }
        }
      ]
    },
    saveToSentItems: true
  };

  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 8000); // max 8s

  const response = await fetch(`https://graph.microsoft.com/v1.0/users/${encodeURIComponent(sender_email)}/sendMail`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body),
    signal: controller.signal
  });

  clearTimeout(timeout);

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`E-postmisslyckande: ${err}`);
  }
}

async function getGraphAccessToken() {
  const params = new URLSearchParams();
  params.append('client_id', process.env.GRAPH_CLIENT_ID);
  params.append('client_secret', process.env.GRAPH_CLIENT_SECRET);
  params.append('scope', 'https://graph.microsoft.com/.default');
  params.append('grant_type', 'client_credentials');
  const response = await fetch(`https://login.microsoftonline.com/${process.env.GRAPH_TENANT_ID}/oauth2/v2.0/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: params
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`Misslyckad tokenh√§mtning: ${err}`);
  }

  const data = await response.json();
  return data.access_token;
}
END: index.js

====================
üìÑ Fil: shared/utils/debugLogger.js
üìÖ Senast √§ndrad: 2025-05-20 12:16:50
üìè Antal rader: 23
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 8 rader
üß† Komplexitetspo√§ng: 2
üß™ TODO/FIXME: 0
====================
START: debugLogger.js
console.log("üß™ debugLogger.js laddades");

function createDebugLogger(context) {
  const isDebug = process.env.DEBUG === 'true';
  const skipReasons = {};

  const debugLog = (msg) => {
    if (msg.startsWith('‚õî') || msg.startsWith('üçΩÔ∏è') || msg.startsWith('üìõ')) {
      const reason = msg.split(' ‚Äì ')[0];
      skipReasons[reason] = (skipReasons[reason] || 0) + 1;
    }
    if (isDebug && context?.log) {
      context.log(msg);
    }
  };

  return {
    debugLog,
    getSkipSummary: () => skipReasons
  };
}

module.exports = { createDebugLogger };
END: debugLogger.js

====================
üìÑ Fil: shared/slots/slotEngine.js
üìÖ Senast √§ndrad: 2025-05-20 19:53:15
üìè Antal rader: 149
üß© Antal funktioner: 4
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 6 ‚Äì ["const pool = require('../db/pgPool');", 'const { DateTime } = require("luxon");', 'const { resolveOriginAddress } = require("../calendar/resolveOrigin");', 'const { resolveTravelTime } = require("../maps/travelTimeResolver");', 'const msGraph = require("../calendar/msGraph");', 'const appleCalendar = require("../calendar/appleCalendar");']
üîç L√§ngsta funktion: 9 rader
üß† Komplexitetspo√§ng: 11
üß™ TODO/FIXME: 0
====================
START: slotEngine.js
console.log("üß™ slotEngine.js laddades");

const pool = require('../db/pgPool');

const { DateTime } = require("luxon");
const { resolveOriginAddress } = require("../calendar/resolveOrigin");
const { resolveTravelTime } = require("../maps/travelTimeResolver");
const msGraph = require("../calendar/msGraph");
const appleCalendar = require("../calendar/appleCalendar");

async function generateSlotCandidates({ day, settings, contact, pool, context }) {
  const timezone = settings.timezone || "Europe/Stockholm";
  const hoursToTry = [10, 14];
  const slots = [];

  for (const hour of hoursToTry) {
    const eventId = `${day}T${hour.toString().padStart(2, "0")}:00:00.000Z`;
    const dateObj = new Date(eventId);
    const weekday = dateObj.toLocaleDateString("en-US", { weekday: "long", timeZone: timezone }).toLowerCase();
    const slot_part = hour < 12 ? "fm" : "em";

    const originInfo = await resolveOriginAddress({
      eventId,
      calendarId: contact.contact_id,
      pool,
      context,
      graphClient: msGraph,
      appleClient: appleCalendar,
      fallbackOrigin: settings.default_home_address,
      settings
    });

    if (!originInfo?.origin) {
      context.log(`‚ö†Ô∏è Kunde inte fastst√§lla origin f√∂r ${eventId}`);
      continue;
    }

    const destination = settings.default_office_address;
    const { travelTimeMin } = await resolveTravelTime({
      origin: originInfo.origin,
      destination,
      hour,
      db: pool,
      accessToken: context.accessToken || null,
      context
    });

    if (!travelTimeMin || typeof travelTimeMin !== "number") {
      context.log.warn(`‚ö†Ô∏è Ogiltig restid, hoppar slot: ${eventId}`);
      continue;
    }

    slots.push({
      slot_iso: eventId,
      slot_local: DateTime.fromJSDate(dateObj).setZone(timezone).toISO(),
      travel_time_min: travelTimeMin,
      origin: originInfo.origin,
      originEndTime: originInfo.originEndTime,
      source: originInfo.originSource,
      require_approval: settings.require_approval,
      meeting_length: settings.default_meeting_length_digital?.[0] || 20,
      weekday,
      slot_part
    });
  }

  return slots;
}


async function generateSlotChunks({
  days,
  context,
  contact,
  contact_id,
  meeting_type,
  meeting_length,
  bookingsByDay,
  weeklyMinutesByType,
  settings,
  graphClient,
  appleClient,
  travelCache,
  accessToken,
  timezone,
  debugHelper
}) {
  const { debugLog, skipReasons } = debugHelper || {};
  const slotMap = {};
  const chosen = [];

  if (days.length === 0) {
    const fallbackDate = new Date().toISOString().split('T')[0];
    const { rows } = await pool.query(
      'SELECT slots FROM slot_cache WHERE slot_day = $1 LIMIT 1',
      [fallbackDate]
    );
    if (rows.length > 0) {
      context.log(`üü° Anv√§nder slot_cache som fallback (${fallbackDate})`);
      return {
        chosenSlots: rows[0].slots || [],
        slotMapResult: {},
        slotLogSummary: { 'fallback_used': 1 }
      };
    }
  }

  for (const day of days) {
    const dayStr = day.toISOString().split("T")[0];
    const slotCandidates = await generateSlotCandidates({
      day: dayStr,
      settings,
      contact,
      pool: context.client || pool,
      context
    });

    for (const slot of slotCandidates) {
      const key = `${dayStr}_${slot.slot_part}`;
      if (!slotMap[key]) slotMap[key] = [];
      slotMap[key].push(slot);
    }
  }

  for (const [key, candidates] of Object.entries(slotMap)) {
    if (candidates.length === 0) continue;

    const alreadyPicked = slotGroupPicked[key];
    if (alreadyPicked) {
      debugLog?.(`üü° Slotgrupp '${key}' redan vald tidigare ‚Äì hoppar`);
      continue;
    }

    const best = candidates.sort((a, b) => (b.score || 0) - (a.score || 0))[0] || candidates[0];
    slotGroupPicked[key] = true;
    chosen.push(best);
  }

  return {
    chosenSlots: chosen.sort((a, b) => new Date(a.slot_iso) - new Date(b.slot_iso)),
    slotMapResult: slotMap,
    slotLogSummary: skipReasons
  };
}

module.exports = {
  generateSlotCandidates,
  generateSlotChunks
};
END: slotEngine.js

üìÅ KONFIGURATIONSFILER (function.json / host.json / package.json / .funcignore)
====================================

üìÑ .funcignore
   # Exclude dev-only files and folders
   .git
   .vscode
   .env
   *.log
   test/
   tests/
   
   # Explicitly include all required files and folders
   !host.json
   !package.json
   !package-lock.json
   
   !node_modules/
   !node_modules/**
   
   !shared/
   !shared/**
   
   !bookings/
   !bookings/**
   !getavailableslots/
   !getavailableslots/**
   !validate_contact/
   !validate_contact/**
   !meeting_types/
   !meeting_types/**
   !refreshCalendarOrigins/
   !refreshCalendarOrigins/**
   !refreshTravelTimes/
   !refreshTravelTimes/**
üìÑ bookings/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "bookings"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ getavailableslots/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "getavailableslots"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ host.json
   {
     "version": "2.0",
     "extensionBundle": {
       "id": "Microsoft.Azure.Functions.ExtensionBundle",
       "version": "[4.*, 5.0.0)"
     },
     "extensions": {
       "http": {
         "cors": {
           "allowedOrigins": [
             "https://www.klrab.se"
           ],
           "supportCredentials": false
         }
       }
     }
   }
üìÑ meeting_types/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": [ "get" ],
         "route": "meeting_types"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ package.json
   {
     "name": "macspot-api",
     "version": "1.0.0",
     "description": "Azure Functions backend f√∂r MacSpot CRM/ERP",
     "scripts": {
       "start": "func start",
       "dev": "func start --verbose",
       "deploy": "func azure functionapp publish macspotbackend",
       "build": "echo 'Nothing to build'"
     },
     "dependencies": {
       "@azure/functions": "^4.7.0",
       "@azure/msal-node": "^3.5.1",
       "@microsoft/microsoft-graph-client": "^3.0.0",
       "dav": "^1.8.0",
       "dotenv": "^16.5.0",
       "isomorphic-fetch": "^3.0.0",
       "jsonwebtoken": "^9.0.0",
       "luxon": "^3.4.4",
       "node-fetch": "^2.7.0",
       "node-ical": "^0.20.1",
       "pg": "^8.15.6",
       "uuid": "^9.0.0",
       "xml2js": "^0.6.2"
     }
   }

üìÑ refreshCalendarOrigins/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ refreshTravelTimes/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ validate_contact/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post"],
         "route": "validate_contact"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìà SUMMERING AV ALLA JS-FILER
====================================
üìè Totalt antal rader kod: 1565
üß© Totalt antal funktioner: 39
üß† Total komplexitetspo√§ng: 139
üß™ Antal TODO/FIXME totalt: 0

üìä Per fil:
fil,rader,funktioner,komplexitet,kommentarer,imports
index.js,66,2,5,1,1
index.js,128,2,14,1,2
index.js,154,2,10,2,5
index.js,35,1,1,0,4
index.js,112,4,8,0,6
appleCalendar.js,76,2,7,0,2
getMsToken.js,30,1,2,0,1
msGraph.js,65,3,3,0,3
resolveOrigin.js,134,1,21,6,0
settingsLoader.js,40,1,8,0,0
verifySettings.js,52,1,8,0,0
pgPool.js,14,1,0,0,1
appleMaps.js,121,5,9,0,2
returnTravelVerifier.js,66,1,4,1,1
resolveTravelTime.js,67,1,7,0,0
index.js,233,5,19,6,3
debugLogger.js,23,2,2,0,0
slotEngine.js,149,4,11,0,6
üìä MOLNDATABAS (Azure) ‚Äì STRUKTUR & INNEH√ÖLL
====================================

üìÅ Tabell: available_slots_cache
  ‚Ä¢ id (uuid)
  ‚Ä¢ travel_time_min (integer)
  ‚Ä¢ generated_at (timestamp without time zone)
  ‚Ä¢ expires_at (timestamp without time zone)
  ‚Ä¢ meeting_length (integer)
  ‚Ä¢ slot_day (date)
  ‚Ä¢ slot_score (integer)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ slot_part (text)
  ‚Ä¢ slot_iso (text)
  üîë [p] available_slots_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: slot_cache
  ‚Ä¢ created_at (timestamp without time zone)
  ‚Ä¢ slot_day (date)
  ‚Ä¢ slots (jsonb)
  ‚Ä¢ id (uuid)
  ‚Ä¢ meeting_length (integer)
  ‚Ä¢ booking_email (text)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ slot_part (text)
  üîë [p] slot_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: calendar_origin_cache
  ‚Ä¢ created_at (timestamp without time zone)
  ‚Ä¢ timestamp (timestamp with time zone)
  ‚Ä¢ event_date (date)
  ‚Ä¢ id (integer)
  ‚Ä¢ end_time (timestamp without time zone)
  ‚Ä¢ address (text)
  ‚Ä¢ source (text)
  üîë [c] calendar_origin_cache_source_check: CHECK ((source = ANY (ARRAY['Apple Calendar'::text, 'Microsoft 365'::text])))
  üîë [p] calendar_origin_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: travel_time_cache
  ‚Ä¢ hour (integer)
  ‚Ä¢ travel_minutes (integer)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ from_address (text)
  ‚Ä¢ to_address (text)
  üîë [u] unique_travel_key: UNIQUE (from_address, to_address, hour)
  üß™ Topp 5 rader:
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=12, travel_minutes=20, created_at=2025-05-19 08:35:30.341217+00:00, updated_at=2025-05-19 08:35:30.341217+00:00
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=8, travel_minutes=22, created_at=2025-05-19 08:51:46.047719+00:00, updated_at=2025-05-19 08:51:46.047719+00:00
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=10, travel_minutes=23, created_at=2025-05-19 12:00:01.057723+00:00, updated_at=2025-05-19 12:00:01.057723+00:00
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=14, travel_minutes=23, created_at=2025-05-19 12:00:01.639717+00:00, updated_at=2025-05-19 12:00:01.639717+00:00

üìÅ Tabell: event_log
  ‚Ä¢ received_at (timestamp with time zone)
  ‚Ä¢ record_id (uuid)
  ‚Ä¢ timestamp (timestamp with time zone)
  ‚Ä¢ booking_id (uuid)
  ‚Ä¢ id (uuid)
  ‚Ä¢ payload (jsonb)
  ‚Ä¢ action (text)
  ‚Ä¢ event_type (text)
  ‚Ä¢ source (text)
  ‚Ä¢ table_name (text)
  üîë [p] event_log_pkey: PRIMARY KEY (id)
  üß™ Topp 5 rader:
    - source=None, event_type=None, payload=None, received_at=2025-05-16 09:40:53.307336+00:00, id=903c2758-e7e6-4f11-9a31-1871596e195c, action=INSERT, table_name=contact, record_id=c4e2d9dd-545e-4e05-99fe-16d377a87698, timestamp=2025-05-16 09:40:53.307336+00:00, booking_id=None
    - source=None, event_type=booking_created, payload=None, received_at=2025-05-18 11:56:16.897217+00:00, id=fb33d0d1-ff78-4506-82dd-026fd86cd781, action=None, table_name=None, record_id=None, timestamp=2025-05-18 11:56:16.897217+00:00, booking_id=fb6b2112-8dbf-4bed-aba4-c2882989db21
    - source=None, event_type=booking_created, payload=None, received_at=2025-05-18 12:06:54.686150+00:00, id=89690767-0414-4c48-b61d-8f9d350718e5, action=None, table_name=None, record_id=None, timestamp=2025-05-18 12:06:54.686150+00:00, booking_id=3ecff74d-cb9c-4e9f-9db5-b0a7b12666ee
    - source=None, event_type=None, payload=None, received_at=2025-05-18 12:32:42.290134+00:00, id=420ca821-9117-46b4-b9cb-6eedef51f4cb, action=INSERT, table_name=contact, record_id=14e1bef9-2833-40d5-b4fe-7576f7cffd6c, timestamp=2025-05-18 12:32:42.290134+00:00, booking_id=None
    - source=None, event_type=None, payload=None, received_at=2025-05-18 12:37:08.028330+00:00, id=931849cb-3a69-4861-83ba-258fe1de5e98, action=UPDATE, table_name=contact, record_id=14e1bef9-2833-40d5-b4fe-7576f7cffd6c, timestamp=2025-05-18 12:37:08.028330+00:00, booking_id=None

üìÅ Tabell: bookings
  ‚Ä¢ start_time (timestamp with time zone)
  ‚Ä¢ end_time (timestamp with time zone)
  ‚Ä¢ id (uuid)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ metadata (jsonb)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ contact_id (uuid)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ booking_email (text)
  üîë [p] bookings_pkey: PRIMARY KEY (id)
  üîë [f] fk_bookings_contact: FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE SET NULL
  üß™ Topp 5 rader:
    - start_time=2025-05-20 08:00:00+00:00, end_time=2025-05-20 08:20:00+00:00, meeting_type=facetime, metadata={}, created_at=2025-05-18 10:48:56.390000+00:00, contact_id=None, id=378a6541-8e61-465d-a37d-6242ba770dc7, updated_at=2025-05-18 10:48:56.390000+00:00, booking_email=None
    - start_time=2025-05-20 12:00:00+00:00, end_time=2025-05-20 12:20:00+00:00, meeting_type=facetime, metadata={}, created_at=2025-05-18 11:12:10.769000+00:00, contact_id=None, id=f861a2c5-f1ca-4f00-91af-276bac7f326d, updated_at=2025-05-18 11:12:10.769000+00:00, booking_email=None
    - start_time=2025-05-20 12:00:00+00:00, end_time=2025-05-20 12:20:00+00:00, meeting_type=facetime, metadata={}, created_at=2025-05-18 11:13:04.323000+00:00, contact_id=None, id=feccbea8-6a8f-44d8-9f9d-cf468b55bc0c, updated_at=2025-05-18 11:13:04.323000+00:00, booking_email=None
    - start_time=2025-05-20 12:00:00+00:00, end_time=2025-05-20 12:20:00+00:00, meeting_type=facetime, metadata={}, created_at=2025-05-18 11:13:07.009000+00:00, contact_id=None, id=40f2b6ab-51ba-4c50-844c-6d9ff3db52d2, updated_at=2025-05-18 11:13:07.009000+00:00, booking_email=None
    - start_time=2025-05-21 08:00:00+00:00, end_time=2025-05-21 08:20:00+00:00, meeting_type=facetime, metadata={}, created_at=2025-05-18 11:29:28.739000+00:00, contact_id=None, id=4c0d2868-f99d-4156-b92e-4e7a97fd1153, updated_at=2025-05-18 11:29:28.739000+00:00, booking_email=None

üìÅ Tabell: pending_changes
  ‚Ä¢ booking_id (uuid)
  ‚Ä¢ processed (boolean)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ payload (jsonb)
  ‚Ä¢ id (uuid)
  ‚Ä¢ record_id (uuid)
  ‚Ä¢ table_name (text)
  ‚Ä¢ operation (text)
  ‚Ä¢ change_type (text)
  ‚Ä¢ direction (text)
  üîë [p] pending_changes_pkey: PRIMARY KEY (id)
  üîë [f] fk_pending_changes_booking_id: FOREIGN KEY (booking_id) REFERENCES bookings(id) ON DELETE CASCADE
  üß™ Topp 5 rader:
    - id=7d417b09-6288-490b-a73c-3f3b2792817e, table_name=contact, record_id=c4e2d9dd-545e-4e05-99fe-16d377a87698, change_type=INSERT, direction=out, processed=False, created_at=2025-05-16 09:40:53.307336+00:00, operation=INSERT, payload={'id': 'c4e2d9dd-545e-4e05-99fe-16d377a87698', 'email': None, 'metadata': {'city': '', 'phone': '0709561480', 'address': '', 'company': 'AnyNode', 'country': '', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'postal_code': ''}, 'created_at': '2025-05-16T09:40:53.307336+00:00', 'updated_at': '2025-05-16T09:40:53.307336+00:00', 'booking_email': 'daniel@anynode.se'}, booking_id=None
    - id=6463cae5-e1e8-4899-903b-feccaf981229, table_name=bookings, record_id=378a6541-8e61-465d-a37d-6242ba770dc7, change_type=INSERT, direction=out, processed=False, created_at=2025-05-18 10:48:56.394310+00:00, operation=INSERT, payload={'id': '378a6541-8e61-465d-a37d-6242ba770dc7', 'end_time': '2025-05-20T08:20:00+00:00', 'metadata': {}, 'contact_id': None, 'created_at': '2025-05-18T10:48:56.39+00:00', 'start_time': '2025-05-20T08:00:00+00:00', 'updated_at': '2025-05-18T10:48:56.39+00:00', 'meeting_type': 'facetime', 'booking_email': None}, booking_id=378a6541-8e61-465d-a37d-6242ba770dc7
    - id=62176d8e-90ff-48d9-bfe6-9375995dede3, table_name=bookings, record_id=378a6541-8e61-465d-a37d-6242ba770dc7, change_type=INSERT, direction=cloud_to_local, processed=False, created_at=2025-05-18 10:48:56.440000+00:00, operation=None, payload=None, booking_id=378a6541-8e61-465d-a37d-6242ba770dc7
    - id=c6553a94-29ae-4721-b381-898f78f0d67c, table_name=bookings, record_id=f861a2c5-f1ca-4f00-91af-276bac7f326d, change_type=INSERT, direction=out, processed=False, created_at=2025-05-18 11:12:10.772513+00:00, operation=INSERT, payload={'id': 'f861a2c5-f1ca-4f00-91af-276bac7f326d', 'end_time': '2025-05-20T12:20:00+00:00', 'metadata': {}, 'contact_id': None, 'created_at': '2025-05-18T11:12:10.769+00:00', 'start_time': '2025-05-20T12:00:00+00:00', 'updated_at': '2025-05-18T11:12:10.769+00:00', 'meeting_type': 'facetime', 'booking_email': None}, booking_id=f861a2c5-f1ca-4f00-91af-276bac7f326d
    - id=4d1006a6-2ff8-4c60-a573-e2091d5d3917, table_name=bookings, record_id=f861a2c5-f1ca-4f00-91af-276bac7f326d, change_type=INSERT, direction=cloud_to_local, processed=False, created_at=2025-05-18 11:12:10.803000+00:00, operation=None, payload=None, booking_id=f861a2c5-f1ca-4f00-91af-276bac7f326d

üìÅ Tabell: contact
  ‚Ä¢ metadata (jsonb)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ id (uuid)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ booking_email (text)
  ‚Ä¢ email (text)
  üîë [p] contact_pkey: PRIMARY KEY (id)
  üß™ Topp 5 rader:
    - metadata={'city': '', 'phone': '0709561480', 'address': '', 'company': 'AnyNode', 'country': '', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'postal_code': ''}, created_at=2025-05-16 09:40:53.307336+00:00, id=c4e2d9dd-545e-4e05-99fe-16d377a87698, booking_email=daniel@anynode.se, updated_at=2025-05-16 09:40:53.307336+00:00, email=None
    - metadata={'city': 'Stockholm', 'address': 'Maria Skolgata 79A', 'postal_code': '118 53'}, created_at=2025-05-18 12:32:42.290134+00:00, id=14e1bef9-2833-40d5-b4fe-7576f7cffd6c, booking_email=None, updated_at=2025-05-18 12:32:42.290134+00:00, email=daniel@anynode.se

üìÅ Tabell: booking_settings
  ‚Ä¢ value (jsonb)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ key (text)
  ‚Ä¢ value_type (text)
  üß™ Topp 5 rader:
    - key=max_days_in_advance, value=30, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=buffer_between_meetings, value=15, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=max_weekly_booking_minutes, value=360, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=default_office_address, value=Maria Skolgata 79A, 118 53 Stockholm, value_type=string, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=fallback_travel_time_minutes, value=90, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00

üìÅ Tabell: translation
  ‚Ä¢ key (character varying)
  ‚Ä¢ sv (text)
  ‚Ä¢ en (text)
  üß™ Topp 5 rader:
    - key=error_min_duration_fysiskt_kund, sv=M√∂testiden f√∂r 'Fysiskt hos kund' m√•ste vara minst {{minutes}} minuter. Du visste det redan., en=The meeting time for 'On-site at customer' must be at least {{minutes}} minutes. You knew that.
    - key=error_min_duration_fysiskt_mig, sv=M√∂testiden f√∂r 'Fysiskt hos mig' m√•ste vara minst {{minutes}} minuter. Annars hinner vi bara s√§ga hej., en=The meeting time for 'At my office' must be at least {{minutes}} minutes. Otherwise, we‚Äôll only have time to say hello.
    - key=email_body_booking_received, sv=Hej {{name}}! Vi har tagit emot din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}}. Ingen panik ‚Äì vi √•terkommer med bekr√§ftelse. / Daniel, en=Hello {{name}}, We‚Äôve received your booking for {{meeting_type}} between {{start_time}} and {{end_time}}. No need to panic ‚Äì we‚Äôll confirm shortly. / Daniel
    - key=email_body_booking_confirmed, sv=Hej {{name}}! Din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}} √§r nu spikad. Ser fram emot det! / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} is now locked in. Looking forward! / Daniel
    - key=email_body_booking_cancelled, sv=Hej {{name}}! Din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}} √§r avbokad. H√∂r av dig om du vill hitta en ny tid. / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} has been cancelled. Let me know if you'd like a new one. / Daniel

