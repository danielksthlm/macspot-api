ğŸ“‚ KODTRÃ„D
==========
â”œâ”€â”€ bookings
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ getavailableslots
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ meeting_types
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ refreshCalendarOrigins
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ refreshTravelTimes
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ calendar
â”‚   â”‚   â”œâ”€â”€ appleCalendar.js
â”‚   â”‚   â”œâ”€â”€ getMsToken.js
â”‚   â”‚   â”œâ”€â”€ msGraph.js
â”‚   â”‚   â”œâ”€â”€ resolveOrigin.js
â”‚   â”œâ”€â”€ config
â”‚   â”‚   â”œâ”€â”€ settingsLoader.js
â”‚   â”‚   â”œâ”€â”€ verifySettings.js
â”‚   â”œâ”€â”€ db
â”‚   â”‚   â”œâ”€â”€ pgPool.js
â”‚   â”œâ”€â”€ maps
â”‚   â”‚   â”œâ”€â”€ appleMaps.js
â”‚   â”‚   â”œâ”€â”€ resolveTravelTime.js
â”‚   â”‚   â”œâ”€â”€ returnTravelVerifier.js
â”‚   â”œâ”€â”€ slots
â”‚   â”‚   â”œâ”€â”€ slotEngine.js
â”‚   â”œâ”€â”€ utils
â”‚   â”‚   â”œâ”€â”€ debugLogger.js
â”œâ”€â”€ sync.py
â”œâ”€â”€ sync_all.py
â”œâ”€â”€ sync_from_cloud.py
â”œâ”€â”€ sync_static_tables.py
â”œâ”€â”€ sync_to_cloud.py
â”œâ”€â”€ validate_contact
â”‚   â”œâ”€â”€ index.js
==========

====================
ğŸ“„ Fil: meeting_types/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 19:37:45
ğŸ“ Antal rader: 47
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 1 rader (2.1%)
ğŸ“¥ Imports: 2 â€“ ["const pool = require('../shared/db/pgPool');", "const { getSettings } = require('../shared/config/settingsLoader');"]
ğŸ” LÃ¤ngsta funktion: 7 rader
ğŸ§  KomplexitetspoÃ¤ng: 3
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const pool = require('../shared/db/pgPool');
const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, req) {
  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.log.error(`Missing environment variable: ${key}`);
      context.res = {
        status: 500,
        body: { error: `Missing environment variable: ${key}` }
      };
      return;
    }
  }

  try {
    const settings = await getSettings(context);

    const rawTypes = settings['meeting_types'];
    const meetingTypes = Array.isArray(rawTypes) ? rawTypes.map(t => t.toLowerCase()) : [];
    const lengths = {
      zoom: settings['default_meeting_length_digital'],
      facetime: settings['default_meeting_length_digital'],
      teams: settings['default_meeting_length_digital'],
      atclient: settings['default_meeting_length_atclient'],
      atoffice: settings['default_meeting_length_atoffice']
    };

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        types: meetingTypes,
        lengths
      })
    };
  } catch (error) {
    context.log.error('Database query failed:', error);
    context.res = {
      status: 500,
      body: { error: error.message }
    };
  } finally {
    // pool.end() tas bort â€“ vi Ã¥teranvÃ¤nder en delad pool mellan anrop
  }
};
END: index.js

====================
ğŸ“„ Fil: validate_contact/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 19:36:32
ğŸ“ Antal rader: 121
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 1 rader (0.8%)
ğŸ“¥ Imports: 3 â€“ ["const { getSettings } = require('../shared/config/settingsLoader');", "const pool = require('../shared/db/pgPool');", "const { v4: uuidv4 } = require('uuid');"]
ğŸ” LÃ¤ngsta funktion: 1 rader
ğŸ§  KomplexitetspoÃ¤ng: 14
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const { getSettings } = require('../shared/config/settingsLoader');
const pool = require('../shared/db/pgPool');
const { v4: uuidv4 } = require('uuid');

module.exports = async function (context, req) {
  try {
    const email = req.body?.email || req.query?.email;
    const meeting_type = req.body?.meeting_type || req.query?.meeting_type;
    context.log.info('ğŸ“¥ validate_contact triggered with:', { email, meeting_type });

    if (!email || !meeting_type) {
      context.res = { status: 400, body: { error: "email and meeting_type are required" } };
      return;
    }

    const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
    for (const key of requiredEnv) {
      if (!process.env[key]) throw new Error(`Missing environment variable: ${key}`);
    }

    const contactRes = await pool.query('SELECT * FROM contact WHERE booking_email = $1', [email]);
    const contact = contactRes.rows[0];
    let metadata = contact?.metadata || {};

    if (typeof metadata === 'string') {
      try {
        metadata = JSON.parse(metadata);
      } catch {
        metadata = {};
      }
    }

    if (typeof metadata !== 'object' || metadata === null) metadata = {};

    const settings = await getSettings(context);
    const digitalTypes = Array.isArray(settings.meeting_digital) ? settings.meeting_digital : [];
    const isDigital = digitalTypes.map(t => t.toLowerCase()).includes(meeting_type.toLowerCase()) || meeting_type === 'atoffice';

    const alwaysRequired = ['first_name', 'last_name', 'phone', 'company'];
    const addressRequired = ['address', 'postal_code', 'city', 'country'];
    const requiredFields = [...alwaysRequired, ...(isDigital ? [] : addressRequired)];
    const missingFields = requiredFields.filter(
      field => !metadata[field] || typeof metadata[field] !== 'string' || metadata[field].trim() === ''
    );

    if ((req.body?.write_if_valid || req.query?.write_if_valid) && missingFields.length > 0) {
      let metadataFromClient = req.body?.metadata;
      if (typeof metadataFromClient === 'string') {
        try {
          metadataFromClient = JSON.parse(metadataFromClient);
        } catch {
          metadataFromClient = {};
        }
      }
      if (typeof metadataFromClient === 'object' && metadataFromClient !== null) {
        if (!contact) {
          const newId = uuidv4();
          await pool.query(
            `INSERT INTO contact (id, booking_email, metadata, created_at) VALUES ($1, $2, $3, NOW())`,
            [newId, email, metadataFromClient]
          );
          context.log.info('âœ… Ny kontakt skapad via validate_contact');

          context.res = {
            status: 200,
            body: {
              status: "created",
              contact_id: newId
            }
          };
          return;
        } else {
          await pool.query(
            `UPDATE contact SET metadata = $1, updated_at = NOW() WHERE booking_email = $2`,
            [metadataFromClient, email]
          );
          context.log.info('âœï¸ Befintlig kontakt uppdaterad via validate_contact');
        }
      }
    }

    if (!contact) {
      context.res = {
        status: 200,
        body: {
          status: "new_customer",
          missing_fields: missingFields
        }
      };
    } else if (missingFields.length > 0) {
      context.res = {
        status: 200,
        body: {
          status: "incomplete",
          contact_id: contact.id,
          missing_fields: missingFields
        }
      };
    } else {
      context.res = {
        status: 200,
        body: {
          status: "existing_customer",
          contact_id: contact.id
        }
      };
    }

  } catch (error) {
    context.log.error('âŒ Error during validate_contact:', {
      message: error.message,
      stack: error.stack
    });
    context.res = {
      status: 500,
      body: { error: error.message, stack: error.stack }
    };
  } finally {
    // Poolen Ã¤r delad och Ã¥teranvÃ¤nds â€“ vi stÃ¤nger den inte hÃ¤r
  }
};
END: index.js

====================
ğŸ“„ Fil: getavailableslots/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 16:32:19
ğŸ“ Antal rader: 191
ğŸ§© Antal funktioner: 2
ğŸ’¬ KommentarstÃ¤ckning: 2 rader (1.0%)
ğŸ“¥ Imports: 9 â€“ ['const db = require("../shared/db/pgPool");', "const createMsGraphClient = require('../shared/calendar/msGraph');", "const createAppleClient = require('../shared/calendar/appleCalendar');", "const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');", "const { createDebugLogger } = require('../shared/utils/debugLogger');", "require('../shared/config/verifySettings');", "const { getSettings } = require('../shared/config/settingsLoader');", "const verifyBookingSettings = require('../shared/config/verifySettings');", "generateSlotChunks = require('../shared/slots/slotEngine').generateSlotChunks;"]
ğŸ” LÃ¤ngsta funktion: 19 rader
ğŸ§  KomplexitetspoÃ¤ng: 13
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const db = require("../shared/db/pgPool");
const createMsGraphClient = require('../shared/calendar/msGraph');
const createAppleClient = require('../shared/calendar/appleCalendar');
const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');
const { createDebugLogger } = require('../shared/utils/debugLogger');
console.log("âœ… getavailableslots/index.js laddad");
require('../shared/config/verifySettings');

module.exports = async function (context, req) {
  const appleClient = createAppleClient(context);
  const graphClient = createMsGraphClient();
  context.log("ğŸ§ª Azure Function entrypoint nÃ¥dd");
  context.log("ğŸ§ª graphClient.getEvent:", typeof graphClient.getEvent === "function");
  context.log("ğŸ§ª appleClient.getEvent:", typeof appleClient.getEvent === "function");

  try {
    const client = await db.connect();

    if (!req || !req.body) {
      context.log("âŒ Ingen request body mottagen");
      context.res = { status: 400, body: { error: "Missing request body" } };
      return;
    }

    const { email, meeting_type, meeting_length, contact_id } = req.body;
    context.log("âœ… Request body innehÃ¥ller:", { email, meeting_type });
    context.log("âœ… Steg 1: Anropar DB med contact_id:", contact_id);

    // Declare allBookings, days, and contact at the top-level scope of the outer try block
    let allBookings = [];
    let days = [];
    let contact;
    let bookingsByDay = {};

    try {
      const contactRes = await client.query("SELECT * FROM contact WHERE id = $1", [contact_id]);
      contact = contactRes.rows[0];
      if (contact) {
        context.log("âœ… Kontakt hittad:", contact.id);
      } else {
        context.log("âš ï¸ Ingen kontakt hittad fÃ¶r contact_id:", contact_id);
      }
    } catch (err) {
      context.log("ğŸ”¥ DB-fel:", err.message);
      context.res = { status: 500, body: { error: "DB error", detail: err.message } };
      client.release();
      return;
    }

    context.log("âœ… Steg 2: Laddar booking_settings...");

    const { getSettings } = require('../shared/config/settingsLoader');
    const verifyBookingSettings = require('../shared/config/verifySettings');

    let settings;
    try {
      settings = await getSettings(context);
      context.log("âœ… Steg 2a: InstÃ¤llningar laddade â€“ nycklar:", Object.keys(settings).join(', '));
      verifyBookingSettings(settings, context);
      context.log("âœ… Steg 2b: InstÃ¤llningar verifierade");

      context.log("âœ… Steg 3: Genererar days[] och laddar bokningar");

      const maxDays = settings.max_days_in_advance || 14;
      const today = new Date();
      days = Array.from({ length: maxDays }, (_, i) => {
        const date = new Date(today);
        date.setDate(today.getDate() + i);
        return date;
      });

      const startDateStr = days[0].toISOString().split('T')[0];
      const endDateStr = days[days.length - 1].toISOString().split('T')[0];

      const allBookingsRes = await client.query(
        'SELECT start_time, end_time, meeting_type FROM bookings WHERE start_time::date >= $1 AND start_time::date <= $2',
        [startDateStr, endDateStr]
      );
      context.log("ğŸ”¢ Antal bokningar hÃ¤mtade:", allBookingsRes.rows.length);

      allBookings = allBookingsRes.rows.map(b => ({
        start: new Date(b.start_time).getTime(),
        end: new Date(b.end_time).getTime(),
        date: new Date(b.start_time).toISOString().split('T')[0],
        meeting_type: b.meeting_type
      }));

      for (const booking of allBookings) {
        if (!bookingsByDay[booking.date]) bookingsByDay[booking.date] = [];
        bookingsByDay[booking.date].push({ start: booking.start, end: booking.end });
      }

      context.log("âœ… Steg 3: Dagar genererade och bokningar summerade");

    } catch (err) {
      context.log("ğŸ”¥ Fel vid laddning/verifiering av settings:", err.message);
      context.res = { status: 500, body: { error: "Settings error", detail: err.message } };
      client.release();
      return;
    }

    let generateSlotChunks;
    try {
      generateSlotChunks = require('../shared/slots/slotEngine').generateSlotChunks;
      context.log("âœ… generateSlotChunks import ok");
    } catch (importErr) {
      context.log("âŒ Misslyckades importera generateSlotChunks:", importErr.message);
      context.res = { status: 500, body: { error: "Import error", detail: importErr.message } };
      client.release();
      return;
    }

    const weeklyMinutesByType = {};
    const weekKey = (date) => {
      const start = new Date(date);
      start.setUTCHours(0, 0, 0, 0);
      start.setUTCDate(start.getUTCDate() - start.getUTCDay());
      return start.toISOString().split('T')[0];
    };
    for (const b of allBookings) {
      const type = b.meeting_type || 'unknown';
      const week = weekKey(b.start);
      weeklyMinutesByType[type] = weeklyMinutesByType[type] || {};
      weeklyMinutesByType[type][week] = (weeklyMinutesByType[type][week] || 0) + (b.end - b.start) / 60000;
    }

    const debugHelper = createDebugLogger(context);

    const appleMapsToken = await getAppleMapsAccessToken(context);
    if (appleMapsToken) {
      context.log("âœ… Apple Maps token hÃ¤mtad â€“ lÃ¤ngd:", appleMapsToken.length);
    } else {
      context.log("âš ï¸ Apple Maps token saknas â€“ fallback kommer att anvÃ¤ndas");
    }

    // Riktigt anrop till generateSlotChunks
    const slotGroupPicked = {};
    const startSlotGen = Date.now();
    const chosenSlotsResult = await generateSlotChunks({
      days,
      context,
      contact,
      contact_id,
      meeting_type,
      meeting_length,
      bookingsByDay,
      weeklyMinutesByType,
      settings,
      graphClient,
      appleClient,
      travelCache: new Map(),
      accessToken: appleMapsToken,
      timezone: settings.timezone || 'Europe/Stockholm',
      debugHelper,
      client: client,
      slotGroupPicked,
      logSlotContext: true
    });
    const durationMs = Date.now() - startSlotGen;
    context.log(`â±ï¸ Slotgenerering klar pÃ¥ ${durationMs} ms`);
    context.log("âœ… generateSlotChunks kÃ¶rdes utan fel");
    context.log("ğŸ“¦ Slotresultat:", JSON.stringify(chosenSlotsResult?.chosenSlots || [], null, 2));

    if (chosenSlotsResult?.chosenSlots?.length) {
      for (const slot of chosenSlotsResult.chosenSlots) {
        const slotHour = new Date(slot.slot_iso).getUTCHours();
        context.log(`ğŸ“† Slot: ${slot.slot_iso}, Part: ${slot.slot_part}, Origin: ${slot.origin}, Source: ${slot.source}`);
      }
    }

    context.log("ğŸ“¤ Response skickas med antal slots:", (chosenSlotsResult?.chosenSlots || []).length);
    context.res = {
      status: 200,
      body: {
        message: "âœ… getavailableslots Ã¤r kontaktbar och fungerar i full version",
        received: { email, meeting_type, meeting_length },
        slots: (chosenSlotsResult?.chosenSlots || []).map(slot => ({
          ...slot,
          score: slot.score ?? null
        }))
      }
    };
    client.release();
    context.log("âœ… Databasanslutning slÃ¤ppt");
  } catch (err) {
    context.log("ğŸ”¥ FEL i minimal testfunktion:", err.message);
    context.res = { status: 500, body: { error: err.message } };
  }
  context.log("ğŸ¯ Slut pÃ¥ exekvering av getavailableslots");
  context.log("âœ… getavailableslots/index.js â€“ HELA FUNKTIONEN KÃ–RDES UTAN FEL");
};
END: index.js

====================
ğŸ“„ Fil: refreshCalendarOrigins/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 19:34:31
ğŸ“ Antal rader: 36
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 4 â€“ ["const { DateTime } = require('luxon');", "const pool = require('../shared/db/pgPool');", "const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');", "const { getSettings } = require('../shared/config/settingsLoader');"]
ğŸ” LÃ¤ngsta funktion: 4 rader
ğŸ§  KomplexitetspoÃ¤ng: 1
ğŸ§ª TODO/FIXME: 0
====================
START: index.js


const { DateTime } = require('luxon');
const pool = require('../shared/db/pgPool');
const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');

const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const today = new Date();
  const settings = await getSettings(context);
  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const date = new Date();
    date.setDate(today.getDate() + i);
    return date;
  });

  context.log(`ğŸ” KÃ¶r refreshCalendarOrigins fÃ¶r ${days.length} dagar`);

  for (const date of days) {
    const slotTime = DateTime.fromJSDate(date).set({ hour: 10, minute: 0 }).toJSDate();
    const travelStart = new Date(slotTime.getTime() - (settings.fallback_travel_time_minutes || 20) * 60000);

    await resolveOriginAddress({
      eventId: slotTime.toISOString(),
      calendarId: 'system-refresh',
      pool,
      context,
      fallbackOrigin: settings.default_home_address,
      settings
    });
  }

  context.log('âœ… refreshCalendarOrigins fÃ¤rdig');
};
END: index.js

====================
ğŸ“„ Fil: refreshTravelTimes/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 19:35:16
ğŸ“ Antal rader: 112
ğŸ§© Antal funktioner: 4
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 6 â€“ ["const { DateTime } = require('luxon');", "const fetch = require('node-fetch');", "const pool = require('../shared/db/pgPool');", "const { getSettings } = require('../shared/config/settingsLoader');", "const jwt = require('jsonwebtoken');", "const fs = require('fs');"]
ğŸ” LÃ¤ngsta funktion: 10 rader
ğŸ§  KomplexitetspoÃ¤ng: 8
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const { DateTime } = require('luxon');
const fetch = require('node-fetch');
const pool = require('../shared/db/pgPool');
const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const settings = await getSettings(context);
  const fallbackTravelTime = settings.fallback_travel_time_minutes || 20;
  const today = new Date();
  const timezone = settings.timezone || 'Europe/Stockholm';

  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const d = new Date(today);
    d.setDate(today.getDate() + i);
    return d;
  });

  const destinations = [settings.default_office_address];
  const origins = [settings.default_home_address];

  for (const day of days) {
    for (const hour of [10, 14]) {
      const slotTime = DateTime.fromJSDate(day).set({ hour, minute: 0 }).toJSDate();

      for (const from of origins) {
        for (const to of destinations) {
          const hourKey = slotTime.getUTCHours();
          const key = `${from}|${to}|${hourKey}`;

          const res = await pool.query(
            `SELECT 1 FROM travel_time_cache
             WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
            [from, to, hourKey]
          );

          if (res.rows.length > 0) {
            context.log(`âš¡ Redan i cache: ${key}`);
            continue;
          }

          context.log(`â³ BerÃ¤knar restid: ${key}`);
          try {
            const token = await getAppleMapsAccessToken(context);
            if (!token) throw new Error('Apple Maps-token saknas');

            const url = new URL('https://maps-api.apple.com/v1/directions');
            url.searchParams.append('origin', from);
            url.searchParams.append('destination', to);
            url.searchParams.append('transportType', 'automobile');
            url.searchParams.append('departureTime', slotTime.toISOString());

            const response = await fetch(url.toString(), {
              headers: { Authorization: `Bearer ${token}` }
            });
            const data = await response.json();

            const minutes = Math.round((data.routes?.[0]?.durationSeconds || fallbackTravelTime * 60) / 60);
            await pool.query(
              `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
               VALUES ($1, $2, $3, $4)
               ON CONFLICT (from_address, to_address, hour)
               DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes`,
              [from, to, hourKey, minutes]
            );
            context.log(`âœ… Sparad restid: ${minutes} min (${key})`);
          } catch (err) {
            context.log(`âš ï¸ Misslyckades hÃ¤mta/spara restid fÃ¶r ${key}: ${err.message}`);
          }
        }
      }
    }
  }

  context.log('âœ… refreshTravelTimes fÃ¤rdig');
};

async function getAppleMapsAccessToken(context) {
  try {
    const jwt = require('jsonwebtoken');
    const fs = require('fs');

    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n') ||
                       fs.readFileSync(process.env.APPLE_MAPS_KEY_PATH, 'utf8');

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context.log('âš ï¸ Misslyckades hÃ¤mta Apple Maps token:', err.message);
    return null;
  }
}
END: index.js

====================
ğŸ“„ Fil: shared/calendar/appleCalendar.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 15:04:59
ğŸ“ Antal rader: 166
ğŸ§© Antal funktioner: 4
ğŸ’¬ KommentarstÃ¤ckning: 1 rader (0.6%)
ğŸ“¥ Imports: 2 â€“ ['const fetch = require("node-fetch");', 'const xml2js = require("xml2js");']
ğŸ” LÃ¤ngsta funktion: 8 rader
ğŸ§  KomplexitetspoÃ¤ng: 13
ğŸ§ª TODO/FIXME: 0
====================
START: appleCalendar.js
console.log("ğŸ§ª appleCalendar.js laddades");
const fetch = require("node-fetch");
const xml2js = require("xml2js");

function createAppleClient(context) {
  async function getEvent(calendarId, eventId) {
    context.log("ğŸ appleClient.getEvent() anropad med:", { calendarId, eventId });
    const caldavUrl = process.env.CALDAV_CALENDAR_URL;
    const username = process.env.CALDAV_USER;
    const password = process.env.CALDAV_PASSWORD;

    context.log("ğŸ§ª getEvent() kallas med:", { calendarId, eventId });
    context.log("ğŸ appleClient.getEvent() startar â€“ kontrollera om .ics-innehÃ¥ll innehÃ¥ller LOCATION och DTEND...");
    context.log("ğŸŒ caldavUrl:", caldavUrl);
    context.log("ğŸ‘¤ username:", username);

    if (!caldavUrl || !username || !password) {
      context.log("âš ï¸ Missing CalDAV credentials");
      return null;
    }

    try {
      const eventUrl = `${caldavUrl.replace(/\/$/, '')}/${eventId}.ics`;
      const icsRes = await fetch(eventUrl, {
        method: "GET",
        headers: {
          "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64")
        }
      });

      if (!icsRes.ok) {
        context.log(`âš ï¸ Misslyckades hÃ¤mta ICS-fil: ${eventUrl}`);
        return null;
      }

      const icsText = await icsRes.text();
      context.log("ğŸ§¾ FÃ¶rhandsvisning av ICS-innehÃ¥ll (fÃ¶rsta 500 tecken):", icsText.slice(0, 500));
      context.log("ğŸ§¾ Full ICS-innehÃ¥ll:");
      context.log(icsText);
      context.log("ğŸ” locationMatch:", icsText.match(/LOCATION:(.*)/));
      context.log("ğŸ” endTimeMatch:", icsText.match(/DTEND(?:;[^:]*)?:(.*)/));
      const locationMatch = icsText.match(/LOCATION:(.*)/);
      const endTimeMatch = icsText.match(/DTEND(?:;[^:]*)?:(.*)/);

      const location = locationMatch ? locationMatch[1].trim() : null;
      const endTime = endTimeMatch ? endTimeMatch[1].trim() : null;

      if (location && endTime) {
        context.log("âœ… Hittade event med location och endTime:", { location, endTime });
        return { location, endTime };
      }

      context.log("âš ï¸ Inget event med bÃ¥de location och endTime hittades.");
      return null;

    } catch (err) {
      context.log("âš ï¸ Error i getEvent():", err.message);
      return null;
    }
  }

  // HÃ¤mtar alla events i ett datumintervall via CalDAV REPORT
  async function fetchEventsByDateRange(startDate, endDate) {
    const caldavUrl = process.env.CALDAV_CALENDAR_URL;
    const username = process.env.CALDAV_USER;
    const password = process.env.CALDAV_PASSWORD;

    context.log("ğŸ§ª fetchEventsByDateRange() kallas med:", { startDate, endDate });
    context.log(`ğŸ fetchEventsByDateRange(): anvÃ¤nder CALDAV_USER = ${process.env.CALDAV_USER}`);

    if (!caldavUrl || !username || !password) {
      context.log("âš ï¸ Missing CalDAV credentials");
      return [];
    }

    const xmlBody = `
<C:calendar-query xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:caldav">
  <D:prop>
    <D:getetag/>
    <C:calendar-data content-type="text/calendar"/>
  </D:prop>
  <C:filter>
    <C:comp-filter name="VCALENDAR">
      <C:comp-filter name="VEVENT">
        <C:time-range start="${startDate}" end="${endDate}"/>
      </C:comp-filter>
    </C:comp-filter>
  </C:filter>
</C:calendar-query>`.trim();

    try {
      const res = await fetch(caldavUrl, {
        method: "REPORT",
        headers: {
          "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64"),
          "Depth": "1",
          "Content-Type": "application/xml"
        },
        body: xmlBody
      });

      const xml = await res.text();
      const parsed = await xml2js.parseStringPromise(xml, { explicitArray: false, tagNameProcessors: [xml2js.processors.stripPrefix] });
      const responses = parsed?.['multistatus']?.['response'] || parsed?.['D:multistatus']?.['D:response'];
      if (!responses) return [];

      const items = Array.isArray(responses) ? responses : [responses];
      const results = [];

      for (const item of items) {
        let calendarData = item?.['propstat']?.['prop']?.['calendar-data'] || item?.['D:propstat']?.['D:prop']?.['C:calendar-data'];

        if (calendarData && typeof calendarData === 'object' && '_' in calendarData) {
          calendarData = calendarData._;
        }

        const href = item['href'] || item['D:href'];
        if (!calendarData || !calendarData.includes('VEVENT')) {
          const fullUrl = `${caldavUrl.replace(/\/$/, '')}${href}`;
          const fallbackRes = await fetch(fullUrl, {
            method: "GET",
            headers: {
              "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64")
            }
          });
          calendarData = await fallbackRes.text();
          if (!calendarData.includes("VEVENT")) continue;
        }

        const vevents = Array.from(calendarData.matchAll(/BEGIN:VEVENT[\s\S]*?END:VEVENT/g));
        for (const vevent of vevents) {
          const v = vevent[0];
          const summary = v.match(/SUMMARY:(.*)/)?.[1]?.trim() ?? "â€“";
          const dtstart = v.match(/DTSTART(?:;[^:]*)?:(\d{8}(T\d{6})?)/)?.[1]?.trim() ?? "â€“";
          const dtend = v.match(/DTEND(?:;[^:]*)?:(\d{8}(T\d{6})?)/)?.[1]?.trim() ?? "â€“";
          const location = v.match(/LOCATION:(.*)/)?.[1]?.trim() ?? "â€“";
          const uid = v.match(/UID:(.*)/)?.[1]?.trim() ?? "â€“";
          results.push({ summary, dtstart, dtend, location, uid });
        }
      }

      results.sort((a, b) => {
        const aTime = new Date(a.dtstart.replace(/^(\d{8})$/, '$1T000000')).getTime();
        const bTime = new Date(b.dtstart.replace(/^(\d{8})$/, '$1T000000')).getTime();
        return aTime - bTime;
      });

      context.log(`âœ… Hittade ${results.length} events totalt`);
      return results;
    } catch (err) {
      context.log("âŒ Fel i fetchEventsByDateRange():", err.message);
      return [];
    }
  }

  return { getEvent, fetchEventsByDateRange };
}

const client = createAppleClient({ log: console.log });

if (process.env.NODE_ENV === 'test') {
  console.log("ğŸ§ª TEST appleClient:", typeof client.getEvent === 'function' ? 'âœ… getEvent finns' : 'âŒ getEvent saknas');
  console.log("ğŸ§ª TEST appleClient:", typeof client.fetchEventsByDateRange === 'function' ? 'âœ… fetchEventsByDateRange finns' : 'âŒ fetchEventsByDateRange saknas');
}

module.exports = () => client;
END: appleCalendar.js

====================
ğŸ“„ Fil: shared/calendar/getMsToken.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 10:10:03
ğŸ“ Antal rader: 57
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ["require('dotenv').config(); // Ladda miljÃ¶variabler frÃ¥n .env", "const fetch = require('node-fetch');"]
ğŸ” LÃ¤ngsta funktion: 4 rader
ğŸ§  KomplexitetspoÃ¤ng: 5
ğŸ§ª TODO/FIXME: 0
====================
START: getMsToken.js
require('dotenv').config(); // Ladda miljÃ¶variabler frÃ¥n .env
const fetch = require('node-fetch');

console.log("ğŸ§ª getMsToken.js laddades");

module.exports = async function getMsToken(context = { log: console.log }) {
  context.log("ğŸ§ª getMsToken() anropades â€“ initierar tokenhÃ¤mtning");
  context.log("ğŸ” MS365_CLIENT_ID:", process.env.MS365_CLIENT_ID?.slice(0, 8));
  context.log("ğŸ” MS365_CLIENT_SECRET:", process.env.MS365_CLIENT_SECRET ? "[satt]" : "[saknas]");
  context.log("ğŸ” MS365_TENANT_ID:", process.env.MS365_TENANT_ID?.slice(0, 8));
  if (!process.env.MS365_CLIENT_ID || !process.env.MS365_CLIENT_SECRET || !process.env.MS365_TENANT_ID) {
    context.log("âŒ En eller flera miljÃ¶variabler fÃ¶r MS Graph saknas.");
    return null;
  }
  try {
    const tokenEndpoint = `https://login.microsoftonline.com/${process.env.MS365_TENANT_ID}/oauth2/v2.0/token`;
    const params = new URLSearchParams();
    params.append('client_id', process.env.MS365_CLIENT_ID);
    params.append('client_secret', process.env.MS365_CLIENT_SECRET);
    params.append('scope', 'https://graph.microsoft.com/.default');
    params.append('grant_type', 'client_credentials');

    context.log("ğŸ“¡ FÃ¶rsÃ¶ker hÃ¤mta token frÃ¥n:", tokenEndpoint);

    const res = await fetch(tokenEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params
    });

    context.log(`ğŸ“¬ Response status: ${res.status}`);

    if (!res.ok) {
      const errorText = await res.text();
      context.log(`âš ï¸ TokenhÃ¤mtning misslyckades: ${res.status} ${res.statusText}\nSvar: ${errorText}`);
      context.log("ğŸªµ FullstÃ¤ndigt svar frÃ¥n Graph:", errorText);
      return null;
    }

    const data = await res.json();
    return data.access_token;
  } catch (err) {
    context.log(`âš ï¸ TokenhÃ¤mtning fel: ${err.message}`);
    return null;
  }
};

if (require.main === module) {
  (async () => {
    const token = await module.exports();
    if (token) {
      console.log("âœ… Token hÃ¤mtad:", token.slice(0, 20) + "...");
    } else {
      console.log("âŒ Kunde inte hÃ¤mta token.");
    }
  })();
}
END: getMsToken.js

====================
ğŸ“„ Fil: shared/calendar/msGraph.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 15:05:00
ğŸ“ Antal rader: 102
ğŸ§© Antal funktioner: 4
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 5 â€“ ['const { Client } = require("@microsoft/microsoft-graph-client");', 'require("isomorphic-fetch");', 'const fetch = require("node-fetch");', 'const { loadSettings } = require("../config/settingsLoader");', 'const getMsToken = require("./getMsToken");']
ğŸ” LÃ¤ngsta funktion: 6 rader
ğŸ§  KomplexitetspoÃ¤ng: 10
ğŸ§ª TODO/FIXME: 0
====================
START: msGraph.js
console.log("ğŸ§ª msGraph.js laddades");
const { Client } = require("@microsoft/microsoft-graph-client");
require("isomorphic-fetch");
const fetch = require("node-fetch");
const { loadSettings } = require("../config/settingsLoader");
const getMsToken = require("./getMsToken");

function createMsGraphClient() {

  async function getEvent(calendarId, eventId) {
    console.log(`ğŸ§ª getEvent() kallas med calendarId=${calendarId}, eventId=${eventId}`);
    console.log(`ğŸ“¡ getEvent(): anvÃ¤nder calendarId = ${calendarId}, fÃ¶rvÃ¤ntad = ${process.env.MS365_USER_EMAIL}`);
    try {
      if (!calendarId || !eventId) {
        console.warn("âŒ getEvent missing calendarId or eventId (Graph)");
        return null;
      }

      const authToken = await getMsToken({ log: console.log });
      if (!authToken) {
        throw new Error("ğŸ›‘ TokenhÃ¤mtning misslyckades â€“ accessToken saknas. Funktion avbryts.");
      }
      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      try {
        const result = await client
          .api(`/users/${calendarId}/events/${encodeURIComponent(eventId)}`)
          .select("subject,location,start,end")
          .get();

        const location = result.location?.displayName || null;
        const endTime = result.end?.dateTime || null;

        return { location, endTime };
      } catch (err) {
        if (err.statusCode === 404) {
          console.warn(`âš ï¸ getEvent: event ${eventId} saknas`);
          return { location: null, endTime: null, deleted: true };
        }
        console.error("âš ï¸ getEvent error (Graph):", err.message);
        return null;
      }
    } catch (err) {
      console.error("âš ï¸ getEvent error (Graph):", err.message);
      return null;
    }
  }

  async function listUpcomingEvents(daysAhead) {
    try {
      if (!daysAhead) {
        const settings = await loadSettings(null);
        daysAhead = settings.max_days_in_advance || 90;
      }
      const calendarId = process.env.MS365_USER_EMAIL;
      if (!calendarId) throw new Error("âŒ MS365_USER_EMAIL saknas");

      const authToken = await getMsToken({ log: console.log });
      if (!authToken) {
        throw new Error("ğŸ›‘ TokenhÃ¤mtning misslyckades â€“ accessToken saknas. Funktion avbryts.");
      }
      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const now = new Date();
      const startDate = now.toISOString();
      const endDate = new Date(now.getTime() + daysAhead * 86400000).toISOString();

      const response = await client
        .api(`/users/${calendarId}/calendarView?startDateTime=${startDate}&endDateTime=${endDate}`)
        .top(100)
        .select("subject,start,end,id")
        .orderby("start/dateTime ASC")
        .get();

      const upcoming = response.value.filter(ev => new Date(ev.start.dateTime) > new Date());
      return upcoming.map(ev => ({
        subject: ev.subject,
        start: ev.start.dateTime,
        end: ev.end?.dateTime || null,
        id: ev.id
      }));
    } catch (err) {
      console.error("âš ï¸ listUpcomingEvents error (Graph):", err.message);
      return [];
    }
  }

  return { getEvent, listUpcomingEvents };
}

if (process.env.NODE_ENV === 'test') {
  const testClient = createMsGraphClient();
  console.log("ğŸ§ª TEST graphClient:", typeof testClient.getEvent === 'function' ? 'âœ… getEvent finns' : 'âŒ getEvent saknas');
}

const client = createMsGraphClient();
console.log("ğŸ§ª msGraph-klient skapad â€“ getEvent Ã¤r funktion:", typeof client.getEvent === 'function');
module.exports = () => client;
END: msGraph.js

====================
ğŸ“„ Fil: shared/calendar/resolveOrigin.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 14:30:40
ğŸ“ Antal rader: 235
ğŸ§© Antal funktioner: 2
ğŸ’¬ KommentarstÃ¤ckning: 21 rader (8.9%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 2 rader
ğŸ§  KomplexitetspoÃ¤ng: 37
ğŸ§ª TODO/FIXME: 0
====================
START: resolveOrigin.js
/**
 * resolveOriginAddress
 * --------------------
 * HÃ¤mtar origin-adress fÃ¶r ett kalender-event frÃ¥n:
 * 1. Memory-cache
 * 2. PostgreSQL-cache (om SKIP_DB inte Ã¤r satt)
 * 3. MS Graph
 * 4. Apple Calendar
 * Fallback anvÃ¤nds vid miss.
 *
 * MiljÃ¶variabler:
 * - SKIP_DB=true  â†’ hoppar Ã¶ver all databaslogik (lÃ¤s/skriv)
 */
console.log("ğŸ§ª resolveOrigin.js laddades");
const memoryCache = {};

function cleanAddress(address) {
  return address.replace(/\n/g, ', ').replace(/\\,/g, ',').replace(/\+/g, ' ').trim();
}

async function resolveOriginAddress({ eventId, calendarId, pool, context, graphClient, appleClient, fallbackOrigin, settings, eventCache }) {
  const cacheKey = `${calendarId}:${eventId}`;
  const debugLog = (msg) => {
    if (process.env.DEBUG === 'true' && context?.log) context.log(msg);
  };
  debugLog(`ğŸ” resolveOriginAddress â†’ calendarId: ${calendarId}, eventId: ${eventId}`);
  const eventDateOnly = eventId.split('T')[0];

  const useCacheEvents = eventCache?.has(eventDateOnly);
  const cachedEvents = useCacheEvents ? eventCache.get(eventDateOnly) : null;

  if (memoryCache[cacheKey]) {
    // Provide originEndTime as well
    let originEndTime = null;
    if (memoryCache[cacheKey].originSource === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = memoryCache[cacheKey].originEndTime || null;
    }
    debugLog(`âœ… Hittade origin frÃ¥n cache: ${memoryCache[cacheKey].origin}`);
    return {
      origin: cleanAddress(memoryCache[cacheKey].origin),
      originSource: memoryCache[cacheKey].originSource,
      originEndTime
    };
  }


  // Try database cache first
  let dbRes;
  if (!process.env.SKIP_DB) {
    try {
      dbRes = await pool.query(
        'SELECT address, source, end_time FROM calendar_origin_cache WHERE event_date = $1',
        [eventDateOnly]
      );
      debugLog(`ğŸ“‚ DB-kontroll: Hittade ${dbRes?.rows?.length || 0} rader fÃ¶r ${eventDateOnly}`);
    } catch (err) {
      context.log(`âš ï¸ DB error in resolveOriginAddress: ${err.message}`);
    }
  }
  if (dbRes && dbRes.rows && dbRes.rows.length > 0) {
    // Special case: if source is fallback, return immediately
    if (dbRes.rows[0].source === 'fallback') {
      const originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
      memoryCache[cacheKey] = {
        origin: dbRes.rows[0].address,
        originSource: dbRes.rows[0].source,
        originEndTime
      };
      debugLog(`ğŸ›‘ DB-trÃ¤ff var fallback â€“ hoppar Ã¶vriga fÃ¶rsÃ¶k`);
      return {
        origin: cleanAddress(dbRes.rows[0].address),
        originSource: dbRes.rows[0].source,
        originEndTime
      };
    }
    let originEndTime = null;
    if (dbRes.rows[0].source === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = dbRes.rows[0].end_time || null;
    }
    memoryCache[cacheKey] = {
      origin: dbRes.rows[0].address,
      originSource: dbRes.rows[0].source,
      originEndTime: originEndTime
    };
    debugLog(`âœ… Hittade origin frÃ¥n DB: ${dbRes.rows[0].address}`);
    return {
      origin: cleanAddress(dbRes.rows[0].address),
      originSource: dbRes.rows[0].source,
      originEndTime
    };
  }
  debugLog(`ğŸ•³ï¸ Inget cachetrÃ¤ff i DB fÃ¶r ${eventDateOnly}`);

  let latestOrigin;
  let originEndTime = null;
  let originSource = 'unknown';

  if (!latestOrigin && memoryCache[`${calendarId}:${eventDateOnly}`]) {
    const { origin, originSource, originEndTime } = memoryCache[`${calendarId}:${eventDateOnly}`];
    debugLog(`ğŸ” Ã…teranvÃ¤nder memoryCache fÃ¶r dag: ${eventDateOnly}`);
    return { origin: cleanAddress(origin), originSource, originEndTime };
  }
  if (graphClient && typeof graphClient.getEvent === 'function') {
    if (!latestOrigin && !memoryCache[`${calendarId}:${eventDateOnly}`]) {
      try {
        const graphCalendarId = settings.ms_sender_email;
        const appleCalendarId = process.env.CALDAV_USER;
        const msEvent = await graphClient.getEvent(graphCalendarId, eventId);
        if (msEvent && msEvent.location) {
          latestOrigin = msEvent.location;
          originSource = 'Microsoft 365';
          debugLog(`âœ… Hittade origin frÃ¥n MS Graph: ${latestOrigin}`);
        }
      } catch (err) {
        context.log(`âš ï¸ MS Graph error in resolveOriginAddress: ${err.message}`);
      }
    }
  } else if (graphClient) {
    context.log(`âš ï¸ graphClient saknar getEvent-metod eller Ã¤r null`);
  }

  // Try fetching from Apple calendar if not found
  if (!latestOrigin && appleClient && typeof appleClient.fetchEventsByDateRange === 'function') {
    try {
      const startRange = `${eventDateOnly}T00:00:00Z`;
      const endRange = `${eventDateOnly}T23:59:59Z`;
      const appleCalendarId = process.env.CALDAV_USER;
      const events = cachedEvents || await appleClient.fetchEventsByDateRange(startRange, endRange, appleCalendarId);
      if (!cachedEvents && eventCache) eventCache.set(eventDateOnly, events);
      let mostRecent = null;
      const eventStartTime = new Date(eventId);
      for (const e of events) {
        const dtend = new Date(e.dtend || '');
        if (dtend && dtend <= eventStartTime) {
          if (!mostRecent || dtend > new Date(mostRecent.dtend || 0)) {
            mostRecent = e;
          }
        }
      }

      // Om ingen med location hittades, ta det senaste med dtend
      if (!mostRecent) {
        for (const e of events) {
          const dtend = new Date(e.dtend || '');
          if (dtend && dtend <= eventStartTime) {
            if (!mostRecent || dtend > new Date(mostRecent.dtend || 0)) {
              mostRecent = e;
            }
          }
        }
      }

      if (mostRecent) {
        latestOrigin = mostRecent.location || fallbackOrigin || '';
        originSource = mostRecent.location ? 'Apple Calendar' : 'fallback';
        debugLog(`âœ… Hittade origin frÃ¥n Apple (eller fallback): ${latestOrigin}`);

        if (mostRecent.dtend && typeof mostRecent.dtend === 'string') {
          const dt = mostRecent.dtend.replace(/[^0-9T]/g, '');
          const parsed = new Date(dt.length === 8 ? `${dt}T00:00:00Z` : dt);
          originEndTime = !isNaN(parsed.getTime())
            ? parsed
            : new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
        } else {
          originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
        }
      }
    } catch (err) {
      context.log(`âš ï¸ Apple error in resolveOriginAddress: ${err.message}`);
    }
  } else if (!latestOrigin && appleClient) {
    context.log(`âš ï¸ appleClient saknar fetchEventsByDateRange-metod eller Ã¤r null`);
  }

  // Fallback if not found
  if (!latestOrigin) {
    if (originEndTime) {
      debugLog(`âš ï¸ LOCATION saknas men endTime finns â€“ anvÃ¤nder fallback som origin`);
      latestOrigin = fallbackOrigin || '';
      originSource = 'fallback';
    } else {
      debugLog(`ğŸš¨ Ingen trÃ¤ff i varken cache, DB, Graph eller Apple â€“ anvÃ¤nder fallback`);
      latestOrigin = fallbackOrigin || '';
      originSource = 'fallback';
    }
    debugLog(`âš ï¸ Fallback anvÃ¤nds som origin: ${latestOrigin}`);
  }

  memoryCache[`${calendarId}:${eventDateOnly}`] = {
    origin: latestOrigin,
    originSource,
    originEndTime
  };

  // Write to DB cache unless fallback
  originEndTime = originEndTime || null;
  if (originSource === 'fallback') {
    originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
  }
  // Ensure originEndTime fallback value before DB insert (unless fallback)
  if (!originEndTime && originSource !== 'fallback') {
    originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
  }
  if (!process.env.SKIP_DB && originSource !== 'fallback') {
    try {
      await pool.query(
        `INSERT INTO calendar_origin_cache (event_date, source, address, end_time)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT DO NOTHING`,
        [eventDateOnly, originSource, latestOrigin, originEndTime]
      );
    } catch (err) {
      context.log(`âš ï¸ DB write error in resolveOriginAddress: ${err.message}`);
    }
  }

  memoryCache[cacheKey] = {
    origin: latestOrigin,
    originSource,
    originEndTime
  };
  debugLog(`ğŸ§  resolveOriginAddress resultat: ${latestOrigin} (kÃ¤lla: ${originSource})`);
  context.log(`ğŸ“¤ resolveOriginAddress return: ${latestOrigin} (kÃ¤lla: ${originSource}, endTime: ${originEndTime?.toISOString?.() || 'null'})`);
  return { origin: cleanAddress(latestOrigin), originSource, originEndTime };
}

module.exports = { resolveOriginAddress };

if (process.env.NODE_ENV === 'test') {
  module.exports._test = { memoryCache };
}
END: resolveOrigin.js

====================
ğŸ“„ Fil: shared/config/settingsLoader.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 16:24:02
ğŸ“ Antal rader: 71
ğŸ§© Antal funktioner: 2
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 1 â€“ ['const pool = require("../db/pgPool");']
ğŸ” LÃ¤ngsta funktion: 8 rader
ğŸ§  KomplexitetspoÃ¤ng: 11
ğŸ§ª TODO/FIXME: 0
====================
START: settingsLoader.js
const pool = require("../db/pgPool");
console.log("ğŸ§ª settingsLoader.js laddades");
async function getSettings(context) {
  try {
    const settings = {};
    const isDebug = process.env.DEBUG === 'true';
    const debugLog = (msg) => {
      if (isDebug && context && context.log) {
        context.log(msg);
      }
    };
    debugLog('âš™ï¸ BÃ¶rjar lÃ¤sa booking_settings...');
    const settingsRes = await pool.query('SELECT key, value, value_type FROM booking_settings');
    debugLog(`ğŸ“¦ ${settingsRes.rows.length} instÃ¤llningar hÃ¤mtade`);
    for (const row of settingsRes.rows) {
      debugLog(`ğŸ”‘ ${row.key} = ${row.value} (${row.value_type})`);
      if (
        row.value_type === 'json' ||
        row.value_type === 'array' ||
        (typeof row.value_type === 'string' && /\[\]$/.test(row.value_type))
      ) {
        try {
          settings[row.key] = JSON.parse(typeof row.value === 'string' ? row.value : JSON.stringify(row.value));
        } catch (_) {}
      } else if (row.value_type === 'int') {
        settings[row.key] = parseInt(row.value);
      } else if (row.value_type === 'bool') {
        settings[row.key] = row.value === 'true' || row.value === true;
      } else if (row.value_type === 'string') {
        settings[row.key] = String(row.value).replace(/^"(.*)"$/, '$1');
      } else {
        settings[row.key] = row.value;
      }
    }
    debugLog('âœ… Alla instÃ¤llningar tolkade och klara');
    settings.required_fields = {
      zoom: ['first_name', 'last_name', 'phone', 'company'],
      atclient: ['first_name', 'last_name', 'phone', 'address', 'postal_code', 'city', 'country']
    };
    settings.field_labels = {
      first_name: 'FÃ¶rnamn',
      last_name: 'Efternamn',
      phone: 'Telefonnummer',
      company: 'FÃ¶retag',
      address: 'Gatuadress',
      postal_code: 'Postnummer',
      city: 'Stad',
      country: 'Land'
    };
    return settings;
  } catch (err) {
    if (context && context.log) {
      context.log(`âš ï¸ Fel vid laddning av booking_settings: ${err.message}`);
    } else {
      console.warn(`âš ï¸ Fel vid laddning av booking_settings: ${err.message}`);
    }
    throw err;
  }
}

function getCloudSecretsOnly() {
  const secrets = {};
  for (const [key, value] of Object.entries(process.env)) {
    if (key.startsWith('MS365_')) {
      secrets[key] = value;
    }
  }
  return secrets;
}

module.exports = { getSettings, getCloudSecretsOnly };
END: settingsLoader.js

====================
ğŸ“„ Fil: shared/config/verifySettings.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-20 12:15:11
ğŸ“ Antal rader: 52
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 24 rader
ğŸ§  KomplexitetspoÃ¤ng: 8
ğŸ§ª TODO/FIXME: 0
====================
START: verifySettings.js
console.log("ğŸ§ª verifySettings.js laddades");
function verifyBookingSettings(settings, context) {
  const expected = {
    default_office_address: 'string',
    default_home_address: 'string',
    fallback_travel_time_minutes: 'number',
    buffer_between_meetings: 'number',
    default_meeting_length_atoffice: 'array',
    default_meeting_length_atclient: 'array',
    default_meeting_length_digital: 'array',
    meeting_types: 'array',
    block_weekends: 'boolean',
    open_time: 'string',
    close_time: 'string',
    lunch_start: 'string',
    lunch_end: 'string',
    travel_time_window_start: 'string',
    travel_time_window_end: 'string',
    require_approval: 'boolean',
    max_days_in_advance: 'number',
    max_weekly_booking_minutes: 'number',
    cache_ttl_minutes: 'number',
    allowed_atclient_meeting_days: 'array',
    timezone: 'string'
  };

  const issues = [];
  for (const [key, type] of Object.entries(expected)) {
    const val = settings[key];
    if (val === undefined || val === null || (key === 'timezone' && String(val).trim() === '')) {
      issues.push(`âŒ Saknar instÃ¤llning: ${key}`);
    } else if (key === 'allowed_atclient_meeting_days') {
      if (!Array.isArray(val) || !val.every(v => typeof v === 'string')) {
        issues.push(`âš ï¸ Typfel fÃ¶r ${key}: ska vara array av strÃ¤ngar`);
      }
    } else if (key === 'require_approval') {
      if (typeof val !== 'boolean') {
        issues.push(`âš ï¸ Typfel fÃ¶r ${key}: ska vara boolean`);
      }
    } else if (type === 'array' ? !Array.isArray(val) : typeof val !== type) {
      issues.push(`âš ï¸ Typfel fÃ¶r ${key}: har ${typeof val}, fÃ¶rvÃ¤ntade ${type}`);
    }
  }

  if (issues.length > 0) {
    const message = 'ğŸ›‘ Problem med booking_settings:\n' + issues.join('\n');
    context.log.warn(message);
    throw new Error(message);
  }
}

module.exports = verifyBookingSettings;
END: verifySettings.js

====================
ğŸ“„ Fil: shared/db/pgPool.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-21 16:03:39
ğŸ“ Antal rader: 20
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ["const { Pool } = require('pg');", "require('dotenv').config();"]
ğŸ” LÃ¤ngsta funktion: 7 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: pgPool.js
const { Pool } = require('pg');
require('dotenv').config();

const useSSL = process.env.PG_USE_SSL === 'true';
const sslConfig = useSSL ? { rejectUnauthorized: false } : false;

console.log("ğŸ§ª shared/db/pgPool.js laddades");
console.log("ğŸ” PG_USE_SSL:", process.env.PG_USE_SSL);
console.log("ğŸ” ssl config:", sslConfig);

const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: sslConfig
});

module.exports = pool;
END: pgPool.js

====================
ğŸ“„ Fil: shared/maps/appleMaps.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-20 12:15:38
ğŸ“ Antal rader: 121
ğŸ§© Antal funktioner: 5
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ["const jwt = require('jsonwebtoken');", "const fetch = require('node-fetch');"]
ğŸ” LÃ¤ngsta funktion: 10 rader
ğŸ§  KomplexitetspoÃ¤ng: 9
ğŸ§ª TODO/FIXME: 0
====================
START: appleMaps.js
console.log("ğŸ§ª appleMaps.js laddades");
const jwt = require('jsonwebtoken');
const fetch = require('node-fetch');

async function getAppleMapsAccessToken(context) {
  try {
    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n');

    if (!privateKey) {
      throw new Error('Apple Maps private key saknas â€“ kontrollera APPLE_MAPS_PRIVATE_KEY');
    }

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context?.log?.('âš ï¸ Misslyckades hÃ¤mta Apple Maps token:', err.message);
    if (err.code === 'EAI_AGAIN') {
      context?.log?.('ğŸŒ DNS-fel (EAI_AGAIN) â€“ kunde inte nÃ¥ servern:', err.message);
    }
    return null;
  }
}


async function getTravelTimeInMinutes(origin, destination, departureTime, accessToken, context) {
  try {
    const url = `https://maps-api.apple.com/v1/directions?origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&departureTime=${encodeURIComponent(departureTime)}&transportType=automobile&includeTravelTimeBreakdown=true`;

    const res = await fetch(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });

    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`âŒ Apple Maps-directions misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const travelTimeSeconds = data.routes?.[0]?.expectedTravelTime;
    return travelTimeSeconds ? Math.ceil(travelTimeSeconds / 60) : null;
  } catch (err) {
    context?.log?.(`âŒ Fel vid directions-anrop: ${err.message}`);
    return null;
  }
}

async function getTravelTime(origin, destination, departureTime, context) {
  try {
    const token = await getAppleMapsAccessToken(context);
    if (!token) {
      context?.log?.('âš ï¸ Kunde inte hÃ¤mta Apple Maps-token');
      return null;
    }
    return await getTravelTimeInMinutes(origin, destination, departureTime, token, context);
  } catch (err) {
    context?.log?.(`âŒ Fel i getTravelTime: ${err.message}`);
    return null;
  }
}

async function safeGetTravelTime(origin, destination, departureTime, accessToken, context) {
  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', origin);
    url.searchParams.append('destination', destination);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', departureTime);

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 8000); // max 8s

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` },
      signal: controller.signal
    });

    clearTimeout(timeout);
    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`âŒ Apple Maps misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const seconds = data.routes?.[0]?.durationSeconds || data.routes?.[0]?.expectedTravelTime;
    return seconds ? Math.round(seconds / 60) : null;
  } catch (err) {
    context?.log?.(`âš ï¸ safeGetTravelTime error: ${err.message}`);
    return null;
  }
}

module.exports = {
  getAppleMapsAccessToken,
  getTravelTimeInMinutes,
  getTravelTime,
  safeGetTravelTime
};
END: appleMaps.js

====================
ğŸ“„ Fil: shared/maps/returnTravelVerifier.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-20 12:16:01
ğŸ“ Antal rader: 66
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 1 rader (1.5%)
ğŸ“¥ Imports: 1 â€“ ["const { URL } = require('url');"]
ğŸ” LÃ¤ngsta funktion: 2 rader
ğŸ§  KomplexitetspoÃ¤ng: 4
ğŸ§ª TODO/FIXME: 0
====================
START: returnTravelVerifier.js
console.log("ğŸ§ª returnTravelVerifier.js laddades");
const { URL } = require('url');

async function verifyReturnTravelFeasibility({
  previousBooking,
  contact,
  slotTime,
  settings,
  accessToken,
  db,
  context,
  travelCache
}) {
  const from = previousBooking.address || settings.default_office_address;
  const to = `${contact.metadata.address} ${contact.metadata.postal_code} ${contact.metadata.city}`;
  const prevEnd = new Date(previousBooking.end);

  if (from === to) {
    context.log(`ğŸ’¾ Returrestid Ã¤r 0 min (${from} â†’ ${to}) â€“ ingen cache behÃ¶vs`);
    return { isFeasible: true };
  }

  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', from);
    url.searchParams.append('destination', to);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', prevEnd.toISOString());

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` }
    });

    const data = await res.json();
    const returnMinutes = Math.round((data.routes?.[0]?.durationSeconds || 0) / 60);
    const arrivalTime = new Date(prevEnd.getTime() + returnMinutes * 60000);

    // Cache return time in memory and DB
    const hour = prevEnd.getUTCHours();
    const returnCacheKey = `${from}|${to}|${hour}`;
    travelCache.set(returnCacheKey, returnMinutes);
    if (from && to) {
      await db.query(`
        INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (from_address, to_address, hour)
        DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes
      `, [from, to, hour, returnMinutes]);
      context.log(`ğŸ’¾ Returrestid sparad: ${returnMinutes} min (${from} â†’ ${to} @ ${hour}:00)`);
    } else {
      context.log(`âš ï¸ Hoppar caching av retur â€“ saknar from_address (${from}) eller to_address (${to})`);
    }

    if (arrivalTime > slotTime) {
      context.log(`â›” Slot ${slotTime.toISOString()} avvisad â€“ retur frÃ¥n tidigare mÃ¶te hinner inte fram i tid (ankomst ${arrivalTime.toISOString()})`);
      return { isFeasible: false, reason: 'retur hinner inte fram', arrivalTime };
    }

    return { isFeasible: true };
  } catch (err) {
    context.log(`âš ï¸ Kunde inte verifiera returrestid frÃ¥n tidigare mÃ¶te: ${err.message}`);
    return { isFeasible: true }; // fail open
  }
}

module.exports = { verifyReturnTravelFeasibility };
END: returnTravelVerifier.js

====================
ğŸ“„ Fil: shared/maps/resolveTravelTime.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-20 20:22:50
ğŸ“ Antal rader: 72
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 2 rader
ğŸ§  KomplexitetspoÃ¤ng: 8
ğŸ§ª TODO/FIXME: 0
====================
START: resolveTravelTime.js
console.log("ğŸ§ª travelTimeResolver.js laddades");
async function resolveTravelTime({ origin, destination, hour, db, accessToken, context }) {
  let travelTimeMin = 20;
  const cacheKey = `${origin}|${destination}|${hour}`;
  let cacheHit = false;
  let isFallback = false;

  if (!origin || !destination) {
    context.log(`âš ï¸ Kan inte berÃ¤kna restid â€“ origin eller destination saknas`);
    return { travelTimeMin, cacheHit: false, isFallback };
  }

  if (!db || typeof db.query !== 'function') {
    context.log(`âŒ db saknas eller saknar query-metod i resolveTravelTime`);
    return { travelTimeMin, cacheHit: false, isFallback: true };
  }

  try {
    const cacheRes = await db.query(
      `SELECT travel_minutes, is_fallback FROM travel_time_cache WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
      [origin, destination, hour]
    );
    if (cacheRes.rows.length > 0) {
      travelTimeMin = cacheRes.rows[0].travel_minutes;
      isFallback = cacheRes.rows[0].is_fallback === true;
      cacheHit = true;
      context.log(`âš¡ Cache hit (db): ${origin} â†’ ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
    }
  } catch (err) {
    context.log(`âš ï¸ Kunde inte lÃ¤sa frÃ¥n travel_time_cache: ${err.message}`);
  }

  if (!accessToken) {
    context.log(`âš ï¸ accessToken saknas â€“ anvÃ¤nder fallback`);
    return { travelTimeMin, cacheHit: false, isFallback: true };
  }

  if (!cacheHit && accessToken) {
    try {
      const url = new URL('https://maps-api.apple.com/v1/directions');
      url.searchParams.append('origin', origin);
      url.searchParams.append('destination', destination);
      url.searchParams.append('transportType', 'automobile');
      url.searchParams.append('departureTime', new Date().toISOString());

      const res = await fetch(url.toString(), {
        headers: { Authorization: `Bearer ${accessToken}` }
      });
      const data = await res.json();
      const travelSeconds = data.routes?.[0]?.durationSeconds;
      if (travelSeconds) {
        travelTimeMin = Math.round(travelSeconds / 60);
        await db.query(
          `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes, is_fallback)
           VALUES ($1, $2, $3, $4, false)
           ON CONFLICT (from_address, to_address, hour)
           DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes, is_fallback = false`,
          [origin, destination, hour, travelTimeMin]
        );
        context.log(`ğŸ’¾ Sparade Apple Maps-restid i cache: ${origin} â†’ ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
      } else {
        context.log(`âš ï¸ Apple Maps-data saknas â€“ anvÃ¤nder fallback`);
      }
    } catch (err) {
      context.log(`âš ï¸ Fel vid Apple Maps-anrop: ${err.message}`);
    }
  }

  return { travelTimeMin, cacheHit, isFallback };
}

module.exports = { resolveTravelTime };
END: resolveTravelTime.js

====================
ğŸ“„ Fil: bookings/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 19:38:29
ğŸ“ Antal rader: 139
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 5 rader (3.6%)
ğŸ“¥ Imports: 4 â€“ ["const { getSettings } = require('../shared/config/settingsLoader');", "const pool = require('../shared/db/pgPool');", "const { v4: uuidv4 } = require('uuid');", "const { createDebugLogger } = require('../shared/utils/debugLogger');"]
ğŸ” LÃ¤ngsta funktion: 1 rader
ğŸ§  KomplexitetspoÃ¤ng: 11
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const { getSettings } = require('../shared/config/settingsLoader');
const pool = require('../shared/db/pgPool');
const { v4: uuidv4 } = require('uuid');
const { createDebugLogger } = require('../shared/utils/debugLogger');

module.exports = async function (context, req) {
  const requiredFields = ['meeting_type', 'meeting_length', 'slot_iso'];
  const missing = requiredFields.filter(k => !req.body?.[k]);

  if (missing.length > 0) {
    context.res = { status: 400, body: { error: `Missing fields: ${missing.join(', ')}` } };
    return;
  }

  const { email, meeting_type, meeting_length, slot_iso, metadata = {} } = req.body;

  const parsedLength = parseInt(meeting_length, 10);
  if (isNaN(parsedLength) || parsedLength <= 0) {
    context.res = { status: 400, body: { error: "Invalid meeting_length" } };
    return;
  }

  const parsedStart = new Date(slot_iso);
  if (isNaN(parsedStart.getTime())) {
    context.res = { status: 400, body: { error: "Invalid slot_iso datetime" } };
    return;
  }

  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.res = { status: 500, body: { error: `Missing environment variable: ${key}` } };
      return;
    }
  }

  const db = await pool.connect();
  const debugHelper = createDebugLogger(context);
  const debugLog = debugHelper.debugLog;
  debugLog("ğŸ§  debugLogger aktiv â€“ DEBUG=" + process.env.DEBUG);
  try {
    // LÃ¤s in booking_settings
    const settings = await getSettings(context);

    const id = uuidv4();
    // Kontrollera om en bokning redan finns
    const existing = await db.query(
      'SELECT id FROM bookings WHERE contact_id = $1 AND start_time = $2',
      [metadata.contact_id || null, parsedStart.toISOString()]
    );
    if (existing.rowCount > 0) {
      context.res = {
        status: 409,
        body: { error: 'Booking already exists for this time.' }
      };
      return;
    }
    const startTime = parsedStart;
    const endTime = new Date(startTime.getTime() + parsedLength * 60000);
    const created_at = new Date();
    const updated_at = created_at;

    // Bygg meeting_link dynamiskt
    let meeting_link = null;
    if (meeting_type.toLowerCase() === 'teams') {
      meeting_link = 'https://teams.microsoft.com/l/meetup-join/...'; // placeholder
    } else if (meeting_type.toLowerCase() === 'zoom') {
      meeting_link = 'https://zoom.us/j/1234567890'; // placeholder
    } else if (meeting_type.toLowerCase() === 'facetime' && metadata.phone) {
      meeting_link = `facetime:${metadata.phone}`;
    }

    const fields = {
      id,
      start_time: startTime.toISOString(),
      end_time: endTime.toISOString(),
      meeting_type,
      metadata: JSON.stringify(metadata),
      created_at,
      updated_at,
      contact_id: metadata.contact_id || null,
      booking_email: email || null
    };

    const query = `
      INSERT INTO bookings (
        id, start_time, end_time, meeting_type,
        metadata, created_at, updated_at,
        contact_id, booking_email
      ) VALUES (
        $1, $2, $3, $4,
        $5, $6, $7,
        $8, $9
      )
    `;

    const values = Object.values(fields);
    await db.query(query, values);
    // Logga pending change fÃ¶r denna bokning
    await db.query(
      `INSERT INTO pending_changes (id, table_name, record_id, change_type, direction, processed, created_at, booking_id)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        uuidv4(),
        'bookings',
        id,
        'INSERT',
        'cloud_to_local',
        false,
        new Date(),
        id
      ]
    );
    // Simulera att kalendern synkades fÃ¶r denna demo
    fields.synced_to_calendar = true;
    await db.query(
      'INSERT INTO event_log (event_type, booking_id) VALUES ($1, $2)',
      ['booking_created', id]
    );
    debugLog(`âœ… Bokning skapad: ${id}, typ: ${meeting_type}, lÃ¤ngd: ${meeting_length}`);

    context.res = {
      status: 200,
      body: {
        status: 'booked',
        booking_id: id,
        calendar_invite_sent: false
      }
    };
  } catch (err) {
    context.log.error("âŒ Booking error:", err.message);
    context.res = {
      status: 500,
      body: { error: err.message }
    };
  } finally {
    db.release();
  }
};
END: index.js

====================
ğŸ“„ Fil: shared/utils/debugLogger.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-20 12:16:50
ğŸ“ Antal rader: 23
ğŸ§© Antal funktioner: 2
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 8 rader
ğŸ§  KomplexitetspoÃ¤ng: 2
ğŸ§ª TODO/FIXME: 0
====================
START: debugLogger.js
console.log("ğŸ§ª debugLogger.js laddades");

function createDebugLogger(context) {
  const isDebug = process.env.DEBUG === 'true';
  const skipReasons = {};

  const debugLog = (msg) => {
    if (msg.startsWith('â›”') || msg.startsWith('ğŸ½ï¸') || msg.startsWith('ğŸ“›')) {
      const reason = msg.split(' â€“ ')[0];
      skipReasons[reason] = (skipReasons[reason] || 0) + 1;
    }
    if (isDebug && context?.log) {
      context.log(msg);
    }
  };

  return {
    debugLog,
    getSkipSummary: () => skipReasons
  };
}

module.exports = { createDebugLogger };
END: debugLogger.js

====================
ğŸ“„ Fil: shared/slots/slotEngine.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 14:54:02
ğŸ“ Antal rader: 225
ğŸ§© Antal funktioner: 4
ğŸ’¬ KommentarstÃ¤ckning: 4 rader (1.8%)
ğŸ“¥ Imports: 6 â€“ ["const pool = require('../db/pgPool');", 'const { DateTime } = require("luxon");', 'const { resolveOriginAddress } = require("../calendar/resolveOrigin");', 'const { resolveTravelTime } = require("../maps/resolveTravelTime");', 'const msGraph = require("../calendar/msGraph");', 'const appleCalendar = require("../calendar/appleCalendar");']
ğŸ” LÃ¤ngsta funktion: 13 rader
ğŸ§  KomplexitetspoÃ¤ng: 17
ğŸ§ª TODO/FIXME: 0
====================
START: slotEngine.js
console.log("ğŸ§ª slotEngine.js laddades");

const pool = require('../db/pgPool');

const { DateTime } = require("luxon");
const { resolveOriginAddress } = require("../calendar/resolveOrigin");
const { resolveTravelTime } = require("../maps/resolveTravelTime");
const msGraph = require("../calendar/msGraph");
const appleCalendar = require("../calendar/appleCalendar");

async function generateSlotCandidates({ day, settings, contact, pool, context, graphClient, appleClient, meeting_length, eventCache }) {
  const timezone = settings.timezone || "Europe/Stockholm";
  const hoursToTry = [8, 12]; // UTC â†’ 10:00 och 14:00 svensk tid
  const slots = [];

  for (const hour of hoursToTry) {
    const eventId = `${day}T${hour.toString().padStart(2, "0")}:00:00.000Z`;
    const dateObj = new Date(eventId);
    const weekday = dateObj.toLocaleDateString("en-US", { weekday: "long", timeZone: timezone }).toLowerCase();
    const slot_part = hour < 12 ? "fm" : "em";
    const isWeekend = ["saturday", "sunday"].includes(weekday);
    if (settings.block_weekends && isWeekend) {
      context.log(`â›” Helg blockerad (${weekday}) â€“ hoppar ${eventId}`);
      continue;
    }

    context.log(`ğŸ“§ resolveOriginAddress anvÃ¤nder settings.ms_sender_email (MS) och CALDAV_USER (Apple) â€“ calendarId sÃ¤tts till 'system' som placeholder`);
    const originInfo = await resolveOriginAddress({
      eventId,
      calendarId: 'system',
      pool,
      context,
      graphClient,
      appleClient,
      fallbackOrigin: settings.default_home_address,
      settings,
      eventCache
    });

    if (!originInfo?.origin) {
      context.log(`âš ï¸ Kunde inte faststÃ¤lla origin fÃ¶r ${eventId}`);
      continue;
    }

    const destination = settings.default_office_address;
    const { travelTimeMin } = await resolveTravelTime({
      origin: originInfo.origin,
      destination,
      hour,
      db: pool,
      accessToken: context.accessToken || null,
      context
    });

    if (!travelTimeMin || typeof travelTimeMin !== "number") {
      context.log.warn(`âš ï¸ Ogiltig restid, hoppar slot: ${eventId}`);
      continue;
    }

    const endTime = new Date(dateObj.getTime() + meeting_length * 60000);
    const dayStart = new Date(dateObj);
    const dayEnd = new Date(dateObj);
    dayStart.setHours(parseInt(settings.open_time.split(':')[0], 10), parseInt(settings.open_time.split(':')[1], 10));
    dayEnd.setHours(parseInt(settings.close_time.split(':')[0], 10), parseInt(settings.close_time.split(':')[1], 10));

    if (endTime > dayEnd) {
      context.log(`â›” Slot ${eventId} gÃ¥r utanfÃ¶r Ã¶ppettid (${settings.close_time}) â€“ hoppar`);
      continue;
    }

    // Build slot object
    const slot = {
      slot_iso: eventId,
      slot_local: DateTime.fromJSDate(dateObj).setZone(timezone).toISO(),
      travel_time_min: travelTimeMin,
      origin: originInfo.origin,
      originEndTime: originInfo.originEndTime,
      source: originInfo.originSource,
      require_approval: settings.require_approval,
      meeting_length,
      weekday,
      slot_part
    };

    // --- Score calculation logic ---
    // AnvÃ¤nd context.bookingsByDay som kÃ¤lla till befintliga bokningar per dag
    const bookingsByDay = (typeof context.bookingsByDay === "object" && context.bookingsByDay) ? context.bookingsByDay : {};
    const slotDateIso = dateObj.toISOString().split("T")[0];
    const slotStart = dateObj.getTime();
    const slotEnd = slotStart + meeting_length * 60000;

    const existing = bookingsByDay[slotDateIso] || [];
    let gapBefore = null;
    let gapAfter = null;

    for (const b of existing) {
      const bStart = b.start;
      const bEnd = b.end;

      if (bEnd <= slotStart) {
        gapBefore = slotStart - bEnd;
      } else if (bStart >= slotEnd && gapAfter === null) {
        gapAfter = bStart - slotEnd;
      }
    }

    // StandardpoÃ¤ng Ã¤r 10. Dra av poÃ¤ng fÃ¶r stor lucka fÃ¶re eller efter.
    let fragmentationPenalty = 0;
    if ((gapBefore && gapBefore > 45 * 60000) || (gapAfter && gapAfter > 45 * 60000)) {
      fragmentationPenalty = 1;
    }

    slot.score = 10 - fragmentationPenalty;

    slots.push(slot);
  }

  return slots;
}


async function generateSlotChunks({
  days,
  context,
  contact,
  contact_id,
  meeting_type,
  meeting_length,
  bookingsByDay,
  weeklyMinutesByType,
  settings,
  graphClient,
  appleClient,
  travelCache,
  accessToken,
  timezone,
  debugHelper
}) {
  const { debugLog, skipReasons } = debugHelper || {};
  const slotGroupPicked = {};
  const slotMap = {};
  const chosen = [];

  if (days.length === 0) {
    const fallbackDate = new Date().toISOString().split('T')[0];
    const { rows } = await pool.query(
      'SELECT slots FROM slot_cache WHERE slot_day = $1 LIMIT 1',
      [fallbackDate]
    );
    if (rows.length > 0) {
      context.log(`ğŸŸ¡ AnvÃ¤nder slot_cache som fallback (${fallbackDate})`);
      return {
        chosenSlots: rows[0].slots || [],
        slotMapResult: {},
        slotLogSummary: { 'fallback_used': 1 }
      };
    }
  }

  const eventCache = new Map();

  const slotCandidatePromises = days.map(day => {
    const dayStr = day.toISOString().split("T")[0];
    return generateSlotCandidates({
      day: dayStr,
      settings,
      contact,
      pool: context.client || pool,
      context,
      graphClient,
      appleClient,
      meeting_length,
      eventCache
    });
  });

  const slotCandidatesPerDay = await Promise.all(slotCandidatePromises);

  days.forEach((day, index) => {
    const dayStr = day.toISOString().split("T")[0];
    const slotCandidates = slotCandidatesPerDay[index];
    for (const slot of slotCandidates) {
      const key = `${dayStr}_${slot.slot_part}`;
      if (!slotMap[key]) slotMap[key] = [];
      slotMap[key].push(slot);
    }
  });

  for (const [key, candidates] of Object.entries(slotMap)) {
    if (candidates.length === 0) continue;

    const alreadyPicked = slotGroupPicked[key];
    if (alreadyPicked) {
      debugLog?.(`ğŸŸ¡ Slotgrupp '${key}' redan vald tidigare â€“ hoppar`);
      continue;
    }

    const preferredHours = [10, 14];
    const best = candidates.sort((a, b) => {
      if ((b.score || 0) !== (a.score || 0)) {
        return (b.score || 0) - (a.score || 0);
      }
      const aHour = new Date(a.slot_iso).getUTCHours();
      const bHour = new Date(b.slot_iso).getUTCHours();
      const aPriority = preferredHours.includes(aHour) ? 0 : 1;
      const bPriority = preferredHours.includes(bHour) ? 0 : 1;
      return aPriority - bPriority;
    })[0] || candidates[0];
    slotGroupPicked[key] = true;
    chosen.push(best);
  }

  const durationMs = Date.now() - context.startTime;
  context.log(`â±ï¸ Slotgenerering klar pÃ¥ ${durationMs} ms`);
  return {
    chosenSlots: chosen.sort((a, b) => new Date(a.slot_iso) - new Date(b.slot_iso)),
    slotMapResult: slotMap,
    slotLogSummary: skipReasons
  };
}

module.exports = {
  generateSlotCandidates,
  generateSlotChunks
};
END: slotEngine.js

====================
ğŸ“„ Fil: sync_from_cloud.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-05-15 18:23:27
ğŸ“ Antal rader: 141
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ['import psycopg2', 'import json']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 28
ğŸ§ª TODO/FIXME: 0
====================
START: sync_from_cloud.py
import psycopg2
import json
from config import LOCAL_DB_CONFIG, REMOTE_DB_CONFIG

def connect_db(config):
    return psycopg2.connect(**config)

def apply_change(cur, table, operation, payload):
    if operation == "INSERT":
        cols = ", ".join(payload.keys())
        placeholders = ", ".join(["%s"] * len(payload))
        sql = f"INSERT INTO {table} ({cols}) VALUES ({placeholders}) ON CONFLICT (id) DO NOTHING"
        cur.execute(sql, [json.dumps(v) if isinstance(v, dict) else v for v in payload.values()])
    elif operation == "UPDATE":
        if table == "contact" and "metadata" in payload:
            local_meta = payload["metadata"]
            if isinstance(local_meta, str):
                local_meta = json.loads(local_meta)
            cur.execute("SELECT metadata FROM contact WHERE id = %s", (payload["id"],))
            row = cur.fetchone()
            if row:
                remote_meta = row[0]
                if isinstance(remote_meta, str):
                    remote_meta = json.loads(remote_meta)
                if remote_meta == local_meta:
                    print(f"â™»ï¸ Ingen skillnad i metadata fÃ¶r {payload['id']}, hoppar UPDATE och markerar som klar.")
                    return
        sets = ", ".join([f"{col} = %s" for col in payload if col != "id"])
        values = [json.dumps(payload[col]) if isinstance(payload[col], dict) else payload[col] for col in payload if col != "id"]
        values.append(payload["id"])
        sql = f"UPDATE {table} SET {sets} WHERE id = %s"
        cur.execute(sql, values)
        cur.execute("SELECT metadata, updated_at FROM contact WHERE id = %s", [payload["id"]])
        updated_row = cur.fetchone()
        if updated_row:
            try:
                metadata = updated_row[0]
                if isinstance(metadata, str):
                    metadata = json.loads(metadata)
                address = metadata.get("address", "(ingen adress)")
            except Exception:
                address = "(kunde inte tolkas)"
            print(f"ğŸ§¾ Efter UPDATE: {payload['id']} â†’ {address} @ {updated_row[1]}")
        else:
            print(f"âš ï¸ UPDATE-verifiering misslyckades: Inget resultat fÃ¶r {payload['id']}")
    elif operation == "DELETE":
        sql = f"DELETE FROM {table} WHERE id = %s"
        cur.execute(sql, [payload["id"]])

def sync():
    remote_conn = connect_db(REMOTE_DB_CONFIG)
    remote_cur = remote_conn.cursor()

    local_conn = connect_db(LOCAL_DB_CONFIG)
    local_cur = local_conn.cursor()

    remote_cur.execute("""
        SELECT id, table_name, record_id, operation, payload
        FROM (
            SELECT *, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
            FROM pending_changes
            WHERE direction = 'out' AND processed = false
              AND table_name IN ('contact', 'bookings')
        ) sub
        WHERE rn = 1
        ORDER BY created_at ASC, id
    """)
    rows = remote_cur.fetchall()

    remote_cur.execute("""
        DELETE FROM pending_changes
        WHERE id NOT IN (
            SELECT id FROM (
                SELECT id, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
                FROM pending_changes
                WHERE direction = 'out' AND processed = false
            ) sub
            WHERE rn = 1
        ) AND direction = 'out' AND processed = false AND operation = 'UPDATE';
    """)

    seen_record_ids = set()
    for row in rows:
        try:
            payload_preview = row[4] if isinstance(row[4], dict) else json.loads(row[4])
            rid = payload_preview.get("id")
            email = payload_preview.get("booking_email", "okÃ¤nd e-post")
            seen_record_ids.add(rid)
        except Exception as e:
            pass
    count = 0
    for row in rows:
        change_id, table, record_id, operation, payload_json = row
        try:
            payload = payload_json if isinstance(payload_json, dict) else json.loads(payload_json)
            if not isinstance(payload.get("id"), str) or "your-generated-id" in payload.get("id"):
                continue
            apply_change(local_cur, table, operation, payload)
            if table == "bookings" and operation == "INSERT":
                local_cur.execute(
                    """
                    UPDATE pending_changes
                    SET booking_id = %s
                    WHERE record_id = %s AND table_name = 'bookings' AND booking_id IS NULL
                    """,
                    (record_id, record_id)
                )
                local_conn.commit()
            if table == "contact":
                email = payload.get("booking_email", "(okÃ¤nd e-post)")
                meta = payload.get("metadata")
                if isinstance(meta, str):
                    try:
                        meta = json.loads(meta)
                    except Exception:
                        meta = {}
                elif not isinstance(meta, dict):
                    meta = {}
                address = meta.get("address", "(okÃ¤nd adress)")
                print(f"ğŸ“¥ Importerad kontakt: {email} â†’ {address}")
            if table == "bookings" and operation == "INSERT":
                pass  # Notis borttagen
            local_cur.execute("""
                INSERT INTO event_log (id, source, event_type, payload, received_at)
                VALUES (gen_random_uuid(), %s, %s, %s, now())
            """, ('sync', f"{operation.lower()}_{table}", json.dumps(payload)))
            remote_cur.execute("UPDATE pending_changes SET processed = true WHERE id = %s", [change_id])
            remote_conn.commit()
            count += 1
        except Exception as e:
            print(f"âŒ Fel vid synk fÃ¶r {table} (id={change_id}): {e}")
            continue

    local_conn.commit()
    local_cur.close()
    remote_cur.close()
    local_conn.close()
    remote_conn.close()

if __name__ == "__main__":
    sync()
END: sync_from_cloud.py

====================
ğŸ“„ Fil: sync_to_cloud.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-05-15 18:23:01
ğŸ“ Antal rader: 211
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 3 â€“ ['import psycopg2', 'import json', 'import traceback']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 41
ğŸ§ª TODO/FIXME: 0
====================
START: sync_to_cloud.py
import psycopg2
import json
from datetime import datetime, timezone
from config import LOCAL_DB_CONFIG, REMOTE_DB_CONFIG

def connect_db(config):
    return psycopg2.connect(**config)

def fetch_pending_changes(conn):
    with conn.cursor() as cur:
        cur.execute("""
            SELECT id, table_name, record_id, operation, payload
            FROM (
                SELECT *, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
                FROM pending_changes
                WHERE direction = 'out' AND processed = false
                  AND table_name IN ('contact', 'bookings')
            ) sub
            WHERE rn = 1
            ORDER BY created_at ASC, id
        """)
        rows = cur.fetchall()

        # Rensa Ã¤ldre UPDATE-poster med samma record_id
        cur.execute("""
            DELETE FROM pending_changes
            WHERE id NOT IN (
                SELECT id FROM (
                    SELECT id, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at ASC) AS rn
                    FROM pending_changes
                    WHERE direction = 'out' AND processed = false
                ) sub
                WHERE rn = 1
            ) AND direction = 'out' AND processed = false AND operation = 'UPDATE';
        """)
        return rows

def mark_as_processed(conn, change_id):
    with conn.cursor() as cur:
        cur.execute("UPDATE pending_changes SET processed = true WHERE id = %s", (change_id,))
        conn.commit()

#
# ğŸ“ SYNC-BETEENDE: Hantering av metadata
#
# Viktigt att fÃ¶rstÃ¥ skillnaden:
#
# 1. Ã„ndring av vÃ¤rde:
#    - Exempel: "postal_code": "111 11" â†’ "115 32"
#    - Hanteras som en vanlig UPDATE (om updated_at Ã¤r nyare)
#
# 2. Ã„ndring av nyckel (etikett):
#    - Exempel: "postal_number" â†’ "postal_code"
#    - Molnet kommer *inte* ta bort "postal_number" utan force_resync
#    - LÃ¤gg till `"force_resync": true` i metadata fÃ¶r att tvinga full Ã¶verskrivning
#
# Detta minskar risken att data i molnet raderas av misstag.

def apply_change(conn, change, local_conn):
    table_name, record_id, operation, payload = change[1], change[2], change[3], change[4]
    with conn.cursor() as cur:
        data = json.loads(payload) if isinstance(payload, str) else payload

        # Skip contact records with metadata.origin != 'klrab.se'
        if table_name == 'contact' and 'metadata' in data:
            meta = json.loads(data['metadata']) if isinstance(data['metadata'], str) else data['metadata']
            if meta.get('origin') != 'klrab.se':
                print(f"âš ï¸ Skickas ej: origin != klrab.se â€“ {data.get('booking_email')}")
                mark_as_processed(local_conn, change[0])
                return

        # Ensure all values are serializable to SQL
        for k, v in data.items():
            if isinstance(v, dict):
                data[k] = json.dumps(v)

        if 'updated_at' in data:
            if isinstance(data['updated_at'], str):
                # Parse and convert to UTC if it's a string
                try:
                    dt = datetime.fromisoformat(data['updated_at'])
                    data['updated_at'] = dt.astimezone(timezone.utc).isoformat()
                except Exception as e:
                    print(f"âš ï¸ Kunde inte tolka updated_at: {data['updated_at']} ({e})")
            elif isinstance(data['updated_at'], datetime):
                data['updated_at'] = data['updated_at'].astimezone(timezone.utc).isoformat()

        if operation == 'INSERT':
            columns = ', '.join(data.keys())
            placeholders = ', '.join(['%s'] * len(data))
            values = list(data.values())
            cur.execute(
                f"INSERT INTO {table_name} ({columns}) VALUES ({placeholders}) "
                f"ON CONFLICT (id) DO UPDATE SET "
                f"{', '.join([f'{k} = EXCLUDED.{k}' for k in data.keys() if k != 'id'])}",
                values
            )
            if table_name == 'bookings':
                with local_conn.cursor() as local_cur:
                    local_cur.execute(
                        """
                        UPDATE pending_changes
                        SET booking_id = %s
                        WHERE record_id = %s AND table_name = 'bookings' AND booking_id IS NULL
                        """,
                        (record_id, record_id)
                    )
                    local_conn.commit()
        if 'metadata' in data and table_name == 'contact':
            # Merge metadata with existing remote value and ensure JSON string
            cur.execute(f"SELECT metadata FROM {table_name} WHERE id = %s", (record_id,))
            row = cur.fetchone()
            if row and row[0]:
                if isinstance(row[0], dict):
                    existing_metadata = row[0]
                else:
                    existing_metadata = json.loads(row[0])
            else:
                existing_metadata = {}

            incoming_metadata = json.loads(data['metadata']) if isinstance(data['metadata'], str) else data['metadata']
            if existing_metadata == incoming_metadata:
                mark_as_processed(local_conn, change[0])
                return
            existing_metadata.update(incoming_metadata)
            changed_keys = [k for k in incoming_metadata if existing_metadata.get(k) != incoming_metadata[k]]
            if not changed_keys:
                mark_as_processed(local_conn, change[0])
                return
            data['metadata'] = json.dumps(existing_metadata)

        if operation == 'UPDATE':
            # FÃ¶rbÃ¤ttrad hantering av tidsjÃ¤mfÃ¶relse fÃ¶r updated_at
            if 'updated_at' in data:
                try:
                    # SÃ¤kerstÃ¤ll att local_ts Ã¤r datetime i UTC
                    local_ts = data['updated_at']
                    if isinstance(local_ts, str):
                        local_ts = datetime.fromisoformat(local_ts)
                    if local_ts.tzinfo is None:
                        local_ts = local_ts.replace(tzinfo=timezone.utc)
                    else:
                        local_ts = local_ts.astimezone(timezone.utc)

                    cur.execute(f"SELECT updated_at FROM {table_name} WHERE id = %s", (record_id,))
                    row = cur.fetchone()
                    if row and row[0] and isinstance(row[0], datetime):
                        remote_ts = row[0]
                        if remote_ts.tzinfo is None:
                            remote_ts = remote_ts.replace(tzinfo=timezone.utc)
                        else:
                            remote_ts = remote_ts.astimezone(timezone.utc)

                        if local_ts <= remote_ts:
                            mark_as_processed(local_conn, change[0])
                            return
                except Exception:
                    pass

            if table_name == "contact" and "metadata" in data:
                local_meta = data["metadata"]
                if isinstance(local_meta, str):
                    local_meta = json.loads(local_meta)
                cur.execute("SELECT metadata FROM contact WHERE id = %s", (data["id"],))
                row = cur.fetchone()
                if row:
                    remote_meta = row[0]
                    if isinstance(remote_meta, str):
                        remote_meta = json.loads(remote_meta)
                    if remote_meta == local_meta:
                        mark_as_processed(local_conn, change[0])
                        return

            columns = ', '.join(data.keys())
            placeholders = ', '.join(['%s'] * len(data))
            values = list(data.values())
            update_keys = [k for k in data.keys() if k != 'id']
            update_set = ', '.join([f"{k} = %s" for k in update_keys])
            update_values = [data[k] for k in update_keys]
            update_values.append(record_id)
            cur.execute(
                f"UPDATE {table_name} SET {update_set} WHERE id = %s",
                update_values
            )
            cur.execute("SELECT metadata, updated_at FROM contact WHERE id = %s", [payload["id"]])
            updated_row = cur.fetchone()
        elif operation == 'DELETE':
            cur.execute(f"DELETE FROM {table_name} WHERE id = %s", (record_id,))
        conn.commit()
        mark_as_processed(local_conn, change[0])

def sync():
    import traceback
    local_conn = connect_db(LOCAL_DB_CONFIG)
    remote_conn = connect_db(REMOTE_DB_CONFIG)

    changes = fetch_pending_changes(local_conn)
    count = 0
    for change in changes:
        try:
            apply_change(remote_conn, change, local_conn)
            count += 1
        except Exception as e:
            print(f"âŒ Misslyckades att applicera Ã¤ndring pÃ¥ {change[1]} (id={change[2]}): {e}")
            traceback.print_exc()
    
    local_conn.close()
    remote_conn.close()

if __name__ == "__main__":
    sync()
END: sync_to_cloud.py

====================
ğŸ“„ Fil: sync_static_tables.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-04-24 17:01:52
ğŸ“ Antal rader: 61
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ['import psycopg2', 'import json']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 6
ğŸ§ª TODO/FIXME: 0
====================
START: sync_static_tables.py
from config import LOCAL_DB_CONFIG, REMOTE_DB_CONFIG
import psycopg2
import json
from datetime import datetime


TABLES = ["translation", "booking_settings"]


def connect_db(config):
    return psycopg2.connect(**config)


def fetch_all_from_local(conn, table):
    with conn.cursor() as cur:
        cur.execute(f"SELECT * FROM {table}")
        colnames = [desc[0] for desc in cur.description]
        rows = cur.fetchall()
        return colnames, rows


def clear_remote_table(conn, table):
    with conn.cursor() as cur:
        cur.execute(f"DELETE FROM {table}")
        conn.commit()


def insert_to_remote(conn, table, columns, rows):
    with conn.cursor() as cur:
        placeholders = ', '.join(['%s'] * len(columns))
        colnames = ', '.join(columns)
        for row in rows:
            # Hantera jsonb-vÃ¤rden som json-strÃ¤ngar
            formatted_row = []
            for i, col in enumerate(columns):
                value = row[i]
                if table == 'booking_settings' and col == 'value':
                    formatted_row.append(json.dumps(value))
                else:
                    formatted_row.append(value)
            cur.execute(f"INSERT INTO {table} ({colnames}) VALUES ({placeholders})", formatted_row)
        conn.commit()


def sync_static_tables():
    local_conn = connect_db(LOCAL_DB_CONFIG)
    remote_conn = connect_db(REMOTE_DB_CONFIG)

    for table in TABLES:
        print(f"\nâ³ Synkar tabell: {table}...")
        columns, rows = fetch_all_from_local(local_conn, table)
        clear_remote_table(remote_conn, table)
        insert_to_remote(remote_conn, table, columns, rows)
        print(f"âœ… Klar med tabell: {table} ({len(rows)} rader)")

    local_conn.close()
    remote_conn.close()


if __name__ == "__main__":
    sync_static_tables()

END: sync_static_tables.py

====================
ğŸ“„ Fil: sync.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-05-14 15:43:17
ğŸ“ Antal rader: 82
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ['import psycopg2', 'import json']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 10
ğŸ§ª TODO/FIXME: 0
====================
START: sync.py
import psycopg2
import json
from datetime import datetime
from config import LOCAL_DB_CONFIG

# Anslutning till lokal PostgreSQL
conn = psycopg2.connect(**LOCAL_DB_CONFIG)
cursor = conn.cursor()

# Rensa Ã¤ldre UPDATE-rader (endast senaste behÃ¶vs per record_id)
cursor.execute("""
    DELETE FROM pending_changes pc
    WHERE operation = 'UPDATE'
      AND processed = false
      AND direction = 'out'
      AND id NOT IN (
        SELECT id FROM (
          SELECT id,
                 ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at DESC) AS rn
          FROM pending_changes
          WHERE operation = 'UPDATE'
            AND processed = false
            AND direction = 'out'
        ) sub
        WHERE rn = 1
      );
""")

# HÃ¤mta EN Ã¤ndring per kontakt (record_id) â€“ endast senaste per kontakt exporteras med hjÃ¤lp av ROW_NUMBER()
cursor.execute("""
    SELECT id, table_name, record_id, operation, payload, created_at
    FROM (
        SELECT *, ROW_NUMBER() OVER (PARTITION BY record_id ORDER BY created_at DESC) as rn
        FROM pending_changes
        WHERE processed = false AND direction = 'out'
    ) sub
    WHERE rn = 1
""")

rows = cursor.fetchall()

# Filtrera bort poster dÃ¤r metadata Ã¤r identisk med befintlig kontakt
filtered_rows = []
for row in rows:
    change_id, table, record_id, operation, payload, created_at = row
    data = json.loads(payload) if isinstance(payload, str) else payload
    if table == "contact" and operation == "UPDATE":
        try:
            cursor.execute("SELECT metadata FROM contact WHERE id = %s", (record_id,))
            result = cursor.fetchone()
            if result:
                current_metadata = result[0] if isinstance(result[0], dict) else json.loads(result[0])
                incoming_metadata = data.get("metadata")
                if isinstance(incoming_metadata, str):
                    incoming_metadata = json.loads(incoming_metadata)
                if current_metadata == incoming_metadata:
                    continue
        except Exception as e:
            print(f"âš ï¸ Kunde inte jÃ¤mfÃ¶ra metadata fÃ¶r {record_id}: {e}")
    filtered_rows.append(row)
rows = filtered_rows

# Skapa exportformat
export = []
for row in rows:
    change_id, table, record_id, operation, payload, created_at = row
    export.append({
        "change_id": str(change_id),
        "table": table,
        "operation": operation,
        "data": payload
    })

# Spara till JSON-fil med tidsstÃ¤mpel
if export:
    first_type = export[0]["table"] if export else "unknown"
    filename = f"sync_outbox/{datetime.now().strftime('%Y%m%d_%H%M%S')}_{first_type}.json"
    with open(filename, "w", encoding="utf-8") as f:
        json.dump(export, f, indent=2, ensure_ascii=False)

cursor.close()
conn.close()

END: sync.py

====================
ğŸ“„ Fil: sync_all.py
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸ Python
ğŸ“… Senast Ã¤ndrad: 2025-05-14 15:49:04
ğŸ“ Antal rader: 148
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 6 â€“ ['import os', 'import subprocess', 'import sys', 'import psycopg2', 'import socket', 'import traceback']
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 18
ğŸ§ª TODO/FIXME: 0
====================
START: sync_all.py
BASE = "/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot/macspot-api"

import os
import subprocess
from datetime import datetime
import sys
import psycopg2

log_dir = "/Users/danielkallberg/Documents/KLR_AI/Projekt_MacSpot"
log_out = os.path.join(log_dir, "macspot_sync.log")
log_err = os.path.join(log_dir, "macspot_sync_error.log")

# Se till att loggfilerna existerar
for path in [log_out, log_err]:
    if not os.path.exists(path):
        with open(path, 'w'):
            pass

# Skriv ut manuell/automatisk kÃ¶rningsinfo till loggen
is_manual = sys.stdout.isatty()
sys.stdout = open(log_out, 'a')
sys.stderr = open(log_err, 'a')
if is_manual:
    print(f"ğŸ–ï¸ Manuell kÃ¶rning: {datetime.now().isoformat()}")
else:
    print(f"ğŸ¤– Automatisk kÃ¶rning via launchd: {datetime.now().isoformat()}")

def run_script(name, script_path):
    subprocess.run(["python", f"{BASE}/{script_path}"], check=True)

try:
    start_time = datetime.now()
    def is_database_online(host, port):
        import socket
        try:
            socket.create_connection((host, port), timeout=2)
            return True
        except:
            return False

    # Kontrollera att bÃ¥da databaser Ã¤r online innan sync startar
    if not is_database_online("localhost", 5433):
        print("âŒ Lokal databas Ã¤r inte tillgÃ¤nglig (localhost:5433)")
        exit(1)

    if not is_database_online("macspotpg.postgres.database.azure.com", 5432):
        print("âŒ Azure-databasen Ã¤r inte tillgÃ¤nglig (macspotpg.postgres.database.azure.com:5432)")
        exit(1)

    print(f"ğŸ“Œ KÃ¶rning initierad: {datetime.now().isoformat()}")

    print(f"\nğŸ”„ [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Startar fullstÃ¤ndig synk...")

    scripts_part1 = [
        ("ğŸŸ¡ KÃ¶r sync.py...", "sync.py"),
        ("ğŸŸ¢ KÃ¶r sync_to_cloud.py...", "sync_to_cloud.py")
    ]

    for msg, script in scripts_part1:
        run_script(msg, script)

    scripts_part2 = [
        ("ğŸ”µ KÃ¶r sync_from_cloud.py...", "sync_from_cloud.py")
    ]

    for msg, script in scripts_part2:
        run_script(msg, script)

    today_prefix = datetime.now().strftime('%Y%m%d')
    outbox_dir = os.path.join(BASE, 'sync_outbox')
    files = [f for f in os.listdir(outbox_dir) if f.startswith(today_prefix)]
    files_with_type = [f for f in files if len(f.split("_")) >= 3]
    num_changes = len(files_with_type)

    if num_changes == 0:
        print("â„¹ï¸ Ingen fÃ¶rÃ¤ndring hittades att synka.")
        print("ğŸ“­ Inga fler Ã¤ndringar kvar i pending_changes.")
    else:
        print(f"ğŸ“¤ Totalt {num_changes} Ã¤ndring(ar) skickades till molnet:")
        files = [f for f in sorted(os.listdir(outbox_dir)) if f.startswith(today_prefix)]
        summary = {}
        for f in files:
            parts = f.split("_")
            if len(parts) >= 3:
                typ = parts[2].split(".")[0]
                summary[typ] = summary.get(typ, 0) + 1

        if summary:
            print("ğŸ§¾ Sammanfattning per typ:")
            for typ, count in summary.items():
                print(f"   â€¢ {typ}: {count} st")

        print("ğŸ“Š Kontroll av Ã¥terstÃ¥ende Ã¤ndringar i pending_changes...")

        # Lokalt
        local = psycopg2.connect(
            dbname="macspot",
            user="postgres",
            host="localhost",
            port=5433
        )
        cur_local = local.cursor()
        cur_local.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
        """)
        out_local = cur_local.fetchone()[0]
        cur_local.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
            GROUP BY record_id
        """)
        print(f"   â€¢ Lokalt â†’ molnet: {out_local} Ã¤ndring(ar) kvar Ã¶ver {cur_local.rowcount} kontakt(er).")
        cur_local.close()
        local.close()

        # Molnet
        cloud = psycopg2.connect(
            dbname="postgres",
            user="daniel",
            host="macspotpg.postgres.database.azure.com",
            port=5432
        )
        cur_cloud = cloud.cursor()
        cur_cloud.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
        """)
        out_cloud = cur_cloud.fetchone()[0]
        cur_cloud.execute("""
            SELECT COUNT(*) FROM pending_changes
            WHERE direction = 'out' AND processed = false
            GROUP BY record_id
        """)
        cur_cloud.close()
        cloud.close()

    print(f"\nâœ… [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] FullstÃ¤ndig synk kÃ¶rd.")

except Exception as e:
    import traceback
    print("âŒ Ett ovÃ¤ntat fel intrÃ¤ffade under kÃ¶rningen:")
    print(traceback.format_exc())

finally:
    print(f"ğŸ KÃ¶rning avslutad: {datetime.now().isoformat()}")
    duration = datetime.now() - start_time
    print(f"â±ï¸ Total kÃ¶rtid: {int(duration.total_seconds())} sekunder")
END: sync_all.py

ğŸ“ KONFIGURATIONSFILER (function.json / host.json / package.json / .funcignore)
====================================

ğŸ“„ .funcignore
   # Exclude dev-only files and folders
   .git
   .vscode
   .env
   *.log
   test/
   tests/
   
   # Explicitly include all required files and folders
   !host.json
   !package.json
   !package-lock.json
   
   !node_modules/
   !node_modules/**
   
   !shared/
   !shared/**
   
   !bookings/
   !bookings/**
   !getavailableslots/
   !getavailableslots/**
   !validate_contact/
   !validate_contact/**
   !meeting_types/
   !meeting_types/**
   !refreshCalendarOrigins/
   !refreshCalendarOrigins/**
   !refreshTravelTimes/
   !refreshTravelTimes/**
   !booking_settings/
   !booking_settings/**
ğŸ“„ booking_settings/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get"],
         "route": "booking_settings"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ bookings/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "bookings"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ getavailableslots/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "getavailableslots"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ host.json
   {
     "version": "2.0",
     "extensionBundle": {
       "id": "Microsoft.Azure.Functions.ExtensionBundle",
       "version": "[4.*, 5.0.0)"
     },
     "extensions": {
       "http": {
         "cors": {
           "allowedOrigins": [
             "https://www.klrab.se"
           ],
           "supportCredentials": false
         }
       }
     }
   }
ğŸ“„ meeting_types/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": [ "get" ],
         "route": "meeting_types"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ package.json
   {
     "name": "macspot-api",
     "version": "1.0.0",
     "description": "Azure Functions backend fÃ¶r MacSpot CRM/ERP",
     "scripts": {
       "start": "func start",
       "dev": "func start --verbose",
       "deploy": "func azure functionapp publish macspotbackend",
       "build": "echo 'Nothing to build'"
     },
     "dependencies": {
       "@azure/functions": "^4.7.0",
       "@azure/msal-node": "^3.5.1",
       "@microsoft/microsoft-graph-client": "^3.0.0",
       "dav": "^1.8.0",
       "dotenv": "^16.5.0",
       "isomorphic-fetch": "^3.0.0",
       "jsonwebtoken": "^9.0.0",
       "luxon": "^3.4.4",
       "node-fetch": "^2.7.0",
       "node-ical": "^0.20.1",
       "p-limit": "^6.2.0",
       "pg": "^8.15.6",
       "uuid": "^9.0.0",
       "xml2js": "^0.6.2"
     }
   }

ğŸ“„ refreshCalendarOrigins/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ refreshTravelTimes/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ validate_contact/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post"],
         "route": "validate_contact"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“ˆ SUMMERING AV ALLA JS-FILER
====================================
ğŸ“ Totalt antal rader kod: 2499
ğŸ§© Totalt antal funktioner: 38
ğŸ§  Total komplexitetspoÃ¤ng: 277
ğŸ§ª Antal TODO/FIXME totalt: 0

ğŸ“Š Per fil:
fil,rader,funktioner,komplexitet,kommentarer,imports
index.js,47,1,3,1,2
index.js,121,1,14,1,3
index.js,191,2,13,2,9
index.js,36,1,1,0,4
index.js,112,4,8,0,6
appleCalendar.js,166,4,13,1,2
getMsToken.js,57,1,5,0,2
msGraph.js,102,4,10,0,5
resolveOrigin.js,235,2,37,21,0
settingsLoader.js,71,2,11,0,1
verifySettings.js,52,1,8,0,0
pgPool.js,20,1,0,0,2
appleMaps.js,121,5,9,0,2
returnTravelVerifier.js,66,1,4,1,1
resolveTravelTime.js,72,1,8,0,0
index.js,139,1,11,5,4
debugLogger.js,23,2,2,0,0
slotEngine.js,225,4,17,4,6
sync_from_cloud.py,141,0,28,0,2
sync_to_cloud.py,211,0,41,0,3
sync_static_tables.py,61,0,6,0,2
sync.py,82,0,10,0,2
sync_all.py,148,0,18,0,6
ğŸ“Š MOLNDATABAS (Azure) â€“ STRUKTUR & INNEHÃ…LL
====================================

ğŸ“ Tabell: available_slots_cache
  â€¢ id (uuid)
  â€¢ travel_time_min (integer)
  â€¢ generated_at (timestamp without time zone)
  â€¢ expires_at (timestamp without time zone)
  â€¢ meeting_length (integer)
  â€¢ slot_day (date)
  â€¢ slot_score (integer)
  â€¢ meeting_type (text)
  â€¢ slot_part (text)
  â€¢ slot_iso (text)
  ğŸ”‘ [p] available_slots_cache_pkey: PRIMARY KEY (id)

ğŸ“ Tabell: slot_cache
  â€¢ created_at (timestamp without time zone)
  â€¢ slot_day (date)
  â€¢ slots (jsonb)
  â€¢ id (uuid)
  â€¢ meeting_length (integer)
  â€¢ booking_email (text)
  â€¢ meeting_type (text)
  â€¢ slot_part (text)
  ğŸ”‘ [p] slot_cache_pkey: PRIMARY KEY (id)

ğŸ“ Tabell: calendar_origin_cache
  â€¢ created_at (timestamp without time zone)
  â€¢ timestamp (timestamp with time zone)
  â€¢ event_date (date)
  â€¢ id (integer)
  â€¢ end_time (timestamp without time zone)
  â€¢ address (text)
  â€¢ source (text)
  ğŸ”‘ [c] calendar_origin_cache_source_check: CHECK ((source = ANY (ARRAY['Apple Calendar'::text, 'Microsoft 365'::text])))
  ğŸ”‘ [p] calendar_origin_cache_pkey: PRIMARY KEY (id)

ğŸ“ Tabell: travel_time_cache
  â€¢ travel_minutes (integer)
  â€¢ updated_at (timestamp with time zone)
  â€¢ is_fallback (boolean)
  â€¢ hour (integer)
  â€¢ created_at (timestamp with time zone)
  â€¢ to_address (text)
  â€¢ from_address (text)
  ğŸ”‘ [u] unique_travel_key: UNIQUE (from_address, to_address, hour)

ğŸ“ Tabell: event_log
  â€¢ received_at (timestamp with time zone)
  â€¢ record_id (uuid)
  â€¢ timestamp (timestamp with time zone)
  â€¢ booking_id (uuid)
  â€¢ id (uuid)
  â€¢ payload (jsonb)
  â€¢ action (text)
  â€¢ event_type (text)
  â€¢ source (text)
  â€¢ table_name (text)
  ğŸ”‘ [p] event_log_pkey: PRIMARY KEY (id)

ğŸ“ Tabell: booking_settings
  â€¢ value (jsonb)
  â€¢ updated_at (timestamp with time zone)
  â€¢ key (text)
  â€¢ value_type (text)
  ğŸ§ª Topp 5 rader:
    - key=max_days_in_advance, value=30, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=buffer_between_meetings, value=15, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=max_weekly_booking_minutes, value=360, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=default_office_address, value=Maria Skolgata 79A, 118 53 Stockholm, value_type=string, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=fallback_travel_time_minutes, value=90, value_type=int, updated_at=2025-04-23 12:48:49.778155+00:00

ğŸ“ Tabell: translation
  â€¢ key (character varying)
  â€¢ sv (text)
  â€¢ en (text)
  ğŸ§ª Topp 5 rader:
    - key=error_min_duration_fysiskt_kund, sv=MÃ¶testiden fÃ¶r 'Fysiskt hos kund' mÃ¥ste vara minst {{minutes}} minuter. Du visste det redan., en=The meeting time for 'On-site at customer' must be at least {{minutes}} minutes. You knew that.
    - key=error_min_duration_fysiskt_mig, sv=MÃ¶testiden fÃ¶r 'Fysiskt hos mig' mÃ¥ste vara minst {{minutes}} minuter. Annars hinner vi bara sÃ¤ga hej., en=The meeting time for 'At my office' must be at least {{minutes}} minutes. Otherwise, weâ€™ll only have time to say hello.
    - key=email_body_booking_received, sv=Hej {{name}}! Vi har tagit emot din bokning fÃ¶r {{meeting_type}} mellan {{start_time}} och {{end_time}}. Ingen panik â€“ vi Ã¥terkommer med bekrÃ¤ftelse. / Daniel, en=Hello {{name}}, Weâ€™ve received your booking for {{meeting_type}} between {{start_time}} and {{end_time}}. No need to panic â€“ weâ€™ll confirm shortly. / Daniel
    - key=email_body_booking_confirmed, sv=Hej {{name}}! Din bokning fÃ¶r {{meeting_type}} mellan {{start_time}} och {{end_time}} Ã¤r nu spikad. Ser fram emot det! / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} is now locked in. Looking forward! / Daniel
    - key=email_body_booking_cancelled, sv=Hej {{name}}! Din bokning fÃ¶r {{meeting_type}} mellan {{start_time}} och {{end_time}} Ã¤r avbokad. HÃ¶r av dig om du vill hitta en ny tid. / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} has been cancelled. Let me know if you'd like a new one. / Daniel

ğŸ“ Tabell: bookings
  â€¢ start_time (timestamp with time zone)
  â€¢ end_time (timestamp with time zone)
  â€¢ id (uuid)
  â€¢ updated_at (timestamp with time zone)
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp with time zone)
  â€¢ contact_id (uuid)
  â€¢ meeting_type (text)
  â€¢ booking_email (text)
  ğŸ”‘ [p] bookings_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] fk_bookings_contact: FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE SET NULL

ğŸ“ Tabell: pending_changes
  â€¢ booking_id (uuid)
  â€¢ processed (boolean)
  â€¢ created_at (timestamp with time zone)
  â€¢ payload (jsonb)
  â€¢ id (uuid)
  â€¢ record_id (uuid)
  â€¢ table_name (text)
  â€¢ operation (text)
  â€¢ change_type (text)
  â€¢ direction (text)
  ğŸ”‘ [p] pending_changes_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] fk_pending_changes_booking_id: FOREIGN KEY (booking_id) REFERENCES bookings(id) ON DELETE CASCADE

ğŸ“ Tabell: contact
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp with time zone)
  â€¢ id (uuid)
  â€¢ updated_at (timestamp with time zone)
  â€¢ booking_email (text)
  â€¢ email (text)
  ğŸ”‘ [p] contact_pkey: PRIMARY KEY (id)

