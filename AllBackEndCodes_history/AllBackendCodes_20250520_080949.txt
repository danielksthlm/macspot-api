üìÇ KODTR√ÑD
==========
‚îú‚îÄ‚îÄ bookings
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ getavailableslots
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ meeting_types
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ refreshCalendarOrigins
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ refreshTravelTimes
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ calendar
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ appleCalendar.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ calendar
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ getMsToken.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ calendar
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ msGraph.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ calendar
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resolveOrigin.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ settingsLoader.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ verifySettings.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ db
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pgPool.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ maps
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ appleMaps.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ maps
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ returnTravelVerifier.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ maps
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ travelTimeResolver.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ slots
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ finalizeSlots.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ slots
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ generateSlots.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ slots
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ slotEngine.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ slots
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ slotRules.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ debugLogger.js
‚îú‚îÄ‚îÄ validate_contact
‚îÇ   ‚îú‚îÄ‚îÄ index.js
==========

====================
üìÑ Fil: index.js
üìÖ Senast √§ndrad: 2025-05-19 09:56:12
üìè Antal rader: 66
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 1 rader (1.5%)
üì• Imports: 1 ‚Äì ["const { Pool } = require('pg');"]
üîç L√§ngsta funktion: 7 rader
üß† Komplexitetspo√§ng: 5
üß™ TODO/FIXME: 0
====================
START: index.js
const { Pool } = require('pg');

const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: { rejectUnauthorized: false }
});

module.exports = async function (context, req) {
  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.log.error(`Missing environment variable: ${key}`);
      context.res = {
        status: 500,
        body: { error: `Missing environment variable: ${key}` }
      };
      return;
    }
  }

  try {
    const settingsRes = await pool.query(
      "select key, value from booking_settings where key in ('meeting_types', 'default_meeting_length_atclient', 'default_meeting_length_atoffice', 'default_meeting_length_digital')"
    );

    const settings = {};
    for (const row of settingsRes.rows) {
      try {
        settings[row.key] = JSON.parse(row.value);
      } catch {
        settings[row.key] = row.value;
      }
    }

    const rawTypes = settings['meeting_types'];
    const meetingTypes = Array.isArray(rawTypes) ? rawTypes.map(t => t.toLowerCase()) : [];
    const lengths = {
      zoom: settings['default_meeting_length_digital'],
      facetime: settings['default_meeting_length_digital'],
      teams: settings['default_meeting_length_digital'],
      atclient: settings['default_meeting_length_atclient'],
      atoffice: settings['default_meeting_length_atoffice']
    };

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        types: meetingTypes,
        lengths
      })
    };
  } catch (error) {
    context.log.error('Database query failed:', error);
    context.res = {
      status: 500,
      body: { error: error.message }
    };
  } finally {
    // pool.end() tas bort ‚Äì vi √•teranv√§nder en delad pool mellan anrop
  }
};
END: index.js

====================
üìÑ Fil: index.js
üìÖ Senast √§ndrad: 2025-05-15 10:15:41
üìè Antal rader: 128
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 1 rader (0.8%)
üì• Imports: 2 ‚Äì ["const { Pool } = require('pg');", "const { v4: uuidv4 } = require('uuid');"]
üîç L√§ngsta funktion: 7 rader
üß† Komplexitetspo√§ng: 14
üß™ TODO/FIXME: 0
====================
START: index.js
const { Pool } = require('pg');
const { v4: uuidv4 } = require('uuid');
const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: { rejectUnauthorized: false }
});

module.exports = async function (context, req) {
  try {
    const email = req.body?.email || req.query?.email;
    const meeting_type = req.body?.meeting_type || req.query?.meeting_type;
    context.log.info('üì• validate_contact triggered with:', { email, meeting_type });

    if (!email || !meeting_type) {
      context.res = { status: 400, body: { error: "email and meeting_type are required" } };
      return;
    }

    const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
    for (const key of requiredEnv) {
      if (!process.env[key]) throw new Error(`Missing environment variable: ${key}`);
    }

    const contactRes = await pool.query('SELECT * FROM contact WHERE booking_email = $1', [email]);
    const contact = contactRes.rows[0];
    let metadata = contact?.metadata || {};

    if (typeof metadata === 'string') {
      try {
        metadata = JSON.parse(metadata);
      } catch {
        metadata = {};
      }
    }

    if (typeof metadata !== 'object' || metadata === null) metadata = {};

    const settingsRes = await pool.query('SELECT value FROM booking_settings WHERE key = $1', ['meeting_digital']);
    const raw = settingsRes.rows[0]?.value;
    const digitalTypes = Array.isArray(raw) ? raw : JSON.parse(raw || '[]');
    const isDigital = digitalTypes.map(t => t.toLowerCase()).includes(meeting_type.toLowerCase()) || meeting_type === 'atoffice';

    const alwaysRequired = ['first_name', 'last_name', 'phone', 'company'];
    const addressRequired = ['address', 'postal_code', 'city', 'country'];
    const requiredFields = [...alwaysRequired, ...(isDigital ? [] : addressRequired)];
    const missingFields = requiredFields.filter(
      field => !metadata[field] || typeof metadata[field] !== 'string' || metadata[field].trim() === ''
    );

    if ((req.body?.write_if_valid || req.query?.write_if_valid) && missingFields.length > 0) {
      let metadataFromClient = req.body?.metadata;
      if (typeof metadataFromClient === 'string') {
        try {
          metadataFromClient = JSON.parse(metadataFromClient);
        } catch {
          metadataFromClient = {};
        }
      }
      if (typeof metadataFromClient === 'object' && metadataFromClient !== null) {
        if (!contact) {
          const newId = uuidv4();
          await pool.query(
            `INSERT INTO contact (id, booking_email, metadata, created_at) VALUES ($1, $2, $3, NOW())`,
            [newId, email, metadataFromClient]
          );
          context.log.info('‚úÖ Ny kontakt skapad via validate_contact');

          context.res = {
            status: 200,
            body: {
              status: "created",
              contact_id: newId
            }
          };
          return;
        } else {
          await pool.query(
            `UPDATE contact SET metadata = $1, updated_at = NOW() WHERE booking_email = $2`,
            [metadataFromClient, email]
          );
          context.log.info('‚úèÔ∏è Befintlig kontakt uppdaterad via validate_contact');
        }
      }
    }

    if (!contact) {
      context.res = {
        status: 200,
        body: {
          status: "new_customer",
          missing_fields: missingFields
        }
      };
    } else if (missingFields.length > 0) {
      context.res = {
        status: 200,
        body: {
          status: "incomplete",
          missing_fields: missingFields
        }
      };
    } else {
      context.res = {
        status: 200,
        body: {
          status: "existing_customer",
          contact_id: contact.id
        }
      };
    }

  } catch (error) {
    context.log.error('‚ùå Error during validate_contact:', {
      message: error.message,
      stack: error.stack
    });
    context.res = {
      status: 500,
      body: { error: error.message, stack: error.stack }
    };
  } finally {
    // Poolen √§r delad och √•teranv√§nds ‚Äì vi st√§nger den inte h√§r
  }
};
END: index.js

====================
üìÑ Fil: index.js
üìÖ Senast √§ndrad: 2025-05-20 08:06:52
üìè Antal rader: 229
üß© Antal funktioner: 4
üí¨ Kommentarst√§ckning: 14 rader (6.1%)
üì• Imports: 11 ‚Äì ["const { generateSlotChunks } = require('../shared/slots/slotEngine');", "const { DateTime } = require('luxon');", "const pool = require('../shared/db/pgPool');", "const loadSettings = require('../shared/config/settingsLoader');", "const graphClient = require('../shared/calendar/msGraph')();", "const appleClient = require('../shared/calendar/appleCalendar')();", "const verifyBookingSettings = require('../shared/config/verifySettings');", "const { createDebugLogger } = require('../shared/utils/debugLogger');", "const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');", "const getMsToken = require('../shared/calendar/getMsToken');", "const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');"]
üîç L√§ngsta funktion: 16 rader
üß† Komplexitetspo√§ng: 14
üß™ TODO/FIXME: 0
====================
START: index.js
// SQL: GRANT USAGE, SELECT ON SEQUENCE calendar_origin_cache_id_seq TO <user>;
const { generateSlotChunks } = require('../shared/slots/slotEngine');
const { DateTime } = require('luxon');
const pool = require('../shared/db/pgPool');
const loadSettings = require('../shared/config/settingsLoader');
const graphClient = require('../shared/calendar/msGraph')();
const appleClient = require('../shared/calendar/appleCalendar')();
const verifyBookingSettings = require('../shared/config/verifySettings');

const { createDebugLogger } = require('../shared/utils/debugLogger');

module.exports = async function (context, req) {
  const startTimeMs = Date.now();
  context.log(`üì• Request mottagen: ${JSON.stringify(req.body || {}, null, 2)}`);
  let msGraphAccessToken = null;
  const isDebug = process.env.DEBUG === 'true';
  const { debugLog, skipReasons, getSkipSummary } = createDebugLogger(context);
  if (req.method === 'OPTIONS') {
    context.res = {
      status: 204,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type'
      }
    };
    return;
  }

  if (req.method !== 'POST') {
    context.res = {
      status: 405,
      body: { message: 'Method Not Allowed' }
    };
    return;
  }

  try {
    // Pool √•teranv√§nds fr√•n global instans
    // Import cache-driven origin resolution logic
    const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');
    graphClient.setToken(msGraphAccessToken);
    appleClient.setContext(context);
    debugLog('üèÅ B√∂rjar getavailableslots');
    const t0 = Date.now();
    const travelCache = new Map(); // key: from|to|hour
    // Flyttad slot-chunk och slot-generation till hj√§lpfunktion
    // Anropa generateSlotChunks direkt efter travelCache
    // (chunk-loop och slot-generation √§r nu flyttad)

    const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
    for (const key of requiredEnv) {
      if (!process.env[key]) {
        throw new Error(`Missing environment variable: ${key}`);
      }
    }
    debugLog('üîê Environment variables verified');
    debugLog('‚úÖ PostgreSQL pool created');
    debugLog('‚è±Ô∏è Efter env och pool: ' + (Date.now() - t0) + ' ms');

    const { email, contact_id, meeting_type: rawMeetingType, meeting_length } = req.body || {};
    const meeting_type = (rawMeetingType || '').toLowerCase();
    debugLog(`üì® Beg√§ran mottagen med meeting_type: ${meeting_type}, meeting_length: ${meeting_length}, contact_id: ${contact_id}, email: ${email}`);

    const db = await pool.connect();

    // H√§mta MS Graph-token en g√•ng
    const getMsToken = require('../shared/calendar/getMsToken');
    msGraphAccessToken = await getMsToken(context);

  const contactRes = await db.query('SELECT * FROM contact WHERE id = $1', [contact_id]);
  const contact = contactRes.rows[0];
  debugLog(`üë§ Kontakt hittad: ${contact?.id || 'ej funnen'}`);
    const t1 = Date.now();
    debugLog('‚è±Ô∏è Efter kontakt: ' + (Date.now() - t0) + ' ms');

    const settings = await loadSettings(db, context);
    debugLog(`‚öôÔ∏è Inst√§llningar laddade: ${Object.keys(settings).join(', ')}`);
    verifyBookingSettings(settings, context);
    debugLog('‚öôÔ∏è Inst√§llningar klara');
    const timezone = settings.timezone || 'Europe/Stockholm';
    const t2 = Date.now();
    debugLog('‚è±Ô∏è Efter settings: ' + (Date.now() - t0) + ' ms');

    const bookingsByDay = {};
    const slotGroupPicked = {};
    const chosen = [];

    const maxDays = settings.max_days_in_advance || 14;
    const today = new Date();
    const endDate = new Date(today);
    endDate.setDate(today.getDate() + maxDays);
    const totalDays = maxDays;
    const days = Array.from({ length: totalDays }, (_, i) => {
      const date = new Date(today);
      date.setDate(today.getDate() + i);
      return date;
    });
    debugLog(`üìÜ Antal dagar att bearbeta: ${days.length}`);
    debugLog('üìÖ Dagar genererade f√∂r bearbetning');

    // --- Ladda alla bokningar f√∂r hela intervallet i ett slag ---
    const startDateStr = days[0].toISOString().split('T')[0];
    const endDateStr = days[days.length - 1].toISOString().split('T')[0];
    const allBookingsRes = await db.query(
      'SELECT start_time, end_time, meeting_type FROM bookings WHERE start_time::date >= $1 AND start_time::date <= $2',
      [startDateStr, endDateStr]
    );
    context.log("üî¢ Mapping allBookings rows:", allBookingsRes.rows.length);
    const allBookings = allBookingsRes.rows.map(b => ({
      start: new Date(b.start_time).getTime(),
      end: new Date(b.end_time).getTime(),
      date: new Date(b.start_time).toISOString().split('T')[0],
      meeting_type: b.meeting_type
    }));
    context.log("üìä allBookings parsed:", allBookings.map(b => b.start));
    const bookingCount = allBookings.length;
    context.log(`üìä Antal bokningar i intervall: ${bookingCount}`);
    context.log(`üë§ Kund: ${contact?.first_name || ''} ${contact?.last_name || ''}, Typ: ${meeting_type}`);
    for (const booking of allBookings) {
      if (!bookingsByDay[booking.date]) bookingsByDay[booking.date] = [];
      bookingsByDay[booking.date].push({ start: booking.start, end: booking.end });
    }
    // --- Summera bokade minuter per vecka & m√∂testyp ---
    const weeklyMinutesByType = {};
    const weekKey = (date) => {
      const start = new Date(date);
      start.setUTCHours(0, 0, 0, 0);
      start.setUTCDate(start.getUTCDate() - start.getUTCDay());
      return start.toISOString().split('T')[0];
    };
    for (const b of allBookings) {
      const type = b.meeting_type || 'unknown';
      const week = weekKey(b.start);
      weeklyMinutesByType[type] = weeklyMinutesByType[type] || {};
      weeklyMinutesByType[type][week] = (weeklyMinutesByType[type][week] || 0) + (b.end - b.start) / 60000;
    }

    if (!contact_id || !meeting_type || !meeting_length) {
      context.res = {
        status: 400,
        body: { error: 'Missing one or more required fields: contact_id, meeting_type, meeting_length' }
      };
      return;
    }

    // Restidslogik (travelTimeMin) hanteras nu av resolveTravelTime i slotRules/generateSlotChunks

    const windowStartHour = DateTime.fromISO(`${days[0].toISOString().split('T')[0]}T${settings.travel_time_window_start || '06:00'}`, { zone: timezone }).toUTC().hour;
    const windowEndHour = DateTime.fromISO(`${days[0].toISOString().split('T')[0]}T${settings.travel_time_window_end || '23:00'}`, { zone: timezone }).toUTC().hour;

    // H√§mta Apple Maps-token en g√•ng tidigt
    const accessToken = await getAppleMapsAccessToken(context);
    if (!accessToken && isDebug) {
      context.log('‚ö†Ô∏è Apple Maps-token saknas ‚Äì vissa slots kan anv√§nda fallback');
    }
    const t3 = Date.now();
    debugLog('‚è±Ô∏è Efter Apple Maps token: ' + (Date.now() - t0) + ' ms');

    // Parallellisera dag-loop i chunkar om 7
    // --- Ny slot-generation via generateSlotChunks ---
    const { chosenSlots, slotMapResult, slotLogSummary } = await generateSlotChunks({
      days,
      context,
      contact,
      contact_id,
      meeting_type,
      meeting_length,
      bookingsByDay,
      weeklyMinutesByType,
      settings,
      graphClient,
      appleClient,
      travelCache,
      accessToken,
      timezone,
      debugHelper: { debugLog, skipReasons }
    });
    const slotMap = slotMapResult;
    const chosen = chosenSlots;
    const slotCount = chosen.length;

    const elapsedMs = Date.now() - t0;
    context.log(`‚è±Ô∏è Total exekveringstid: ${elapsedMs} ms`);

    debugLog(`‚úÖ getavailableslots klar med ${chosen.length} slots`);
    // --- Summerad loggning av varf√∂r slots har avvisats (om isDebug) ---
    if (isDebug) {
      for (const [reason, count] of Object.entries(getSkipSummary())) {
        context.log(`üìâ ${reason}: ${count} st`);
      }
      context.log(`üìà Totalt tillagda slots: ${slotCount}`);
    }
    if (chosen.length < 2) {
      context.log(`‚ö†Ô∏è Endast ${chosen.length} slot(s) genererade ‚Äì kontrollera regler eller data`);
    }
    if (!chosen.length) {
      context.log(`‚ö†Ô∏è Inga tillg√§ngliga slots kunde genereras ‚Äì returnerar tom lista`);
      context.res = {
        status: 200,
        headers: { 'Access-Control-Allow-Origin': '*' },
        body: { slots: [] }
      };
      return;
    }
    context.res = {
      status: 200,
      headers: {
        'Access-Control-Allow-Origin': '*'
      },
      body: {
        slots: chosen
      }
    };
    const totalDurationMs = Date.now() - startTimeMs;
    context.log(`‚è±Ô∏è getavailableslots f√§rdig ‚Äì total tid: ${totalDurationMs} ms`);
    return;
  } catch (error) {
    debugLog(`üí• Fel uppstod: ${error.message}`);
    context.log('üî• FEL:', error.message);
    context.log(error.stack);
    context.res = {
      status: 500,
      body: { error: error.message, stack: error.stack }
    };
  }
};

const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');

END: index.js

====================
üìÑ Fil: index.js
üìÖ Senast √§ndrad: 2025-05-19 15:57:39
üìè Antal rader: 35
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 4 ‚Äì ["const { DateTime } = require('luxon');", "const pool = require('../shared/db/pgPool');", "const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');", "const settingsLoader = require('../shared/config/settingsLoader');"]
üîç L√§ngsta funktion: 4 rader
üß† Komplexitetspo√§ng: 1
üß™ TODO/FIXME: 0
====================
START: index.js


const { DateTime } = require('luxon');
const pool = require('../shared/db/pgPool');
const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');
const settingsLoader = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const today = new Date();
  const settings = await settingsLoader(pool, context);
  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const date = new Date();
    date.setDate(today.getDate() + i);
    return date;
  });

  context.log(`üîÅ K√∂r refreshCalendarOrigins f√∂r ${days.length} dagar`);

  for (const date of days) {
    const slotTime = DateTime.fromJSDate(date).set({ hour: 10, minute: 0 }).toJSDate();
    const travelStart = new Date(slotTime.getTime() - (settings.fallback_travel_time_minutes || 20) * 60000);

    await resolveOriginAddress({
      eventId: slotTime.toISOString(),
      calendarId: 'system-refresh',
      pool,
      context,
      fallbackOrigin: settings.default_home_address,
      settings
    });
  }

  context.log('‚úÖ refreshCalendarOrigins f√§rdig');
};
END: index.js

====================
üìÑ Fil: index.js
üìÖ Senast √§ndrad: 2025-05-19 15:56:23
üìè Antal rader: 112
üß© Antal funktioner: 4
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 6 ‚Äì ["const { DateTime } = require('luxon');", "const fetch = require('node-fetch');", "const pool = require('../shared/db/pgPool');", "const loadSettings = require('../shared/config/settingsLoader');", "const jwt = require('jsonwebtoken');", "const fs = require('fs');"]
üîç L√§ngsta funktion: 10 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: index.js
const { DateTime } = require('luxon');
const fetch = require('node-fetch');
const pool = require('../shared/db/pgPool');
const loadSettings = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const settings = await loadSettings(pool, context);
  const fallbackTravelTime = settings.fallback_travel_time_minutes || 20;
  const today = new Date();
  const timezone = settings.timezone || 'Europe/Stockholm';

  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const d = new Date(today);
    d.setDate(today.getDate() + i);
    return d;
  });

  const destinations = [settings.default_office_address];
  const origins = [settings.default_home_address];

  for (const day of days) {
    for (const hour of [10, 14]) {
      const slotTime = DateTime.fromJSDate(day).set({ hour, minute: 0 }).toJSDate();

      for (const from of origins) {
        for (const to of destinations) {
          const hourKey = slotTime.getUTCHours();
          const key = `${from}|${to}|${hourKey}`;

          const res = await pool.query(
            `SELECT 1 FROM travel_time_cache
             WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
            [from, to, hourKey]
          );

          if (res.rows.length > 0) {
            context.log(`‚ö° Redan i cache: ${key}`);
            continue;
          }

          context.log(`‚è≥ Ber√§knar restid: ${key}`);
          try {
            const token = await getAppleMapsAccessToken(context);
            if (!token) throw new Error('Apple Maps-token saknas');

            const url = new URL('https://maps-api.apple.com/v1/directions');
            url.searchParams.append('origin', from);
            url.searchParams.append('destination', to);
            url.searchParams.append('transportType', 'automobile');
            url.searchParams.append('departureTime', slotTime.toISOString());

            const response = await fetch(url.toString(), {
              headers: { Authorization: `Bearer ${token}` }
            });
            const data = await response.json();

            const minutes = Math.round((data.routes?.[0]?.durationSeconds || fallbackTravelTime * 60) / 60);
            await pool.query(
              `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
               VALUES ($1, $2, $3, $4)
               ON CONFLICT (from_address, to_address, hour)
               DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes`,
              [from, to, hourKey, minutes]
            );
            context.log(`‚úÖ Sparad restid: ${minutes} min (${key})`);
          } catch (err) {
            context.log(`‚ö†Ô∏è Misslyckades h√§mta/spara restid f√∂r ${key}: ${err.message}`);
          }
        }
      }
    }
  }

  context.log('‚úÖ refreshTravelTimes f√§rdig');
};

async function getAppleMapsAccessToken(context) {
  try {
    const jwt = require('jsonwebtoken');
    const fs = require('fs');

    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n') ||
                       fs.readFileSync(process.env.APPLE_MAPS_KEY_PATH, 'utf8');

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context.log('‚ö†Ô∏è Misslyckades h√§mta Apple Maps token:', err.message);
    return null;
  }
}
END: index.js

====================
üìÑ Fil: appleCalendar.js
üìÖ Senast √§ndrad: 2025-05-19 18:37:54
üìè Antal rader: 71
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ['const fetch = require("node-fetch");', 'const xml2js = require("xml2js");']
üîç L√§ngsta funktion: 14 rader
üß† Komplexitetspo√§ng: 7
üß™ TODO/FIXME: 0
====================
START: appleCalendar.js
const fetch = require("node-fetch");
const xml2js = require("xml2js");

async function getEvent(calendarId, eventId, context) {
  const caldavUrl = process.env.CALDAV_CALENDAR_URL;
  const username = process.env.CALDAV_USER;
  const password = process.env.CALDAV_PASSWORD;

  if (!caldavUrl || !username || !password) {
    context.log("‚ö†Ô∏è Missing CalDAV credentials");
    return null;
  }

  try {
    const res = await fetch(caldavUrl, {
      method: "PROPFIND",
      headers: {
        "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64"),
        "Content-Type": "application/xml",
        "Depth": "1"
      },
      body: `<?xml version="1.0"?>
        <d:propfind xmlns:d="DAV:">
          <d:prop>
            <d:getetag/>
            <d:calendar-data xmlns="urn:ietf:params:xml:ns:caldav"/>
          </d:prop>
        </d:propfind>`
    });

    if (!res.ok) {
      context.log("‚ö†Ô∏è CalDAV fetch failed:", res.statusText);
      return null;
    }

    const xml = await res.text();
    const parsed = await xml2js.parseStringPromise(xml, { explicitArray: false });
    const responses = parsed['d:multistatus']?.['d:response'];
    let calendarData;

    if (Array.isArray(responses)) {
      for (const response of responses) {
        const data = response['d:propstat']?.['d:prop']?.['cal:calendar-data'];
        if (data) {
          calendarData = data;
          break;
        }
      }
    } else {
      calendarData = responses?.['d:propstat']?.['d:prop']?.['cal:calendar-data'];
    }

    if (!calendarData) {
      context.log("‚ö†Ô∏è No calendar-data found in CalDAV response.");
      return null;
    }

    const locationMatch = calendarData.match(/LOCATION:(.*)/);
    const endTimeMatch = calendarData.match(/DTEND(?:;[^:]*)?:(.*)/);

    const location = locationMatch ? locationMatch[1].trim() : null;
    const endTime = endTimeMatch ? endTimeMatch[1].trim() : null;

    return { location, endTime };
  } catch (err) {
    context.log("‚ö†Ô∏è Error parsing CalDAV response:", err.message);
    return null;
  }
}

module.exports = { getEvent };
END: appleCalendar.js

====================
üìÑ Fil: getMsToken.js
üìÖ Senast √§ndrad: 2025-05-19 18:32:38
üìè Antal rader: 31
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 1 ‚Äì ["const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 4 rader
üß† Komplexitetspo√§ng: 2
üß™ TODO/FIXME: 0
====================
START: getMsToken.js


const fetch = require('node-fetch');

module.exports = async function getMsToken(context) {
  try {
    const tokenEndpoint = `https://login.microsoftonline.com/${process.env.MS365_TENANT_ID}/oauth2/v2.0/token`;
    const params = new URLSearchParams();
    params.append('client_id', process.env.MS365_CLIENT_ID);
    params.append('client_secret', process.env.MS365_CLIENT_SECRET);
    params.append('scope', 'https://graph.microsoft.com/.default');
    params.append('grant_type', 'client_credentials');

    const res = await fetch(tokenEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params
    });

    if (!res.ok) {
      context.log(`‚ö†Ô∏è Tokenh√§mtning misslyckades: ${res.statusText}`);
      return null;
    }

    const data = await res.json();
    return data.access_token;
  } catch (err) {
    context.log(`‚ö†Ô∏è Tokenh√§mtning fel: ${err.message}`);
    return null;
  }
};
END: getMsToken.js

====================
üìÑ Fil: msGraph.js
üìÖ Senast √§ndrad: 2025-05-19 18:52:36
üìè Antal rader: 57
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 3 ‚Äì ['const { Client } = require("@microsoft/microsoft-graph-client");', 'require("isomorphic-fetch");', 'const fetch = require("node-fetch");']
üîç L√§ngsta funktion: 3 rader
üß† Komplexitetspo√§ng: 3
üß™ TODO/FIXME: 0
====================
START: msGraph.js
const { Client } = require("@microsoft/microsoft-graph-client");
require("isomorphic-fetch");
const fetch = require("node-fetch");

async function getAccessToken() {
  const tenantId = process.env.MS365_TENANT_ID;
  const clientId = process.env.MS365_CLIENT_ID;
  const clientSecret = process.env.MS365_CLIENT_SECRET;

  const tokenEndpoint = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`;
  const params = new URLSearchParams();
  params.append("client_id", clientId);
  params.append("client_secret", clientSecret);
  params.append("scope", "https://graph.microsoft.com/.default");
  params.append("grant_type", "client_credentials");

  const res = await fetch(tokenEndpoint, {
    method: "POST",
    body: params
  });

  if (!res.ok) {
    console.error(`‚ö†Ô∏è Token fetch failed: ${res.statusText}`);
    throw new Error(`Token fetch failed: ${res.statusText}`);
  }
  const data = await res.json();
  return data.access_token;
}

async function getEvent(calendarId, eventId) {
  try {
    if (!calendarId || !eventId) {
      console.warn("‚ùå getEvent missing calendarId or eventId (Graph)");
      return null;
    }

    const token = await getAccessToken();
    const client = Client.init({
      authProvider: (done) => done(null, token)
    });

    const result = await client
      .api(`/users/${calendarId}/events/${encodeURIComponent(eventId)}`)
      .select("location,end")
      .get();

    const location = result.location?.displayName || null;
    const endTime = result.end?.dateTime || null;

    return { location, endTime };
  } catch (err) {
    console.error("‚ö†Ô∏è getEvent error (Graph):", err.message);
    return null;
  }
}

module.exports = { getEvent };
END: msGraph.js

====================
üìÑ Fil: resolveOrigin.js
üìÖ Senast √§ndrad: 2025-05-19 18:24:41
üìè Antal rader: 129
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 6 rader (4.7%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 20
üß™ TODO/FIXME: 0
====================
START: resolveOrigin.js
const memoryCache = {};

async function resolveOriginAddress({ eventId, calendarId, pool, context, graphClient, appleClient, fallbackOrigin, settings }) {
  const cacheKey = `${calendarId}:${eventId}`;
  const debugLog = (msg) => {
    if (process.env.DEBUG === 'true' && context?.log) context.log(msg);
  };
  debugLog(`üîç resolveOriginAddress ‚Üí calendarId: ${calendarId}, eventId: ${eventId}`);
  const eventDateOnly = eventId.split('T')[0];
  if (memoryCache[cacheKey]) {
    // Provide originEndTime as well
    let originEndTime = null;
    if (memoryCache[cacheKey].originSource === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = memoryCache[cacheKey].originEndTime || null;
    }
    debugLog(`‚úÖ Hittade origin fr√•n cache: ${memoryCache[cacheKey].origin}`);
    return {
      origin: memoryCache[cacheKey].origin,
      originSource: memoryCache[cacheKey].originSource,
      originEndTime
    };
  }


  // Try database cache first
  let dbRes;
  try {
    dbRes = await pool.query(
      'SELECT address, source, end_time FROM calendar_origin_cache WHERE event_date = $1',
      [eventDateOnly]
    );
    debugLog(`üìÇ DB-kontroll: Hittade ${dbRes?.rows?.length || 0} rader f√∂r ${eventDateOnly}`);
  } catch (err) {
    context.log(`‚ö†Ô∏è DB error in resolveOriginAddress: ${err.message}`);
  }
  if (dbRes && dbRes.rows && dbRes.rows.length > 0) {
    let originEndTime = null;
    if (dbRes.rows[0].source === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = dbRes.rows[0].end_time || null;
    }
    memoryCache[cacheKey] = {
      origin: dbRes.rows[0].address,
      originSource: dbRes.rows[0].source,
      originEndTime: originEndTime
    };
    debugLog(`‚úÖ Hittade origin fr√•n DB: ${dbRes.rows[0].address}`);
    return {
      origin: dbRes.rows[0].address,
      originSource: dbRes.rows[0].source,
      originEndTime
    };
  }
  debugLog(`üï≥Ô∏è Inget cachetr√§ff i DB f√∂r ${eventDateOnly}`);

  // Try fetching from MS Graph
  let latestOrigin;
  let originSource = 'unknown';
  if (graphClient && typeof graphClient.getEvent === 'function') {
    try {
      const msEvent = await graphClient.getEvent(calendarId, eventId);
      if (msEvent && msEvent.location) {
        latestOrigin = msEvent.location;
        originSource = 'msgraph';
        debugLog(`‚úÖ Hittade origin fr√•n MS Graph: ${latestOrigin}`);
      }
    } catch (err) {
      context.log(`‚ö†Ô∏è MS Graph error in resolveOriginAddress: ${err.message}`);
    }
  } else if (graphClient) {
    context.log(`‚ö†Ô∏è graphClient saknar getEvent-metod eller √§r null`);
  }

  // Try fetching from Apple calendar if not found
  if (!latestOrigin && appleClient && typeof appleClient.getEvent === 'function') {
    try {
      const appleEvent = await appleClient.getEvent(calendarId, eventId);
      if (appleEvent && appleEvent.location) {
        latestOrigin = appleEvent.location;
        originSource = 'apple';
        debugLog(`‚úÖ Hittade origin fr√•n Apple: ${latestOrigin}`);
      }
    } catch (err) {
      context.log(`‚ö†Ô∏è Apple error in resolveOriginAddress: ${err.message}`);
    }
  } else if (!latestOrigin && appleClient) {
    context.log(`‚ö†Ô∏è appleClient saknar getEvent-metod eller √§r null`);
  }

  // Fallback if not found
  if (!latestOrigin) {
    debugLog(`üö® Ingen tr√§ff i varken cache, DB, Graph eller Apple ‚Äì anv√§nder fallback`);
    latestOrigin = fallbackOrigin || '';
    originSource = 'fallback';
    debugLog(`‚ö†Ô∏è Fallback anv√§nds som origin: ${latestOrigin}`);
  }

  // Write to DB cache unless fallback
  let originEndTime = null;
  if (originSource === 'fallback') {
    originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
  }
  if (originSource !== 'fallback') {
    try {
      await pool.query(
        `INSERT INTO calendar_origin_cache (event_date, source, address, end_time)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT DO NOTHING`,
        [eventDateOnly, originSource, latestOrigin, originEndTime]
      );
    } catch (err) {
      context.log(`‚ö†Ô∏è DB write error in resolveOriginAddress: ${err.message}`);
    }
  }

  memoryCache[cacheKey] = {
    origin: latestOrigin,
    originSource,
    originEndTime
  };
  debugLog(`üß† resolveOriginAddress resultat: ${latestOrigin} (k√§lla: ${originSource})`);
  context.log(`üì§ resolveOriginAddress return: ${latestOrigin} (k√§lla: ${originSource}, endTime: ${originEndTime?.toISOString?.() || 'null'})`);
  return { origin: latestOrigin, originSource, originEndTime };
}

module.exports = { resolveOriginAddress };
END: resolveOrigin.js

====================
üìÑ Fil: settingsLoader.js
üìÖ Senast √§ndrad: 2025-05-19 17:13:05
üìè Antal rader: 39
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 4 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: settingsLoader.js
module.exports = async function loadSettings(pool, context) {
  try {
    const settings = {};
    const isDebug = process.env.DEBUG === 'true';
    const debugLog = (msg) => {
      if (isDebug && context && context.log) {
        context.log(msg);
      }
    };
    debugLog('‚öôÔ∏è B√∂rjar l√§sa booking_settings...');
    const settingsRes = await pool.query('SELECT key, value, value_type FROM booking_settings');
    debugLog(`üì¶ ${settingsRes.rows.length} inst√§llningar h√§mtade`);
    for (const row of settingsRes.rows) {
      debugLog(`üîë ${row.key} = ${row.value} (${row.value_type})`);
      if (
        row.value_type === 'json' ||
        row.value_type === 'array' ||
        (typeof row.value_type === 'string' && /\[\]$/.test(row.value_type))
      ) {
        try {
          settings[row.key] = JSON.parse(typeof row.value === 'string' ? row.value : JSON.stringify(row.value));
        } catch (_) {}
      } else if (row.value_type === 'int') {
        settings[row.key] = parseInt(row.value);
      } else if (row.value_type === 'bool') {
        settings[row.key] = row.value === 'true' || row.value === true;
      } else if (row.value_type === 'string') {
        settings[row.key] = String(row.value).replace(/^"(.*)"$/, '$1');
      } else {
        settings[row.key] = row.value;
      }
    }
    debugLog('‚úÖ Alla inst√§llningar tolkade och klara');
    return settings;
  } catch (err) {
    context.log(`‚ö†Ô∏è Fel vid laddning av booking_settings: ${err.message}`);
    throw err;
  }
};
END: settingsLoader.js

====================
üìÑ Fil: verifySettings.js
üìÖ Senast √§ndrad: 2025-05-19 19:18:11
üìè Antal rader: 53
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 24 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: verifySettings.js


function verifyBookingSettings(settings, context) {
  const expected = {
    default_office_address: 'string',
    default_home_address: 'string',
    fallback_travel_time_minutes: 'number',
    buffer_between_meetings: 'number',
    default_meeting_length_atoffice: 'array',
    default_meeting_length_atclient: 'array',
    default_meeting_length_digital: 'array',
    meeting_types: 'array',
    block_weekends: 'boolean',
    open_time: 'string',
    close_time: 'string',
    lunch_start: 'string',
    lunch_end: 'string',
    travel_time_window_start: 'string',
    travel_time_window_end: 'string',
    require_approval: 'boolean',
    max_days_in_advance: 'number',
    max_weekly_booking_minutes: 'number',
    cache_ttl_minutes: 'number',
    allowed_atclient_meeting_days: 'array',
    timezone: 'string'
  };

  const issues = [];
  for (const [key, type] of Object.entries(expected)) {
    const val = settings[key];
    if (val === undefined || val === null || (key === 'timezone' && String(val).trim() === '')) {
      issues.push(`‚ùå Saknar inst√§llning: ${key}`);
    } else if (key === 'allowed_atclient_meeting_days') {
      if (!Array.isArray(val) || !val.every(v => typeof v === 'string')) {
        issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: ska vara array av str√§ngar`);
      }
    } else if (key === 'require_approval') {
      if (typeof val !== 'boolean') {
        issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: ska vara boolean`);
      }
    } else if (type === 'array' ? !Array.isArray(val) : typeof val !== type) {
      issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: har ${typeof val}, f√∂rv√§ntade ${type}`);
    }
  }

  if (issues.length > 0) {
    const message = 'üõë Problem med booking_settings:\n' + issues.join('\n');
    context.log.warn(message);
    throw new Error(message);
  }
}

module.exports = verifyBookingSettings;
END: verifySettings.js

====================
üìÑ Fil: pgPool.js
üìÖ Senast √§ndrad: 2025-05-19 13:26:26
üìè Antal rader: 12
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 1 ‚Äì ["const { Pool } = require('pg');"]
üîç L√§ngsta funktion: 7 rader
üß† Komplexitetspo√§ng: 0
üß™ TODO/FIXME: 0
====================
START: pgPool.js
const { Pool } = require('pg');

const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: { rejectUnauthorized: false }
});

module.exports = pool;
END: pgPool.js

====================
üìÑ Fil: appleMaps.js
üìÖ Senast √§ndrad: 2025-05-19 19:20:14
üìè Antal rader: 120
üß© Antal funktioner: 5
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 3 ‚Äì ["const jwt = require('jsonwebtoken');", "const fs = require('fs');", "const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 10 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: appleMaps.js


const jwt = require('jsonwebtoken');
const fs = require('fs');
const fetch = require('node-fetch');

async function getAppleMapsAccessToken(context) {
  try {
    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n') ||
                       fs.readFileSync(process.env.APPLE_MAPS_KEY_PATH, 'utf8');

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context?.log?.('‚ö†Ô∏è Misslyckades h√§mta Apple Maps token:', err.message);
    if (err.code === 'EAI_AGAIN') {
      context?.log?.('üåê DNS-fel (EAI_AGAIN) ‚Äì kunde inte n√• servern:', err.message);
    }
    return null;
  }
}


async function getTravelTimeInMinutes(origin, destination, departureTime, accessToken, context) {
  try {
    const url = `https://maps-api.apple.com/v1/directions?origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&departureTime=${encodeURIComponent(departureTime)}&transportType=automobile&includeTravelTimeBreakdown=true`;

    const res = await fetch(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });

    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`‚ùå Apple Maps-directions misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const travelTimeSeconds = data.routes?.[0]?.expectedTravelTime;
    return travelTimeSeconds ? Math.ceil(travelTimeSeconds / 60) : null;
  } catch (err) {
    context?.log?.(`‚ùå Fel vid directions-anrop: ${err.message}`);
    return null;
  }
}

async function getTravelTime(origin, destination, departureTime, context) {
  try {
    const token = await getAppleMapsAccessToken(context);
    if (!token) {
      context?.log?.('‚ö†Ô∏è Kunde inte h√§mta Apple Maps-token');
      return null;
    }
    return await getTravelTimeInMinutes(origin, destination, departureTime, token, context);
  } catch (err) {
    context?.log?.(`‚ùå Fel i getTravelTime: ${err.message}`);
    return null;
  }
}

async function safeGetTravelTime(origin, destination, departureTime, accessToken, context) {
  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', origin);
    url.searchParams.append('destination', destination);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', departureTime);

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 8000); // max 8s

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` },
      signal: controller.signal
    });

    clearTimeout(timeout);
    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`‚ùå Apple Maps misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const seconds = data.routes?.[0]?.durationSeconds || data.routes?.[0]?.expectedTravelTime;
    return seconds ? Math.round(seconds / 60) : null;
  } catch (err) {
    context?.log?.(`‚ö†Ô∏è safeGetTravelTime error: ${err.message}`);
    return null;
  }
}

module.exports = {
  getAppleMapsAccessToken,
  getTravelTimeInMinutes,
  getTravelTime,
  safeGetTravelTime
};
END: appleMaps.js

====================
üìÑ Fil: returnTravelVerifier.js
üìÖ Senast √§ndrad: 2025-05-19 19:09:10
üìè Antal rader: 67
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 1 rader (1.5%)
üì• Imports: 1 ‚Äì ["const { URL } = require('url');"]
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 4
üß™ TODO/FIXME: 0
====================
START: returnTravelVerifier.js


const { URL } = require('url');

async function verifyReturnTravelFeasibility({
  previousBooking,
  contact,
  slotTime,
  settings,
  accessToken,
  db,
  context,
  travelCache
}) {
  const from = previousBooking.address || settings.default_office_address;
  const to = `${contact.metadata.address} ${contact.metadata.postal_code} ${contact.metadata.city}`;
  const prevEnd = new Date(previousBooking.end);

  if (from === to) {
    context.log(`üíæ Returrestid √§r 0 min (${from} ‚Üí ${to}) ‚Äì ingen cache beh√∂vs`);
    return { isFeasible: true };
  }

  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', from);
    url.searchParams.append('destination', to);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', prevEnd.toISOString());

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` }
    });

    const data = await res.json();
    const returnMinutes = Math.round((data.routes?.[0]?.durationSeconds || 0) / 60);
    const arrivalTime = new Date(prevEnd.getTime() + returnMinutes * 60000);

    // Cache return time in memory and DB
    const hour = prevEnd.getUTCHours();
    const returnCacheKey = `${from}|${to}|${hour}`;
    travelCache.set(returnCacheKey, returnMinutes);
    if (from && to) {
      await db.query(`
        INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (from_address, to_address, hour)
        DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes
      `, [from, to, hour, returnMinutes]);
      context.log(`üíæ Returrestid sparad: ${returnMinutes} min (${from} ‚Üí ${to} @ ${hour}:00)`);
    } else {
      context.log(`‚ö†Ô∏è Hoppar caching av retur ‚Äì saknar from_address (${from}) eller to_address (${to})`);
    }

    if (arrivalTime > slotTime) {
      context.log(`‚õî Slot ${slotTime.toISOString()} avvisad ‚Äì retur fr√•n tidigare m√∂te hinner inte fram i tid (ankomst ${arrivalTime.toISOString()})`);
      return { isFeasible: false, reason: 'retur hinner inte fram', arrivalTime };
    }

    return { isFeasible: true };
  } catch (err) {
    context.log(`‚ö†Ô∏è Kunde inte verifiera returrestid fr√•n tidigare m√∂te: ${err.message}`);
    return { isFeasible: true }; // fail open
  }
}

module.exports = { verifyReturnTravelFeasibility };
END: returnTravelVerifier.js

====================
üìÑ Fil: travelTimeResolver.js
üìÖ Senast √§ndrad: 2025-05-20 07:58:59
üìè Antal rader: 61
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 6
üß™ TODO/FIXME: 0
====================
START: travelTimeResolver.js


async function resolveTravelTime({ origin, destination, hour, db, accessToken, context }) {
  let travelTimeMin = 20;
  const cacheKey = `${origin}|${destination}|${hour}`;
  let cacheHit = false;

  if (!origin || !destination) {
    context.log(`‚ö†Ô∏è Kan inte ber√§kna restid ‚Äì origin eller destination saknas`);
    return { travelTimeMin, cacheHit: false };
  }

  try {
    const cacheRes = await db.query(
      `SELECT travel_minutes FROM travel_time_cache WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
      [origin, destination, hour]
    );
    if (cacheRes.rows.length > 0) {
      travelTimeMin = cacheRes.rows[0].travel_minutes;
      cacheHit = true;
      context.log(`‚ö° Cache hit (db): ${origin} ‚Üí ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
    }
  } catch (err) {
    context.log(`‚ö†Ô∏è Kunde inte l√§sa fr√•n travel_time_cache: ${err.message}`);
  }

  if (!cacheHit && accessToken) {
    try {
      const url = new URL('https://maps-api.apple.com/v1/directions');
      url.searchParams.append('origin', origin);
      url.searchParams.append('destination', destination);
      url.searchParams.append('transportType', 'automobile');
      url.searchParams.append('departureTime', new Date().toISOString());

      const res = await fetch(url.toString(), {
        headers: { Authorization: `Bearer ${accessToken}` }
      });
      const data = await res.json();
      const travelSeconds = data.routes?.[0]?.durationSeconds;
      if (travelSeconds) {
        travelTimeMin = Math.round(travelSeconds / 60);
        await db.query(
          `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
           VALUES ($1, $2, $3, $4)
           ON CONFLICT (from_address, to_address, hour)
           DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes`,
          [origin, destination, hour, travelTimeMin]
        );
        context.log(`üíæ Sparade Apple Maps-restid i cache: ${origin} ‚Üí ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
      } else {
        context.log(`‚ö†Ô∏è Apple Maps-data saknas ‚Äì anv√§nder fallback`);
      }
    } catch (err) {
      context.log(`‚ö†Ô∏è Fel vid Apple Maps-anrop: ${err.message}`);
    }
  }

  return { travelTimeMin, cacheHit };
}

module.exports = { resolveTravelTime };
END: travelTimeResolver.js

START: finalizeSlots.js
// ‚ö†Ô∏è Filen 'finalizeSlots.js' hittades inte
END: finalizeSlots.js

START: generateSlots.js
// ‚ö†Ô∏è Filen 'generateSlots.js' hittades inte
END: generateSlots.js

START: slotRules.js
// ‚ö†Ô∏è Filen 'slotRules.js' hittades inte
END: slotRules.js

====================
üìÑ Fil: index.js
üìÖ Senast √§ndrad: 2025-05-19 09:53:06
üìè Antal rader: 233
üß© Antal funktioner: 5
üí¨ Kommentarst√§ckning: 6 rader (2.6%)
üì• Imports: 3 ‚Äì ["const { Pool } = require('pg');", "const { v4: uuidv4 } = require('uuid');", "const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 8 rader
üß† Komplexitetspo√§ng: 19
üß™ TODO/FIXME: 0
====================
START: index.js
const { Pool } = require('pg');
const { v4: uuidv4 } = require('uuid');

module.exports = async function (context, req) {
  const requiredFields = ['meeting_type', 'meeting_length', 'slot_iso'];
  const missing = requiredFields.filter(k => !req.body?.[k]);

  if (missing.length > 0) {
    context.res = { status: 400, body: { error: `Missing fields: ${missing.join(', ')}` } };
    return;
  }

  const { email, meeting_type, meeting_length, slot_iso, metadata = {} } = req.body;

  const parsedLength = parseInt(meeting_length, 10);
  if (isNaN(parsedLength) || parsedLength <= 0) {
    context.res = { status: 400, body: { error: "Invalid meeting_length" } };
    return;
  }

  const parsedStart = new Date(slot_iso);
  if (isNaN(parsedStart.getTime())) {
    context.res = { status: 400, body: { error: "Invalid slot_iso datetime" } };
    return;
  }

  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.res = { status: 500, body: { error: `Missing environment variable: ${key}` } };
      return;
    }
  }

  const pool = new Pool({
    user: process.env.PGUSER,
    host: process.env.PGHOST,
    database: process.env.PGDATABASE,
    password: process.env.PGPASSWORD,
    port: parseInt(process.env.PGPORT || '5432', 10),
    ssl: { rejectUnauthorized: false }
  });

  const db = await pool.connect();
  try {
    // L√§s in booking_settings
    const settingsRes = await db.query('SELECT key, value, value_type FROM booking_settings');
    const settings = {};
    for (const row of settingsRes.rows) {
      let val = row.value;
      if (row.value_type === 'int') {
        val = parseInt(val);
      } else if (row.value_type === 'bool') {
        val = val === 'true' || val === true;
      } else if (row.value_type === 'json' || row.value_type === 'array') {
        try {
          val = JSON.parse(typeof val === 'string' ? val : JSON.stringify(val));
        } catch (_) {}
      } else if (typeof val === 'string') {
        val = val.replace(/^"(.*)"$/, '$1'); // trimma citattecken
      }
      settings[row.key] = val;
    }

    const id = uuidv4();
    // Kontrollera om en bokning redan finns
    const existing = await db.query(
      'SELECT id FROM bookings WHERE contact_id = $1 AND start_time = $2',
      [metadata.contact_id || null, parsedStart.toISOString()]
    );
    if (existing.rowCount > 0) {
      context.res = {
        status: 409,
        body: { error: 'Booking already exists for this time.' }
      };
      return;
    }
    const startTime = parsedStart;
    const endTime = new Date(startTime.getTime() + parsedLength * 60000);
    const created_at = new Date();
    const updated_at = created_at;

    // Bygg meeting_link dynamiskt
    let meeting_link = null;
    if (meeting_type.toLowerCase() === 'teams') {
      meeting_link = 'https://teams.microsoft.com/l/meetup-join/...'; // placeholder
    } else if (meeting_type.toLowerCase() === 'zoom') {
      meeting_link = 'https://zoom.us/j/1234567890'; // placeholder
    } else if (meeting_type.toLowerCase() === 'facetime' && metadata.phone) {
      meeting_link = `facetime:${metadata.phone}`;
    }

    const fields = {
      id,
      start_time: startTime.toISOString(),
      end_time: endTime.toISOString(),
      meeting_type,
      metadata: JSON.stringify(metadata),
      created_at,
      updated_at,
      contact_id: metadata.contact_id || null,
      booking_email: email || null
    };

    const query = `
      INSERT INTO bookings (
        id, start_time, end_time, meeting_type,
        metadata, created_at, updated_at,
        contact_id, booking_email
      ) VALUES (
        $1, $2, $3, $4,
        $5, $6, $7,
        $8, $9
      )
    `;

    const values = Object.values(fields);
    await db.query(query, values);
    // Logga pending change f√∂r denna bokning
    await db.query(
      `INSERT INTO pending_changes (id, table_name, record_id, change_type, direction, processed, created_at, booking_id)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        uuidv4(),
        'bookings',
        id,
        'INSERT',
        'cloud_to_local',
        false,
        new Date(),
        id
      ]
    );
    // Simulera att kalendern synkades f√∂r denna demo
    fields.synced_to_calendar = true;
    await db.query(
      'INSERT INTO event_log (event_type, booking_id) VALUES ($1, $2)',
      ['booking_created', id]
    );

    context.res = {
      status: 200,
      body: {
        status: 'booked',
        booking_id: id,
        calendar_invite_sent: false // kan uppdateras om Graph-mail l√§ggs in h√§r
      }
    };
  } catch (err) {
    context.res = {
      status: 500,
      body: { error: err.message }
    };
  } finally {
    db.release();
  }
};

// --- Send confirmation email via Microsoft Graph ---
const fetch = require('node-fetch');

async function sendConfirmationEmail({ to, startTime, endTime, meeting_type, meeting_link, first_name, sender_email }) {
  const token = await getGraphAccessToken();

  const subject = `Din bokning √§r bekr√§ftad ‚Äì ${meeting_type}`;
  const content = `
    <p>Hej ${first_name || ''},</p>
    <p>Din bokning den ${startTime.toLocaleDateString()} kl ${startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} √§r nu bekr√§ftad.</p>
    <p><strong>M√∂testyp:</strong> ${meeting_type}</p>
    <p><strong>L√§nk:</strong> <a href="${meeting_link}">${meeting_link}</a></p>
    <p>Vi ser fram emot att ses!</p>
    <p>V√§nligen,<br/>Daniel</p>
  `;

  const body = {
    message: {
      subject,
      body: {
        contentType: 'HTML',
        content
      },
      toRecipients: [
        {
          emailAddress: {
            address: to
          }
        }
      ]
    },
    saveToSentItems: true
  };

  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 8000); // max 8s

  const response = await fetch(`https://graph.microsoft.com/v1.0/users/${encodeURIComponent(sender_email)}/sendMail`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body),
    signal: controller.signal
  });

  clearTimeout(timeout);

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`E-postmisslyckande: ${err}`);
  }
}

async function getGraphAccessToken() {
  const params = new URLSearchParams();
  params.append('client_id', process.env.GRAPH_CLIENT_ID);
  params.append('client_secret', process.env.GRAPH_CLIENT_SECRET);
  params.append('scope', 'https://graph.microsoft.com/.default');
  params.append('grant_type', 'client_credentials');
  const response = await fetch(`https://login.microsoftonline.com/${process.env.GRAPH_TENANT_ID}/oauth2/v2.0/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: params
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`Misslyckad tokenh√§mtning: ${err}`);
  }

  const data = await response.json();
  return data.access_token;
}
END: index.js

====================
üìÑ Fil: debugLogger.js
üìÖ Senast √§ndrad: 2025-05-20 07:58:57
üìè Antal rader: 23
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 8 rader
üß† Komplexitetspo√§ng: 2
üß™ TODO/FIXME: 0
====================
START: debugLogger.js


function createDebugLogger(context) {
  const isDebug = process.env.DEBUG === 'true';
  const skipReasons = {};

  const debugLog = (msg) => {
    if (msg.startsWith('‚õî') || msg.startsWith('üçΩÔ∏è') || msg.startsWith('üìõ')) {
      const reason = msg.split(' ‚Äì ')[0];
      skipReasons[reason] = (skipReasons[reason] || 0) + 1;
    }
    if (isDebug && context?.log) {
      context.log(msg);
    }
  };

  return {
    debugLog,
    getSkipSummary: () => skipReasons
  };
}

module.exports = { createDebugLogger };
END: debugLogger.js

====================
üìÑ Fil: slotEngine.js
üìÖ Senast √§ndrad: 2025-05-20 08:05:37
üìè Antal rader: 68
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 5 ‚Äì ['const { DateTime } = require("luxon");', 'const { resolveOriginAddress } = require("../calendar/resolveOrigin");', 'const { resolveTravelTime } = require("../maps/travelTimeResolver");', 'const msGraph = require("../calendar/msGraph");', 'const appleCalendar = require("../calendar/appleCalendar");']
üîç L√§ngsta funktion: 9 rader
üß† Komplexitetspo√§ng: 3
üß™ TODO/FIXME: 0
====================
START: slotEngine.js


const { DateTime } = require("luxon");
const { resolveOriginAddress } = require("../calendar/resolveOrigin");
const { resolveTravelTime } = require("../maps/travelTimeResolver");
const msGraph = require("../calendar/msGraph");
const appleCalendar = require("../calendar/appleCalendar");

async function generateSlotCandidates({ day, settings, contact, pool, context }) {
  const timezone = settings.timezone || "Europe/Stockholm";
  const hoursToTry = [10, 14];
  const slots = [];

  for (const hour of hoursToTry) {
    const eventId = `${day}T${hour.toString().padStart(2, "0")}:00:00.000Z`;
    const dateObj = new Date(eventId);
    const weekday = dateObj.toLocaleDateString("en-US", { weekday: "long", timeZone: timezone }).toLowerCase();
    const slot_part = hour < 12 ? "fm" : "em";

    const originInfo = await resolveOriginAddress({
      eventId,
      calendarId: contact.contact_id,
      pool,
      context,
      graphClient: msGraph,
      appleClient: appleCalendar,
      fallbackOrigin: settings.default_home_address,
      settings
    });

    if (!originInfo?.origin) {
      context.log(`‚ö†Ô∏è Kunde inte fastst√§lla origin f√∂r ${eventId}`);
      continue;
    }

    const destination = settings.default_office_address;
    const { travelTimeMin } = await resolveTravelTime({
      origin: originInfo.origin,
      destination,
      hour,
      db: pool,
      accessToken: context.accessToken || null,
      context
    });

    if (!travelTimeMin || typeof travelTimeMin !== "number") {
      context.log.warn(`‚ö†Ô∏è Ogiltig restid, hoppar slot: ${eventId}`);
      continue;
    }

    slots.push({
      slot_iso: eventId,
      slot_local: DateTime.fromJSDate(dateObj).setZone(timezone).toISO(),
      travel_time_min: travelTimeMin,
      origin: originInfo.origin,
      originEndTime: originInfo.originEndTime,
      source: originInfo.originSource,
      require_approval: settings.require_approval,
      meeting_length: settings.default_meeting_length_digital?.[0] || 20,
      weekday,
      slot_part
    });
  }

  return slots;
}

module.exports = { generateSlotCandidates };
END: slotEngine.js

