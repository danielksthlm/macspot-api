üìÇ KODTR√ÑD
==========
‚îú‚îÄ‚îÄ bookings
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ getavailableslots
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ meeting_types
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ refreshCalendarOrigins
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ refreshTravelTimes
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ calendar
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ appleCalendar.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ getMsToken.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ msGraph.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resolveOrigin.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ zoomClient.js
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ settingsLoader.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ verifySettings.js
‚îÇ   ‚îú‚îÄ‚îÄ db
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pgPool.js
‚îÇ   ‚îú‚îÄ‚îÄ maps
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ appleMaps.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resolveTravelTime.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ returnTravelVerifier.js
‚îÇ   ‚îú‚îÄ‚îÄ notification
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sendMail.js
‚îÇ   ‚îú‚îÄ‚îÄ slots
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ slotEngine.js
‚îÇ   ‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ debugLogger.js
‚îú‚îÄ‚îÄ trackingPixel
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ validate_contact
‚îÇ   ‚îú‚îÄ‚îÄ index.js
==========

====================
üìÑ Fil: meeting_types/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-22 19:37:45
üìè Antal rader: 47
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 1 rader (2.1%)
üì• Imports: 2 ‚Äì ["const pool = require('../shared/db/pgPool');", "const { getSettings } = require('../shared/config/settingsLoader');"]
üîç L√§ngsta funktion: 7 rader
üß† Komplexitetspo√§ng: 3
üß™ TODO/FIXME: 0
====================
START: index.js
const pool = require('../shared/db/pgPool');
const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, req) {
  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.log.error(`Missing environment variable: ${key}`);
      context.res = {
        status: 500,
        body: { error: `Missing environment variable: ${key}` }
      };
      return;
    }
  }

  try {
    const settings = await getSettings(context);

    const rawTypes = settings['meeting_types'];
    const meetingTypes = Array.isArray(rawTypes) ? rawTypes.map(t => t.toLowerCase()) : [];
    const lengths = {
      zoom: settings['default_meeting_length_digital'],
      facetime: settings['default_meeting_length_digital'],
      teams: settings['default_meeting_length_digital'],
      atclient: settings['default_meeting_length_atclient'],
      atoffice: settings['default_meeting_length_atoffice']
    };

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        types: meetingTypes,
        lengths
      })
    };
  } catch (error) {
    context.log.error('Database query failed:', error);
    context.res = {
      status: 500,
      body: { error: error.message }
    };
  } finally {
    // pool.end() tas bort ‚Äì vi √•teranv√§nder en delad pool mellan anrop
  }
};
END: index.js

====================
üìÑ Fil: validate_contact/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-24 18:36:04
üìè Antal rader: 182
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 5 rader (2.7%)
üì• Imports: 3 ‚Äì ["const { getSettings } = require('../shared/config/settingsLoader');", "const pool = require('../shared/db/pgPool');", "const { v4: uuidv4 } = require('uuid');"]
üîç L√§ngsta funktion: 1 rader
üß† Komplexitetspo√§ng: 28
üß™ TODO/FIXME: 0
====================
START: index.js
const { getSettings } = require('../shared/config/settingsLoader');
const pool = require('../shared/db/pgPool');
const { v4: uuidv4 } = require('uuid');

module.exports = async function (context, req) {
  try {
    const email = req.body?.email || req.query?.email;
    const meeting_type = req.body?.meeting_type || req.query?.meeting_type;

    if (process.env.DEBUG === 'true') {
      context.log.info('üõ† DEBUG MODE ENABLED');
    }

    if (process.env.DEBUG === 'true') {
      context.log.info('üì• validate_contact triggered with:', { email, meeting_type });
    }

    if (!email || !meeting_type) {
      context.res = { status: 400, body: { error: "email and meeting_type are required" } };
      return;
    }

    const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
    for (const key of requiredEnv) {
      if (!process.env[key]) throw new Error(`Missing environment variable: ${key}`);
    }

    const contactRes = await pool.query('SELECT * FROM contact WHERE booking_email = $1', [email]);
    const contact = contactRes.rows[0];

    if ((req.body?.write_if_valid || req.query?.write_if_valid) && contact) {
      // Update existing contact if needed, merging metadata
      let metadataFromClient = req.body?.metadata;
      if (typeof metadataFromClient === 'string') {
        try {
          metadataFromClient = JSON.parse(metadataFromClient);
        } catch {
          metadataFromClient = {};
        }
      }
      if (typeof metadataFromClient === 'object' && metadataFromClient !== null) {
        // Fetch existing metadata
        const existing = await pool.query('SELECT metadata FROM contact WHERE booking_email = $1', [email]);
        const old = existing.rows[0]?.metadata || {};
        const merged = { ...old, ...metadataFromClient };
        await pool.query(
          `UPDATE contact SET metadata = $1, updated_at = NOW() WHERE booking_email = $2`,
          [merged, email]
        );
        context.log.info('‚úèÔ∏è Befintlig kontakt uppdaterad via validate_contact');
      }
    }

    if ((req.body?.write_if_valid || req.query?.write_if_valid) && !contact) {
      let metadataFromClient = req.body?.metadata;
      if (typeof metadataFromClient === 'string') {
        try {
          metadataFromClient = JSON.parse(metadataFromClient);
        } catch {
          metadataFromClient = {};
        }
      }
      if (typeof metadataFromClient === 'object' && metadataFromClient !== null) {
        const newId = uuidv4();
        await pool.query(
          `INSERT INTO contact (id, email, booking_email, metadata, created_at) VALUES ($1, $2, $2, $3, NOW())`,
          [newId, email, metadataFromClient]
        );
        context.log.info('‚úÖ Ny kontakt skapad via validate_contact');

        if (process.env.DEBUG === 'true') {
          context.log.info('üì§ Svarar med status: created');
        }

        context.res = {
          status: 200,
          body: {
            status: "created",
            contact_id: newId
          }
        };
        return;
      }
    }

    let metadata = {};
    if (contact) {
      const refreshed = await pool.query('SELECT metadata FROM contact WHERE booking_email = $1', [email]);
      metadata = refreshed.rows[0]?.metadata || {};
    }

    if (typeof metadata === 'string') {
      try {
        metadata = JSON.parse(metadata);
      } catch {
        metadata = {};
      }
    }

    if (typeof metadata !== 'object' || metadata === null) metadata = {};

    if (process.env.DEBUG === 'true') {
      context.log.info('üßæ Metadata:', metadata);
    }

    const METADATA_KEYS = ['first_name', 'last_name', 'phone', 'company', 'address', 'postal_code', 'city', 'country'];
    const fullMetadata = Object.fromEntries(
      METADATA_KEYS.map(key => [key, metadata[key] ?? ''])
    );
    metadata = fullMetadata;

    const settings = await getSettings(context);
    const digitalTypes = Array.isArray(settings.meeting_digital) ? settings.meeting_digital : [];
    const isDigital = digitalTypes.map(t => t.toLowerCase()).includes(meeting_type.toLowerCase()) || meeting_type === 'atoffice';

    // Dynamically get required fields from booking_settings
    const allRequired = settings.required_fields || {};
    const requiredFields = Array.isArray(allRequired[meeting_type]) ? allRequired[meeting_type] : [];
    // Ber√§kna alltid missingFields fr√•n metadata som just l√§sts fr√•n databasen
    const missingFields = requiredFields.filter(
      field => !metadata[field] || typeof metadata[field] !== 'string' || metadata[field].trim() === ''
    );

    if (process.env.DEBUG === 'true') {
      context.log.info('üìå Saknade f√§lt:', missingFields);
    }

    if (!contact) {
      if (process.env.DEBUG === 'true') {
        context.log.info('üì§ Svarar med status: new_customer');
      }
      context.res = {
        status: 200,
        body: {
          status: "new_customer",
          missing_fields: missingFields
        }
      };
    } else if (missingFields.length > 0) {
      if (process.env.DEBUG === 'true') {
        context.log.info('üì§ Svarar med status: incomplete');
      }
      context.res = {
        status: 200,
        body: {
          status: "incomplete",
          contact_id: contact.id,
          booking_email: contact.booking_email,
          missing_fields: missingFields,
          metadata
        }
      };
    } else {
      if (process.env.DEBUG === 'true') {
        context.log.info('üì§ Svarar med status: existing_customer');
      }
      context.res = {
        status: 200,
        body: {
          status: "existing_customer",
          contact_id: contact.id,
          booking_email: contact.booking_email,
          metadata
        }
      };
    }

  } catch (error) {
    if (process.env.DEBUG === 'true') {
      context.log.error('‚ùå Error during validate_contact:', {
        message: error.message,
        stack: error.stack
      });
    }
    context.res = {
      status: 500,
      body: { error: error.message, stack: error.stack }
    };
  } finally {
    // Poolen √§r delad och √•teranv√§nds ‚Äì vi st√§nger den inte h√§r
  }
};
END: index.js

====================
üìÑ Fil: getavailableslots/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 15:04:19
üìè Antal rader: 329
üß© Antal funktioner: 10
üí¨ Kommentarst√§ckning: 32 rader (9.7%)
üì• Imports: 9 ‚Äì ['const db = require("../shared/db/pgPool");', "const createMsGraphClient = require('../shared/calendar/msGraph');", "const createAppleClient = require('../shared/calendar/appleCalendar');", "const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');", "const { createDebugLogger } = require('../shared/utils/debugLogger');", "require('../shared/config/verifySettings');", "const { getSettings } = require('../shared/config/settingsLoader');", "const verifyBookingSettings = require('../shared/config/verifySettings');", "generateSlotChunks = require('../shared/slots/slotEngine').generateSlotChunks;"]
üîç L√§ngsta funktion: 19 rader
üß† Komplexitetspo√§ng: 31
üß™ TODO/FIXME: 0
====================
START: index.js
const db = require("../shared/db/pgPool");
const createMsGraphClient = require('../shared/calendar/msGraph');
const createAppleClient = require('../shared/calendar/appleCalendar');
const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');
const { createDebugLogger } = require('../shared/utils/debugLogger');
const isDebug = process.env.DEBUG === 'true';
// console.log("‚úÖ getavailableslots/index.js laddad");
require('../shared/config/verifySettings');

module.exports = async function (context, req) {
  const debugLog = (msg) => { if (isDebug) context.log(msg); };
  const appleClient = createAppleClient(context);
  // üß™ TEST: Logga fetchEventsByDateRange direkt vid start med explicit tidsintervall och robust felhantering
  const testStart = new Date();
  const testEnd = new Date(Date.now() + 7 * 86400000);
  if (!(testStart instanceof Date) || isNaN(testStart)) {
    debugLog("‚õî TEST Apple ‚Äì Ogiltigt testStart:", testStart);
  }
  if (!(testEnd instanceof Date) || isNaN(testEnd)) {
    debugLog("‚õî TEST Apple ‚Äì Ogiltigt testEnd:", testEnd);
  }
  // context.log("üß™ TEST Apple ‚Äì Start:", testStart.toISOString(), "End:", testEnd.toISOString());
  try {
    const testAppleRange = await appleClient.fetchEventsByDateRange(testStart, testEnd);
    // [BEVIS] Loggning f√∂r att visa om Apple CalDAV faktiskt svarar
    if (!testAppleRange || testAppleRange.length === 0) {
      debugLog("‚õî [BEVIS] Apple CalDAV returnerade inga events ‚Äì m√∂jligt problem med API eller filter.");
    } else {
      debugLog(`‚úÖ [BEVIS] Apple CalDAV returnerade ${testAppleRange.length} event(s).`);
      const preview = testAppleRange.slice(0, 3);
      for (const ev of preview) {
        debugLog("üìÜ [BEVIS] Apple Event:", ev);
      }
      // (Apple events till bookingsByDay flyttad till efter deklaration)
    }
    // context.log("üß™ TEST Apple fetchEventsByDateRange returnerade:", testAppleRange.length);
    // for (const ev of testAppleRange) {
    //   context.log("üìÜ Apple Event:", ev);
    // }
    // for (const e of testAppleRange) {
    //   context.log("üßæ Apple Event UID:", e.uid, "Start:", e.start, "End:", e.end, "Summary:", e.summary);
    // }
  } catch (err) {
    debugLog("‚ùå Apple fetchEventsByDateRange FEL:", err.message);
  }
  const graphClient = createMsGraphClient();
  // context.log("üß™ Azure Function entrypoint n√•dd");
  // context.log("üß™ graphClient.getEvent:", typeof graphClient.getEvent === "function");
  // context.log("üß™ appleClient.getEvent:", typeof appleClient.getEvent === "function");

  try {
    const client = await db.connect();

    if (!req || !req.body) {
      context.log("‚ùå Ingen request body mottagen");
      context.res = { status: 400, body: { error: "Missing request body" } };
      return;
    }

    const { email, meeting_type, meeting_length, contact_id } = req.body;
    debugLog("‚úÖ Request body inneh√•ller: " + JSON.stringify({ email, meeting_type }));
    debugLog("‚úÖ Steg 1: Anropar DB med contact_id: " + contact_id);

    // Declare allBookings, days, and contact at the top-level scope of the outer try block
    let allBookings = [];
    let days = [];
    let contact;
    let bookingsByDay = {};
    // --- BEGIN: Apple events till bookingsByDay ---
    if (typeof testAppleRange !== "undefined" && Array.isArray(testAppleRange)) {
      for (const ev of testAppleRange) {
        if (ev.start && ev.end) {
          const dateKey = new Date(ev.start).toISOString().split('T')[0];
          if (!bookingsByDay[dateKey]) bookingsByDay[dateKey] = [];
          bookingsByDay[dateKey].push({
            start: new Date(ev.start).getTime(),
            end: new Date(ev.end).getTime()
          });
        }
      }
      debugLog("üì• Apple events insatta i bookingsByDay:");
      Object.entries(bookingsByDay).forEach(([date, events]) => {
        debugLog(`üìÖ ${date}: ${events.length} event(s)`);
        events.forEach(ev => {
          const start = new Date(ev.start).toISOString();
          const end = new Date(ev.end).toISOString();
          debugLog(`   ‚è∞ ${start} ‚Üí ${end}`);
        });
      });
    }
    // --- END: Apple events till bookingsByDay ---

    try {
      const contactRes = await client.query("SELECT * FROM contact WHERE id = $1", [contact_id]);
      contact = contactRes.rows[0];
      if (contact) {
        debugLog("‚úÖ Kontakt hittad: " + contact.id);
      } else {
        debugLog("‚ö†Ô∏è Ingen kontakt hittad f√∂r contact_id: " + contact_id);
      }
    } catch (err) {
      context.log("üî• DB-fel:", err.message);
      context.res = { status: 500, body: { error: "DB error", detail: err.message } };
      client.release();
      return;
    }

    debugLog("‚úÖ Steg 2: Laddar booking_settings...");

    const { getSettings } = require('../shared/config/settingsLoader');
    const verifyBookingSettings = require('../shared/config/verifySettings');

    let settings;
    try {
      settings = await getSettings(context);
      debugLog("‚úÖ Steg 2a: Inst√§llningar laddade ‚Äì nycklar: " + Object.keys(settings).join(', '));
      verifyBookingSettings(settings, context);
      debugLog("‚úÖ Steg 2b: Inst√§llningar verifierade");

      debugLog("‚úÖ Steg 3: Genererar days[] och laddar bokningar");

      const maxDays = settings.max_days_in_advance || 14;
      const today = new Date();
      days = Array.from({ length: maxDays }, (_, i) => {
        const date = new Date(today);
        date.setDate(today.getDate() + i);
        return date;
      });

      // üîç Validera days[]
      days = days.filter((d, idx) => {
        const isValid = d instanceof Date && !isNaN(d);
        if (!isValid) {
          debugLog(`‚õî Ogiltigt datum i days[${idx}]: ` + d);
        }
        return isValid;
      });

      if (days.length === 0) {
        context.log("‚õî Alla datum i days[] var ogiltiga ‚Äì avbryter exekvering.");
        context.res = { status: 500, body: { error: "Inga giltiga datum kunde genereras" } };
        client.release();
        return;
      }

      const startDateStr = days[0].toISOString().split('T')[0];
      const endDateStr = days[days.length - 1].toISOString().split('T')[0];

      const startDate = days[0];
      const endDate = days[days.length - 1];
      if (!(startDate instanceof Date) || isNaN(startDate)) {
        debugLog("‚õî Ogiltigt startDate skickat till fetchEventsByDateRange: " + startDate);
      }
      if (!(endDate instanceof Date) || isNaN(endDate)) {
        debugLog("‚õî Ogiltigt endDate skickat till fetchEventsByDateRange: " + endDate);
      }

      const allBookingsRes = await client.query(
        'SELECT start_time, end_time, meeting_type FROM bookings WHERE start_time::date >= $1 AND start_time::date <= $2',
        [startDateStr, endDateStr]
      );
      debugLog("üî¢ Antal bokningar h√§mtade: " + allBookingsRes.rows.length);

      allBookings = allBookingsRes.rows.map(b => ({
        start: new Date(b.start_time).getTime(),
        end: new Date(b.end_time).getTime(),
        date: new Date(b.start_time).toISOString().split('T')[0],
        meeting_type: b.meeting_type
      }));

      for (const booking of allBookings) {
        if (!bookingsByDay[booking.date]) bookingsByDay[booking.date] = [];
        bookingsByDay[booking.date].push({ start: booking.start, end: booking.end });
      }

      debugLog("‚úÖ Steg 3: Dagar genererade och bokningar summerade");

    } catch (err) {
      context.log("üî• Fel vid laddning/verifiering av settings:", err.message);
      context.res = { status: 500, body: { error: "Settings error", detail: err.message } };
      client.release();
      return;
    }

    let generateSlotChunks;
    try {
      generateSlotChunks = require('../shared/slots/slotEngine').generateSlotChunks;
      debugLog("‚úÖ generateSlotChunks import ok");
    } catch (importErr) {
      context.log("‚ùå Misslyckades importera generateSlotChunks:", importErr.message);
      context.res = { status: 500, body: { error: "Import error", detail: importErr.message } };
      client.release();
      return;
    }

    const weeklyMinutesByType = {};
    const weekKey = (date) => {
      const start = new Date(date);
      start.setUTCHours(0, 0, 0, 0);
      start.setUTCDate(start.getUTCDate() - start.getUTCDay());
      return start.toISOString().split('T')[0];
    };
    for (const b of allBookings) {
      const type = b.meeting_type || 'unknown';
      const week = weekKey(b.start);
      weeklyMinutesByType[type] = weeklyMinutesByType[type] || {};
      weeklyMinutesByType[type][week] = (weeklyMinutesByType[type][week] || 0) + (b.end - b.start) / 60000;
    }

    const debugHelper = createDebugLogger(context);

    const appleMapsToken = await getAppleMapsAccessToken(context);
    context.accessToken = appleMapsToken;
    if (appleMapsToken) {
      debugLog("‚úÖ Apple Maps token h√§mtad ‚Äì l√§ngd: " + appleMapsToken.length);
    } else {
      debugLog("‚ö†Ô∏è Apple Maps token saknas ‚Äì fallback kommer att anv√§ndas");
    }

    // Riktigt anrop till generateSlotChunks
    const slotGroupPicked = {};
    const startSlotGen = Date.now();
    const chosenSlotsResult = await generateSlotChunks({
      days,
      context,
      contact,
      contact_id,
      meeting_type,
      meeting_length,
      bookingsByDay,
      weeklyMinutesByType,
      settings,
      graphClient,
      appleClient,
      travelCache: new Map(),
      accessToken: appleMapsToken,
      timezone: settings.timezone || 'Europe/Stockholm',
      debugHelper,
      client: client,
      slotGroupPicked,
      logSlotContext: true
    });
    const durationMs = Date.now() - startSlotGen;
    debugLog(`‚è±Ô∏è Slotgenerering klar p√• ${durationMs} ms`);
    debugLog("‚úÖ generateSlotChunks k√∂rdes utan fel");
    debugLog("üîé Efter generateSlotChunks ‚Äì dags att filtrera FM/EM");

    const slots = Array.isArray(chosenSlotsResult?.chosenSlots) ? chosenSlotsResult.chosenSlots : [];
    const fallbackCount = slots.filter(s => s.source === 'fallback').length;
    const appleCount = slots.filter(s => s.source === 'apple').length;

    // Flyttat block f√∂r fm/em loggning precis f√∂re slutlogg:
    const fm = slots.filter(s => s.slot_part === 'fm');
    const em = slots.filter(s => s.slot_part === 'em');

    debugLog("üìã Tillg√§ngliga FM-slots:\n" + fm.map(s => `‚òÄÔ∏è ${s.slot_local} (${s.slot_iso}) ‚Äì score: ${s.score}`).join('\n'));
    debugLog("üìã Tillg√§ngliga EM-slots:\n" + em.map(s => `üåô ${s.slot_local} (${s.slot_iso}) ‚Äì score: ${s.score}`).join('\n'));
    debugHelper.logSlotsSummary(slots);

    // üìã Logga tydlig lista p√• tillg√§ngliga slots (en rad per slot)
    if (isDebug) {
      const uniqueSlotLog = slots.map(s => `${s.slot_local} (${s.weekday}, ${s.slot_part}, score: ${s.score})`).join('\n');
      debugLog("üìã Tillg√§ngliga slots:\n" + uniqueSlotLog);
    }

    debugLog("üéØ Slut p√• exekvering av getavailableslots");
    const finalSlots = Array.isArray(chosenSlotsResult?.chosenSlots) ? chosenSlotsResult.chosenSlots : [];
    const finalApple = finalSlots.filter(s => s.source === 'apple').length;
    const finalFallback = finalSlots.filter(s => s.source === 'fallback').length;
    debugLog(`üéâ Slutlig summering: ${finalSlots.length} slots, ${finalApple} Apple Maps, ${finalFallback} fallback`);
    
    // Moved this debugLog line here, just before sending response:
    debugLog("‚úÖ getavailableslots/index.js ‚Äì HELA FUNKTIONEN K√ñRDES UTAN FEL");
    debugLog("üìã getavailableslots ‚Äì sista logg f√∂re response.");
    context.log("‚úÖ getavailableslots ‚Äì context.res s√§tts nu, detta √§r sista logg.");

    // context.log("üì¶ Slotresultat:", JSON.stringify(chosenSlotsResult?.chosenSlots || [], null, 2));

    // if (chosenSlotsResult?.chosenSlots?.length) {
    //   for (const slot of chosenSlotsResult.chosenSlots) {
    //     const slotHour = new Date(slot.slot_iso).getUTCHours();
    //     context.log(`üìÜ Slot: ${slot.slot_iso}, Part: ${slot.slot_part}, Origin: ${slot.origin}, Source: ${slot.source}`);
    //   }
    // }

    debugLog(`üìä Slot-k√§llor: ${appleCount} med Apple Maps, ${fallbackCount} med fallback`);

    // context.log("üì§ Response skickas med antal slots:", (chosenSlotsResult?.chosenSlots || []).length);
    debugLog("‚è≥ P√• v√§g att returnera response...");
    try {
      context.res = {
        status: 200,
        body: {
          message: "‚úÖ getavailableslots √§r kontaktbar och fungerar i full version",
          received: { email, meeting_type, meeting_length },
          travel_stats: {
            apple_count: appleCount,
            fallback_count: fallbackCount
          },
          slots: Array.isArray(chosenSlotsResult?.chosenSlots)
            ? chosenSlotsResult.chosenSlots.map(slot => ({
                ...slot,
                score: slot.score ?? null
              }))
            : []
        }
      };
      client.release();
      debugLog("‚úÖ Databasanslutning sl√§ppt");
      debugLog("‚úÖ client.release() lyckades");
      debugLog("üèÅ Funktion getavailableslots/index.js avslutad helt utan fel");
      context.log("‚úÖ Azure Function getavailableslots har returnerat response.");
    } catch (err) {
      debugLog("‚ùå Fel vid response/build/release: " + err.message);
      context.res = {
        status: 500,
        body: { error: "Internal error after slot gen", detail: err.message }
      };
      context.log("‚úÖ Azure Function getavailableslots har returnerat response.");
    }


  } catch (err) {
    context.log("üî• FEL i funktion:", err.message);
    context.res = { status: 500, body: { error: err.message } };
  }
  // (Flyttad summering och slutloggar till r√§tt plats)
  context.log("üß™ SLUTPUNKT: N√•dde allra sista raden");
};
END: index.js

====================
üìÑ Fil: refreshCalendarOrigins/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-22 19:34:31
üìè Antal rader: 36
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 4 ‚Äì ["const { DateTime } = require('luxon');", "const pool = require('../shared/db/pgPool');", "const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');", "const { getSettings } = require('../shared/config/settingsLoader');"]
üîç L√§ngsta funktion: 4 rader
üß† Komplexitetspo√§ng: 1
üß™ TODO/FIXME: 0
====================
START: index.js


const { DateTime } = require('luxon');
const pool = require('../shared/db/pgPool');
const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');

const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const today = new Date();
  const settings = await getSettings(context);
  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const date = new Date();
    date.setDate(today.getDate() + i);
    return date;
  });

  context.log(`üîÅ K√∂r refreshCalendarOrigins f√∂r ${days.length} dagar`);

  for (const date of days) {
    const slotTime = DateTime.fromJSDate(date).set({ hour: 10, minute: 0 }).toJSDate();
    const travelStart = new Date(slotTime.getTime() - (settings.fallback_travel_time_minutes || 20) * 60000);

    await resolveOriginAddress({
      eventId: slotTime.toISOString(),
      calendarId: 'system-refresh',
      pool,
      context,
      fallbackOrigin: settings.default_home_address,
      settings
    });
  }

  context.log('‚úÖ refreshCalendarOrigins f√§rdig');
};
END: index.js

====================
üìÑ Fil: refreshTravelTimes/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-22 19:35:16
üìè Antal rader: 112
üß© Antal funktioner: 4
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 6 ‚Äì ["const { DateTime } = require('luxon');", "const fetch = require('node-fetch');", "const pool = require('../shared/db/pgPool');", "const { getSettings } = require('../shared/config/settingsLoader');", "const jwt = require('jsonwebtoken');", "const fs = require('fs');"]
üîç L√§ngsta funktion: 10 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: index.js
const { DateTime } = require('luxon');
const fetch = require('node-fetch');
const pool = require('../shared/db/pgPool');
const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const settings = await getSettings(context);
  const fallbackTravelTime = settings.fallback_travel_time_minutes || 20;
  const today = new Date();
  const timezone = settings.timezone || 'Europe/Stockholm';

  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const d = new Date(today);
    d.setDate(today.getDate() + i);
    return d;
  });

  const destinations = [settings.default_office_address];
  const origins = [settings.default_home_address];

  for (const day of days) {
    for (const hour of [10, 14]) {
      const slotTime = DateTime.fromJSDate(day).set({ hour, minute: 0 }).toJSDate();

      for (const from of origins) {
        for (const to of destinations) {
          const hourKey = slotTime.getUTCHours();
          const key = `${from}|${to}|${hourKey}`;

          const res = await pool.query(
            `SELECT 1 FROM travel_time_cache
             WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
            [from, to, hourKey]
          );

          if (res.rows.length > 0) {
            context.log(`‚ö° Redan i cache: ${key}`);
            continue;
          }

          context.log(`‚è≥ Ber√§knar restid: ${key}`);
          try {
            const token = await getAppleMapsAccessToken(context);
            if (!token) throw new Error('Apple Maps-token saknas');

            const url = new URL('https://maps-api.apple.com/v1/directions');
            url.searchParams.append('origin', from);
            url.searchParams.append('destination', to);
            url.searchParams.append('transportType', 'automobile');
            url.searchParams.append('departureTime', slotTime.toISOString());

            const response = await fetch(url.toString(), {
              headers: { Authorization: `Bearer ${token}` }
            });
            const data = await response.json();

            const minutes = Math.round((data.routes?.[0]?.durationSeconds || fallbackTravelTime * 60) / 60);
            await pool.query(
              `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
               VALUES ($1, $2, $3, $4)
               ON CONFLICT (from_address, to_address, hour)
               DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes`,
              [from, to, hourKey, minutes]
            );
            context.log(`‚úÖ Sparad restid: ${minutes} min (${key})`);
          } catch (err) {
            context.log(`‚ö†Ô∏è Misslyckades h√§mta/spara restid f√∂r ${key}: ${err.message}`);
          }
        }
      }
    }
  }

  context.log('‚úÖ refreshTravelTimes f√§rdig');
};

async function getAppleMapsAccessToken(context) {
  try {
    const jwt = require('jsonwebtoken');
    const fs = require('fs');

    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n') ||
                       fs.readFileSync(process.env.APPLE_MAPS_KEY_PATH, 'utf8');

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context.log('‚ö†Ô∏è Misslyckades h√§mta Apple Maps token:', err.message);
    return null;
  }
}
END: index.js

====================
üìÑ Fil: shared/calendar/appleCalendar.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 15:28:53
üìè Antal rader: 198
üß© Antal funktioner: 8
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 3 ‚Äì ['const fetch = require("node-fetch");', 'const xml2js = require("xml2js");', 'const { DateTime } = require("luxon");']
üîç L√§ngsta funktion: 8 rader
üß† Komplexitetspo√§ng: 27
üß™ TODO/FIXME: 0
====================
START: appleCalendar.js
const fetch = require("node-fetch");
const xml2js = require("xml2js");
const { DateTime } = require("luxon");

function createAppleClient(context) {
  const debugLog = (...args) => { if (process.env.DEBUG === 'true') context.log(...args); };
  const DEBUG = process.env.DEBUG === 'true';

  async function getEvent(calendarId, eventId) {
    const caldavUrl = process.env.CALDAV_CALENDAR_URL;
    const username = process.env.CALDAV_USER;
    const password = process.env.CALDAV_PASSWORD;

    if (!caldavUrl || !username || !password) {
      if (DEBUG) context.log("‚ö†Ô∏è Missing CalDAV credentials");
      return null;
    }

    try {
      const eventUrl = `${caldavUrl.replace(/\/$/, '')}/${eventId}.ics`;
      const icsRes = await fetch(eventUrl, {
        method: "GET",
        headers: {
          "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64")
        }
      });

      if (!icsRes.ok) {
        if (DEBUG) context.log(`‚ö†Ô∏è Misslyckades h√§mta ICS-fil: ${eventUrl}`);
        return null;
      }

      const icsText = await icsRes.text();
      const locationMatch = icsText.match(/LOCATION:(.*)/);
      const endTimeMatch = icsText.match(/DTEND(?:;[^:]*)?:(.*)/);

      const location = locationMatch ? locationMatch[1].trim() : null;
      const endTime = endTimeMatch ? endTimeMatch[1].trim() : null;

      if (location && endTime) {
        if (DEBUG) context.log("‚úÖ Hittade event med location och endTime:", { location, endTime });
        return { location, endTime };
      }

      if (DEBUG) context.log("‚ö†Ô∏è Inget event med b√•de location och endTime hittades.");
      return null;

    } catch (err) {
      if (DEBUG) context.log("‚ö†Ô∏è Error i getEvent():", err.message);
      return null;
    }
  }

  async function fetchEventsByDateRange(startDate, endDate) {
    const caldavUrl = process.env.CALDAV_CALENDAR_URL;
    const username = process.env.CALDAV_USER;
    const password = process.env.CALDAV_PASSWORD;


    if (!caldavUrl || !username || !password) {
      if (DEBUG) context.log("‚ö†Ô∏è Missing CalDAV credentials");
      return [];
    }

    const parseDate = (d) => {
      if (d instanceof Date) return DateTime.fromJSDate(d);
      const parsed = new Date(d);
      if (!isNaN(parsed.getTime())) return DateTime.fromJSDate(parsed);
      return DateTime.invalid("Ogiltigt datumformat");
    };
    const startIso = parseDate(startDate).toUTC().toFormat("yyyyLLdd'T'HHmmss'Z'");
    const endIso = parseDate(endDate).toUTC().toFormat("yyyyLLdd'T'HHmmss'Z'");
    const xmlBody = `
    <C:calendar-query xmlns:C="urn:ietf:params:xml:ns:caldav"
                      xmlns:D="DAV:">
      <D:prop>
        <D:getetag/>
        <C:calendar-data/>
      </D:prop>
      <C:filter>
        <C:comp-filter name="VCALENDAR">
          <C:comp-filter name="VEVENT">
            <C:time-range start="${startIso}" end="${endIso}"/>
          </C:comp-filter>
        </C:comp-filter>
      </C:filter>
    </C:calendar-query>`;

    try {
      const res = await fetch(caldavUrl, {
        method: "REPORT",
        headers: {
          "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64"),
          "Depth": "1",
          "Content-Type": "application/xml"
        },
        body: xmlBody
      });

      const xml = await res.text();

      if (!xml || xml.length < 20) {
        if (DEBUG) context.log("‚ö†Ô∏è XML-svar verkar tomt ‚Äì avbryter parsing.");
        return [];
      }

      const parsed = await xml2js.parseStringPromise(xml, {
        explicitArray: false,
        tagNameProcessors: [xml2js.processors.stripPrefix],
        mergeAttrs: true
      });

      const responses = parsed?.['multistatus']?.['response'] || parsed?.['D:multistatus']?.['D:response'];

      if (!responses) {
        if (DEBUG) context.log("‚ö†Ô∏è Inga responses hittades i CalDAV-XML");
        return [];
      }

      const items = Array.isArray(responses) ? responses : [responses];
      const targetPath = new URL(process.env.CALDAV_CALENDAR_URL.trim()).pathname;

      const filteredItems = items; // TEMP: inaktiverat filter f√∂r test

      const results = [];

      for (const item of filteredItems) {
        let calendarData = item?.['propstat']?.['prop']?.['calendar-data'] || item?.['D:propstat']?.['D:prop']?.['C:calendar-data'];

        if (calendarData && typeof calendarData === 'object' && '_' in calendarData) {
          calendarData = calendarData._;
        }

        const href = item['href'] || item['D:href'];
        if (!calendarData || !calendarData.includes('VEVENT')) {
          const fullUrl = `${caldavUrl.replace(/\/$/, '')}${href}`;
          const fallbackRes = await fetch(fullUrl, {
            method: "GET",
            headers: {
              "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64")
            }
          });
          calendarData = await fallbackRes.text();
          if (!calendarData.includes("VEVENT")) {
            continue;
          }
        }

        const vevents = Array.from(calendarData.matchAll(/BEGIN:VEVENT[\S\s]*?END:VEVENT/g));
        for (const vevent of vevents) {
          const v = vevent[0];
          if (DEBUG) context.log("üß™ VEVENT RAW:\n", v);
          const summary = v.match(/SUMMARY:(.*)/)?.[1]?.trim() ?? "‚Äì";
          const dtstart = v.match(/DTSTART(?:;[^:]*)?:(\d{8}(T\d{6})?)/)?.[1]?.trim() ?? "‚Äì";
          const dtend = v.match(/DTEND(?:;[^:]*)?:(\d{8}(T\d{6})?)/)?.[1]?.trim() ?? "‚Äì";
          const location = v.match(/LOCATION:(.*)/)?.[1]?.trim() ?? "‚Äì";
          const uid = v.match(/UID:(.*)/)?.[1]?.trim() ?? "‚Äì";

          const parseToEpoch = (dt) => {
            const clean = dt.replace(/^(\d{8})$/, '$1T000000');
            return DateTime.fromFormat(clean, "yyyyLLdd'T'HHmmss", { zone: "UTC" })
              .setZone("Europe/Stockholm")
              .toMillis();
          };

          const start = parseToEpoch(dtstart);
          const end = parseToEpoch(dtend);

          results.push({ summary, dtstart, dtend, location, uid, start, end });
          if (DEBUG) context.log("‚úÖ Parsed Apple Event:", { summary, dtstart, dtend, location, uid });
        }
      }

      results.sort((a, b) => {
        const aTime = new Date(a.dtstart.replace(/^(\d{8})$/, '$1T000000')).getTime();
        const bTime = new Date(b.dtstart.replace(/^(\d{8})$/, '$1T000000')).getTime();
        return aTime - bTime;
      });


      const now = DateTime.local().setZone("Europe/Stockholm");
      const upcoming = results.filter(ev => {
        const dtRaw = ev.dtstart.replace(/^(\d{8})$/, '$1T000000');
        const dt = DateTime.fromFormat(dtRaw, "yyyyLLdd'T'HHmmss", { zone: "UTC" }).setZone("Europe/Stockholm");
        return dt > now;
      });

      return upcoming;
    } catch (err) {
      if (DEBUG) context.log("‚ùå Fel i fetchEventsByDateRange try/catch:", err.stack || err.message);
      return [];
    }
  }

  return { getEvent, fetchEventsByDateRange };
}

module.exports = (context) => createAppleClient(context || { log: console.log });
END: appleCalendar.js

====================
üìÑ Fil: shared/calendar/getMsToken.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 11:29:41
üìè Antal rader: 57
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 12 rader (21.1%)
üì• Imports: 2 ‚Äì ["require('dotenv').config(); // Ladda milj√∂variabler fr√•n .env", "const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 4 rader
üß† Komplexitetspo√§ng: 5
üß™ TODO/FIXME: 0
====================
START: getMsToken.js
require('dotenv').config(); // Ladda milj√∂variabler fr√•n .env
const fetch = require('node-fetch');

// console.log("üß™ getMsToken.js laddades");

module.exports = async function getMsToken(context = { log: console.log }) {
  // context.log("üß™ getMsToken() anropades ‚Äì initierar tokenh√§mtning");
  // context.log("üîç MS365_CLIENT_ID:", process.env.MS365_CLIENT_ID?.slice(0, 8));
  // context.log("üîç MS365_CLIENT_SECRET:", process.env.MS365_CLIENT_SECRET ? "[satt]" : "[saknas]");
  // context.log("üîç MS365_TENANT_ID:", process.env.MS365_TENANT_ID?.slice(0, 8));
  if (!process.env.MS365_CLIENT_ID || !process.env.MS365_CLIENT_SECRET || !process.env.MS365_TENANT_ID) {
    context.log("‚ùå En eller flera milj√∂variabler f√∂r MS Graph saknas.");
    return null;
  }
  try {
    const tokenEndpoint = `https://login.microsoftonline.com/${process.env.MS365_TENANT_ID}/oauth2/v2.0/token`;
    const params = new URLSearchParams();
    params.append('client_id', process.env.MS365_CLIENT_ID);
    params.append('client_secret', process.env.MS365_CLIENT_SECRET);
    params.append('scope', 'https://graph.microsoft.com/.default');
    params.append('grant_type', 'client_credentials');

    // context.log("üì° F√∂rs√∂ker h√§mta token fr√•n:", tokenEndpoint);

    const res = await fetch(tokenEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params
    });

    // context.log(`üì¨ Response status: ${res.status}`);

    if (!res.ok) {
      const errorText = await res.text();
      context.log(`‚ö†Ô∏è Tokenh√§mtning misslyckades: ${res.status} ${res.statusText}\nSvar: ${errorText}`);
      context.log("ü™µ Fullst√§ndigt svar fr√•n Graph:", errorText);
      return null;
    }

    const data = await res.json();
    return data.access_token;
  } catch (err) {
    context.log(`‚ö†Ô∏è Tokenh√§mtning fel: ${err.message}`);
    return null;
  }
};

if (require.main === module) {
  (async () => {
    const token = await module.exports();
    // if (token) {
    //   console.log("‚úÖ Token h√§mtad:", token.slice(0, 20) + "...");
    // } else {
    //   console.log("‚ùå Kunde inte h√§mta token.");
    // }
  })();
}
END: getMsToken.js

====================
üìÑ Fil: shared/calendar/msGraph.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-06-01 15:25:35
üìè Antal rader: 187
üß© Antal funktioner: 7
üí¨ Kommentarst√§ckning: 1 rader (0.5%)
üì• Imports: 5 ‚Äì ['const { Client } = require("@microsoft/microsoft-graph-client");', 'require("isomorphic-fetch");', 'const fetch = require("node-fetch");', 'const { loadSettings } = require("../config/settingsLoader");', 'const getMsToken = require("./getMsToken");']
üîç L√§ngsta funktion: 6 rader
üß† Komplexitetspo√§ng: 15
üß™ TODO/FIXME: 0
====================
START: msGraph.js
const { Client } = require("@microsoft/microsoft-graph-client");
require("isomorphic-fetch");
const DEBUG = process.env.DEBUG === 'true';
const silentLog = DEBUG ? console.log : () => {};
const fetch = require("node-fetch");
const { loadSettings } = require("../config/settingsLoader");
const getMsToken = require("./getMsToken");

function createMsGraphClient() {

  async function getEvent(calendarId, eventId) {
    try {
      if (!calendarId || !eventId) {
        return null;
      }

      const authToken = await getMsToken({ log: silentLog });
      if (!authToken) {
        throw new Error("üõë Tokenh√§mtning misslyckades ‚Äì accessToken saknas. Funktion avbryts.");
      }
      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      try {
        const result = await client
          .api(`/users/${calendarId}/events/${encodeURIComponent(eventId)}`)
          .select("subject,location,start,end")
          .get();

        const location = result.location?.displayName || null;
        const endTime = result.end?.dateTime || null;

        return { location, endTime };
      } catch (err) {
        if (err.statusCode === 404) {
          return { location: null, endTime: null, deleted: true };
        }
        return null;
      }
    } catch (err) {
      return null;
    }
  }

  async function listUpcomingEvents(daysAhead) {
    try {
      if (!daysAhead) {
        const settings = await loadSettings(null);
        daysAhead = settings.max_days_in_advance || 90;
      }
      const calendarId = process.env.MS365_USER_EMAIL;
      if (!calendarId) throw new Error("‚ùå MS365_USER_EMAIL saknas");

      const authToken = await getMsToken({ log: silentLog });
      if (!authToken) {
        throw new Error("üõë Tokenh√§mtning misslyckades ‚Äì accessToken saknas. Funktion avbryts.");
      }
      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const now = new Date();
      const startDate = now.toISOString();
      const endDate = new Date(now.getTime() + daysAhead * 86400000).toISOString();

      const response = await client
        .api(`/users/${calendarId}/calendarView?startDateTime=${startDate}&endDateTime=${endDate}`)
        .top(100)
        .select("subject,start,end,id")
        .orderby("start/dateTime ASC")
        .get();

      const upcoming = response.value.filter(ev => new Date(ev.start.dateTime) > new Date());
      return upcoming.map(ev => ({
        subject: ev.subject,
        start: ev.start.dateTime,
        end: ev.end?.dateTime || null,
        id: ev.id
      }));
    } catch (err) {
      return [];
    }
  }

  async function createEvent({ start, end, subject, location, attendees }) {
    try {
      const calendarId = process.env.MS365_USER_EMAIL;
      if (!calendarId) throw new Error("‚ùå MS365_USER_EMAIL saknas");

      const authToken = await getMsToken({ log: silentLog });
      if (!authToken) throw new Error("üõë Tokenh√§mtning misslyckades");

      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const event = {
        subject: subject || "M√∂te",
        body: {
          contentType: "HTML",
          content: `Detta √§r en inbjudan till m√∂te: ${subject || "M√∂te"}`
        },
        start: {
          dateTime: start,
          timeZone: "Europe/Stockholm"
        },
        end: {
          dateTime: end,
          timeZone: "Europe/Stockholm"
        },
        location: {
          displayName: location || "Online"
        },
        attendees: (attendees || []).map(email => ({
          emailAddress: { address: email },
          type: "required"
        })),
        allowNewTimeProposals: true,
        isOnlineMeeting: true,
        onlineMeetingProvider: "teamsForBusiness"
      };

      // Uppdaterat Graph-anrop f√∂r att skicka inbjudan direkt till mottagaren
      silentLog("üì§ Event som skickas till Graph:", JSON.stringify({ ...event, sendUpdates: 'all' }, null, 2));
      const created = await client
        .api(`/users/${calendarId}/events`)
        .header('Prefer', 'outlook.timezone="Europe/Stockholm"')
        .post({ ...event, attendees: event.attendees, sendUpdates: 'all' });

      return {
        eventId: created?.id || null,
        onlineMeetingUrl: created?.onlineMeeting?.joinUrl || null,
        subject: created?.subject || null,
        location: created?.location?.displayName || null,
        body: created?.body || null
      };
    } catch (err) {
      silentLog("‚ùå Graph createEvent error (full):", err.stack || err.toString());
      if (err.response) {
        const body = await err.response.text();
        silentLog("üì° Graph response error details:", body);
      }
      return null;
    }
  }

  async function sendEmailInvite({ to, subject, body }) {
    try {
      const senderEmail = process.env.MS365_USER_EMAIL;
      const authToken = await getMsToken({ log: silentLog });
      if (!authToken) throw new Error("‚ùå Kunde inte h√§mta Graph-token");

      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const message = {
        message: {
          subject,
          body: {
            contentType: "HTML",
            content: body
          },
          toRecipients: [
            {
              emailAddress: {
                address: to
              }
            }
          ]
        },
        saveToSentItems: "true"
      };

      await client.api(`/users/${senderEmail}/sendMail`).post(message);
      return { status: "sent" };
    } catch (err) {
      return null;
    }
  }

  return { getEvent, listUpcomingEvents, createEvent, sendEmailInvite };
}

const client = createMsGraphClient();
module.exports = () => client;
END: msGraph.js

====================
üìÑ Fil: shared/calendar/resolveOrigin.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 13:19:22
üìè Antal rader: 236
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 21 rader (8.9%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 38
üß™ TODO/FIXME: 0
====================
START: resolveOrigin.js
/**
 * resolveOriginAddress
 * --------------------
 * H√§mtar origin-adress f√∂r ett kalender-event fr√•n:
 * 1. Memory-cache
 * 2. PostgreSQL-cache (om SKIP_DB inte √§r satt)
 * 3. MS Graph
 * 4. Apple Calendar
 * Fallback anv√§nds vid miss.
 *
 * Milj√∂variabler:
 * - SKIP_DB=true  ‚Üí hoppar √∂ver all databaslogik (l√§s/skriv)
 */
const memoryCache = {};

function cleanAddress(address) {
  return address.replace(/\n/g, ', ').replace(/\\,/g, ',').replace(/\+/g, ' ').trim();
}

async function resolveOriginAddress({ eventId, calendarId, pool, context, graphClient, appleClient, fallbackOrigin, settings, eventCache }) {
  const cacheKey = `${calendarId}:${eventId}`;
  const debugLog = (msg) => {
    if (process.env.DEBUG === 'true' && context?.log) context.log(msg);
  };
  debugLog(`üîç resolveOriginAddress ‚Üí calendarId: ${calendarId}, eventId: ${eventId}`);
  const eventDateOnly = eventId.split('T')[0];

  const useCacheEvents = eventCache?.has(eventDateOnly);
  const cachedEvents = useCacheEvents ? eventCache.get(eventDateOnly) : null;

  if (memoryCache[cacheKey]) {
    // Provide originEndTime as well
    let originEndTime = null;
    if (memoryCache[cacheKey].originSource === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = memoryCache[cacheKey].originEndTime || null;
    }
    debugLog(`‚úÖ Hittade origin fr√•n cache: ${memoryCache[cacheKey].origin}`);
    return {
      origin: cleanAddress(memoryCache[cacheKey].origin),
      originSource: memoryCache[cacheKey].originSource,
      originEndTime
    };
  }


  // Try database cache first
  let dbRes;
  if (!process.env.SKIP_DB) {
    try {
      dbRes = await pool.query(
        'SELECT address, source, end_time FROM calendar_origin_cache WHERE event_date = $1',
        [eventDateOnly]
      );
      debugLog(`üìÇ DB-kontroll: Hittade ${dbRes?.rows?.length || 0} rader f√∂r ${eventDateOnly}`);
    } catch (err) {
      context.log(`‚ö†Ô∏è DB error in resolveOriginAddress: ${err.message}`);
    }
  }
  if (dbRes && dbRes.rows && dbRes.rows.length > 0) {
    // Special case: if source is fallback, return immediately
    if (dbRes.rows[0].source === 'fallback') {
      const originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
      memoryCache[cacheKey] = {
        origin: dbRes.rows[0].address,
        originSource: dbRes.rows[0].source,
        originEndTime
      };
      debugLog(`üõë DB-tr√§ff var fallback ‚Äì hoppar √∂vriga f√∂rs√∂k`);
      return {
        origin: cleanAddress(dbRes.rows[0].address),
        originSource: dbRes.rows[0].source,
        originEndTime
      };
    }
    let originEndTime = null;
    if (dbRes.rows[0].source === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = dbRes.rows[0].end_time || null;
    }
    memoryCache[cacheKey] = {
      origin: dbRes.rows[0].address,
      originSource: dbRes.rows[0].source,
      originEndTime: originEndTime
    };
    debugLog(`‚úÖ Hittade origin fr√•n DB: ${dbRes.rows[0].address}`);
    return {
      origin: cleanAddress(dbRes.rows[0].address),
      originSource: dbRes.rows[0].source,
      originEndTime
    };
  }
  debugLog(`üï≥Ô∏è Inget cachetr√§ff i DB f√∂r ${eventDateOnly}`);

  let latestOrigin;
  let originEndTime = null;
  let originSource = 'unknown';

  if (!latestOrigin && memoryCache[`${calendarId}:${eventDateOnly}`]) {
    const { origin, originSource, originEndTime } = memoryCache[`${calendarId}:${eventDateOnly}`];
    debugLog(`üîÅ √Öteranv√§nder memoryCache f√∂r dag: ${eventDateOnly}`);
    return { origin: cleanAddress(origin), originSource, originEndTime };
  }
  if (graphClient && typeof graphClient.getEvent === 'function') {
    if (!latestOrigin && !memoryCache[`${calendarId}:${eventDateOnly}`]) {
      try {
        const graphCalendarId = settings.ms_sender_email;
        const appleCalendarId = process.env.CALDAV_USER;
        const msEvent = await graphClient.getEvent(graphCalendarId, eventId);
        if (msEvent && msEvent.location) {
          latestOrigin = msEvent.location;
          originSource = 'Microsoft 365';
          debugLog(`‚úÖ Hittade origin fr√•n MS Graph: ${latestOrigin}`);
        }
      } catch (err) {
        context.log(`‚ö†Ô∏è MS Graph error in resolveOriginAddress: ${err.message}`);
      }
    }
  } else if (graphClient) {
    context.log(`‚ö†Ô∏è graphClient saknar getEvent-metod eller √§r null`);
  }

  // Try fetching from Apple calendar if not found
  if (!latestOrigin && appleClient && typeof appleClient.fetchEventsByDateRange === 'function') {
    try {
      const startRange = `${eventDateOnly}T00:00:00Z`;
      const endRange = `${eventDateOnly}T23:59:59Z`;
      const appleCalendarId = process.env.CALDAV_USER;
      const events = cachedEvents || await appleClient.fetchEventsByDateRange(startRange, endRange, appleCalendarId);
      if (!cachedEvents && eventCache) eventCache.set(eventDateOnly, events);
      let mostRecent = null;
      const eventStartTime = new Date(eventId);
      for (const e of events) {
        const dtend = new Date(e.dtend || '');
        if (dtend && dtend <= eventStartTime) {
          if (!mostRecent || dtend > new Date(mostRecent.dtend || 0)) {
            mostRecent = e;
          }
        }
      }

      // Om ingen med location hittades, ta det senaste med dtend
      if (!mostRecent) {
        for (const e of events) {
          const dtend = new Date(e.dtend || '');
          if (dtend && dtend <= eventStartTime) {
            if (!mostRecent || dtend > new Date(mostRecent.dtend || 0)) {
              mostRecent = e;
            }
          }
        }
      }

      if (mostRecent) {
        latestOrigin = mostRecent.location || fallbackOrigin || '';
        originSource = mostRecent.location ? 'Apple Calendar' : 'fallback';
        debugLog(`‚úÖ Hittade origin fr√•n Apple (eller fallback): ${latestOrigin}`);

        if (mostRecent.dtend && typeof mostRecent.dtend === 'string') {
          const dt = mostRecent.dtend.replace(/[^0-9T]/g, '');
          const parsed = new Date(dt.length === 8 ? `${dt}T00:00:00Z` : dt);
          originEndTime = !isNaN(parsed.getTime())
            ? parsed
            : new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
        } else {
          originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
        }
      }
    } catch (err) {
      context.log(`‚ö†Ô∏è Apple error in resolveOriginAddress: ${err.message}`);
    }
  } else if (!latestOrigin && appleClient) {
    context.log(`‚ö†Ô∏è appleClient saknar fetchEventsByDateRange-metod eller √§r null`);
  }

  // Fallback if not found
  if (!latestOrigin) {
    if (originEndTime) {
      debugLog(`‚ö†Ô∏è LOCATION saknas men endTime finns ‚Äì anv√§nder fallback som origin`);
      latestOrigin = fallbackOrigin || '';
      originSource = 'fallback';
    } else {
      debugLog(`üö® Ingen tr√§ff i varken cache, DB, Graph eller Apple ‚Äì anv√§nder fallback`);
      latestOrigin = fallbackOrigin || '';
      originSource = 'fallback';
    }
    debugLog(`‚ö†Ô∏è Fallback anv√§nds som origin: ${latestOrigin}`);
  }

  memoryCache[`${calendarId}:${eventDateOnly}`] = {
    origin: latestOrigin,
    originSource,
    originEndTime
  };

  // Write to DB cache unless fallback
  originEndTime = originEndTime || null;
  if (originSource === 'fallback') {
    originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
  }
  // Ensure originEndTime fallback value before DB insert (unless fallback)
  if (!originEndTime && originSource !== 'fallback') {
    originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
  }
  if (!process.env.SKIP_DB && originSource !== 'fallback') {
    try {
      await pool.query(
        `INSERT INTO calendar_origin_cache (event_date, source, address, end_time)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT DO NOTHING`,
        [eventDateOnly, originSource, latestOrigin, originEndTime]
      );
    } catch (err) {
      context.log(`‚ö†Ô∏è DB write error in resolveOriginAddress: ${err.message}`);
    }
  }

  memoryCache[cacheKey] = {
    origin: latestOrigin,
    originSource,
    originEndTime
  };
  debugLog(`üß† resolveOriginAddress resultat: ${latestOrigin} (k√§lla: ${originSource})`);
  if (process.env.DEBUG === 'true' && context?.log) {
    context.log(`üì§ resolveOriginAddress return: ${latestOrigin} (k√§lla: ${originSource}, endTime: ${originEndTime?.toISOString?.() || 'null'})`);
  }
  return { origin: cleanAddress(latestOrigin), originSource, originEndTime };
}

module.exports = { resolveOriginAddress };

if (process.env.NODE_ENV === 'test') {
  module.exports._test = { memoryCache };
}
END: resolveOrigin.js

====================
üìÑ Fil: shared/config/settingsLoader.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 11:32:26
üìè Antal rader: 63
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 1 ‚Äì ['const pool = require("../db/pgPool");']
üîç L√§ngsta funktion: 8 rader
üß† Komplexitetspo√§ng: 11
üß™ TODO/FIXME: 0
====================
START: settingsLoader.js
const pool = require("../db/pgPool");

async function getSettings(context) {
  try {
    const settings = {};
    const isDebug = process.env.DEBUG === 'true';
    const debugLog = (msg) => {
      if (isDebug && context && context.log) {
        context.log(msg);
      }
    };
    const settingsRes = await pool.query('SELECT key, value, value_type FROM booking_settings');
    for (const row of settingsRes.rows) {
      if (
        row.value_type === 'json' ||
        row.value_type === 'array' ||
        (typeof row.value_type === 'string' && /\[\]$/.test(row.value_type))
      ) {
        try {
          settings[row.key] = JSON.parse(typeof row.value === 'string' ? row.value : JSON.stringify(row.value));
        } catch (_) {}
      } else if (row.value_type === 'int') {
        settings[row.key] = parseInt(row.value);
      } else if (row.value_type === 'bool') {
        settings[row.key] = row.value === 'true' || row.value === true;
      } else if (row.value_type === 'string') {
        settings[row.key] = String(row.value).replace(/^"(.*)"$/, '$1');
      } else {
        settings[row.key] = row.value;
      }
    }
    settings.field_labels = {
      first_name: 'F√∂rnamn',
      last_name: 'Efternamn',
      phone: 'Telefonnummer',
      company: 'F√∂retag',
      address: 'Gatuadress',
      postal_code: 'Postnummer',
      city: 'Stad',
      country: 'Land'
    };
    return settings;
  } catch (err) {
    if (context && context.log) {
      context.log(`‚ö†Ô∏è Fel vid laddning av booking_settings: ${err.message}`);
    } else {
      console.warn(`‚ö†Ô∏è Fel vid laddning av booking_settings: ${err.message}`);
    }
    throw err;
  }
}

function getCloudSecretsOnly() {
  const secrets = {};
  for (const [key, value] of Object.entries(process.env)) {
    if (key.startsWith('MS365_')) {
      secrets[key] = value;
    }
  }
  return secrets;
}

module.exports = { getSettings, getCloudSecretsOnly };
END: settingsLoader.js

====================
üìÑ Fil: shared/config/verifySettings.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 11:33:36
üìè Antal rader: 51
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 24 rader
üß† Komplexitetspo√§ng: 8
üß™ TODO/FIXME: 0
====================
START: verifySettings.js
function verifyBookingSettings(settings, context) {
  const expected = {
    default_office_address: 'string',
    default_home_address: 'string',
    fallback_travel_time_minutes: 'number',
    buffer_between_meetings: 'number',
    default_meeting_length_atoffice: 'array',
    default_meeting_length_atclient: 'array',
    default_meeting_length_digital: 'array',
    meeting_types: 'array',
    block_weekends: 'boolean',
    open_time: 'string',
    close_time: 'string',
    lunch_start: 'string',
    lunch_end: 'string',
    travel_time_window_start: 'string',
    travel_time_window_end: 'string',
    require_approval: 'boolean',
    max_days_in_advance: 'number',
    max_weekly_booking_minutes: 'number',
    cache_ttl_minutes: 'number',
    allowed_atclient_meeting_days: 'array',
    timezone: 'string'
  };

  const issues = [];
  for (const [key, type] of Object.entries(expected)) {
    const val = settings[key];
    if (val === undefined || val === null || (key === 'timezone' && String(val).trim() === '')) {
      issues.push(`‚ùå Saknar inst√§llning: ${key}`);
    } else if (key === 'allowed_atclient_meeting_days') {
      if (!Array.isArray(val) || !val.every(v => typeof v === 'string')) {
        issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: ska vara array av str√§ngar`);
      }
    } else if (key === 'require_approval') {
      if (typeof val !== 'boolean') {
        issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: ska vara boolean`);
      }
    } else if (type === 'array' ? !Array.isArray(val) : typeof val !== type) {
      issues.push(`‚ö†Ô∏è Typfel f√∂r ${key}: har ${typeof val}, f√∂rv√§ntade ${type}`);
    }
  }

  if (issues.length > 0) {
    const message = 'üõë Problem med booking_settings:\n' + issues.join('\n');
    context.log.warn(message);
    throw new Error(message);
  }
}

module.exports = verifyBookingSettings;
END: verifySettings.js

====================
üìÑ Fil: shared/db/pgPool.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 13:01:56
üìè Antal rader: 17
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ["const { Pool } = require('pg');", "require('dotenv').config();"]
üîç L√§ngsta funktion: 7 rader
üß† Komplexitetspo√§ng: 0
üß™ TODO/FIXME: 0
====================
START: pgPool.js
const { Pool } = require('pg');
require('dotenv').config();

const useSSL = process.env.PG_USE_SSL === 'true';
const sslConfig = useSSL ? { rejectUnauthorized: false } : false;


const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: sslConfig
});

module.exports = pool;
END: pgPool.js

====================
üìÑ Fil: shared/maps/appleMaps.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 11:30:29
üìè Antal rader: 120
üß© Antal funktioner: 5
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 2 ‚Äì ["const jwt = require('jsonwebtoken');", "const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 10 rader
üß† Komplexitetspo√§ng: 9
üß™ TODO/FIXME: 0
====================
START: appleMaps.js
const jwt = require('jsonwebtoken');
const fetch = require('node-fetch');

async function getAppleMapsAccessToken(context) {
  try {
    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n');

    if (!privateKey) {
      throw new Error('Apple Maps private key saknas ‚Äì kontrollera APPLE_MAPS_PRIVATE_KEY');
    }

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context?.log?.('‚ö†Ô∏è Misslyckades h√§mta Apple Maps token:', err.message);
    if (err.code === 'EAI_AGAIN') {
      context?.log?.('üåê DNS-fel (EAI_AGAIN) ‚Äì kunde inte n√• servern:', err.message);
    }
    return null;
  }
}


async function getTravelTimeInMinutes(origin, destination, departureTime, accessToken, context) {
  try {
    const url = `https://maps-api.apple.com/v1/directions?origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&departureTime=${encodeURIComponent(departureTime)}&transportType=automobile&includeTravelTimeBreakdown=true`;

    const res = await fetch(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });

    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`‚ùå Apple Maps-directions misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const travelTimeSeconds = data.routes?.[0]?.expectedTravelTime;
    return travelTimeSeconds ? Math.ceil(travelTimeSeconds / 60) : null;
  } catch (err) {
    context?.log?.(`‚ùå Fel vid directions-anrop: ${err.message}`);
    return null;
  }
}

async function getTravelTime(origin, destination, departureTime, context) {
  try {
    const token = await getAppleMapsAccessToken(context);
    if (!token) {
      context?.log?.('‚ö†Ô∏è Kunde inte h√§mta Apple Maps-token');
      return null;
    }
    return await getTravelTimeInMinutes(origin, destination, departureTime, token, context);
  } catch (err) {
    context?.log?.(`‚ùå Fel i getTravelTime: ${err.message}`);
    return null;
  }
}

async function safeGetTravelTime(origin, destination, departureTime, accessToken, context) {
  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', origin);
    url.searchParams.append('destination', destination);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', departureTime);

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 8000); // max 8s

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` },
      signal: controller.signal
    });

    clearTimeout(timeout);
    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`‚ùå Apple Maps misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const seconds = data.routes?.[0]?.durationSeconds || data.routes?.[0]?.expectedTravelTime;
    return seconds ? Math.round(seconds / 60) : null;
  } catch (err) {
    context?.log?.(`‚ö†Ô∏è safeGetTravelTime error: ${err.message}`);
    return null;
  }
}

module.exports = {
  getAppleMapsAccessToken,
  getTravelTimeInMinutes,
  getTravelTime,
  safeGetTravelTime
};
END: appleMaps.js

====================
üìÑ Fil: shared/maps/returnTravelVerifier.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 13:09:44
üìè Antal rader: 66
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 1 rader (1.5%)
üì• Imports: 1 ‚Äì ["const { URL } = require('url');"]
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 9
üß™ TODO/FIXME: 0
====================
START: returnTravelVerifier.js
const DEBUG = process.env.DEBUG === 'true';
const { URL } = require('url');

async function verifyReturnTravelFeasibility({
  previousBooking,
  contact,
  slotTime,
  settings,
  accessToken,
  db,
  context,
  travelCache
}) {
  const from = previousBooking.address || settings.default_office_address;
  const to = `${contact.metadata.address} ${contact.metadata.postal_code} ${contact.metadata.city}`;
  const prevEnd = new Date(previousBooking.end);

  if (from === to) {
    if (DEBUG) context.log(`üíæ Returrestid √§r 0 min (${from} ‚Üí ${to}) ‚Äì ingen cache beh√∂vs`);
    return { isFeasible: true };
  }

  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', from);
    url.searchParams.append('destination', to);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', prevEnd.toISOString());

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` }
    });

    const data = await res.json();
    const returnMinutes = Math.round((data.routes?.[0]?.durationSeconds || 0) / 60);
    const arrivalTime = new Date(prevEnd.getTime() + returnMinutes * 60000);

    // Cache return time in memory and DB
    const hour = prevEnd.getUTCHours();
    const returnCacheKey = `${from}|${to}|${hour}`;
    travelCache.set(returnCacheKey, returnMinutes);
    if (from && to) {
      await db.query(`
        INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (from_address, to_address, hour)
        DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes
      `, [from, to, hour, returnMinutes]);
      if (DEBUG) context.log(`üíæ Returrestid sparad: ${returnMinutes} min (${from} ‚Üí ${to} @ ${hour}:00)`);
    } else {
      if (DEBUG) context.log(`‚ö†Ô∏è Hoppar caching av retur ‚Äì saknar from_address (${from}) eller to_address (${to})`);
    }

    if (arrivalTime > slotTime) {
      if (DEBUG) context.log(`‚õî Slot ${slotTime.toISOString()} avvisad ‚Äì retur fr√•n tidigare m√∂te hinner inte fram i tid (ankomst ${arrivalTime.toISOString()})`);
      return { isFeasible: false, reason: 'retur hinner inte fram', arrivalTime };
    }

    return { isFeasible: true };
  } catch (err) {
    if (DEBUG) context.log(`‚ö†Ô∏è Kunde inte verifiera returrestid fr√•n tidigare m√∂te: ${err.message}`);
    return { isFeasible: true }; // fail open
  }
}

module.exports = { verifyReturnTravelFeasibility };
END: returnTravelVerifier.js

====================
üìÑ Fil: shared/maps/resolveTravelTime.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 13:10:31
üìè Antal rader: 78
üß© Antal funktioner: 1
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 2 rader
üß† Komplexitetspo√§ng: 16
üß™ TODO/FIXME: 0
====================
START: resolveTravelTime.js
const DEBUG = process.env.DEBUG === 'true';

async function resolveTravelTime({ origin, destination, hour, db, accessToken, context }) {
  let travelTimeMin = 20;
  const cacheKey = `${origin}|${destination}|${hour}`;
  let cacheHit = false;
  let isFallback = false;

  if (!origin || !destination) {
    if (DEBUG) context.log(`‚ö†Ô∏è Kan inte ber√§kna restid ‚Äì origin eller destination saknas`);
    return { travelTimeMin, cacheHit: false, isFallback };
  }

  if (!db || typeof db.query !== 'function') {
    if (DEBUG) context.log(`‚ùå db saknas eller saknar query-metod i resolveTravelTime`);
    return { travelTimeMin, cacheHit: false, isFallback: true };
  }

  try {
    const cacheRes = await db.query(
      `SELECT travel_minutes, is_fallback FROM travel_time_cache WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
      [origin, destination, hour]
    );
    if (cacheRes.rows.length > 0) {
      travelTimeMin = cacheRes.rows[0].travel_minutes;
      isFallback = cacheRes.rows[0].is_fallback === true;
      cacheHit = true;
      if (DEBUG) context.log(`‚ö° Cache hit (db): ${origin} ‚Üí ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
    }
  } catch (err) {
    if (DEBUG) context.log(`‚ö†Ô∏è Kunde inte l√§sa fr√•n travel_time_cache: ${err.message}`);
  }

  if (!accessToken) {
    if (DEBUG) context.log(`‚ö†Ô∏è accessToken saknas ‚Äì anv√§nder fallback`);
    return { travelTimeMin, cacheHit: false, isFallback: true };
  }

  if (!cacheHit && accessToken) {
    try {
      const url = new URL('https://maps-api.apple.com/v1/directions');
      url.searchParams.append('origin', origin);
      url.searchParams.append('destination', destination);
      url.searchParams.append('transportType', 'automobile');
      url.searchParams.append('departureTime', new Date().toISOString());

      const res = await fetch(url.toString(), {
        headers: { Authorization: `Bearer ${accessToken}` }
      });
      const data = await res.json();
      const travelSeconds = data.routes?.[0]?.durationSeconds;
      if (travelSeconds) {
        travelTimeMin = Math.round(travelSeconds / 60);
        await db.query(
          `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes, is_fallback)
           VALUES ($1, $2, $3, $4, false)
           ON CONFLICT (from_address, to_address, hour)
           DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes, is_fallback = false`,
          [origin, destination, hour, travelTimeMin]
        );
        if (DEBUG) context.log(`üíæ Sparade Apple Maps-restid i cache: ${origin} ‚Üí ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
      } else {
        if (DEBUG) context.log(`‚ö†Ô∏è Apple Maps-data saknas ‚Äì anv√§nder fallback`);
      }
    } catch (err) {
      if (DEBUG) context.log(`‚ö†Ô∏è Fel vid Apple Maps-anrop: ${err.message}`);
    }
  }

  return {
    travelTimeMin,
    cacheHit,
    isFallback,
    source: isFallback ? 'fallback' : 'apple'
  };
}

module.exports = { resolveTravelTime };
END: resolveTravelTime.js

====================
üìÑ Fil: shared/calendar/zoomClient.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-26 11:07:48
üìè Antal rader: 63
üß© Antal funktioner: 3
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 1 ‚Äì ["const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 13 rader
üß† Komplexitetspo√§ng: 3
üß™ TODO/FIXME: 0
====================
START: zoomClient.js
const fetch = require('node-fetch');

function createZoomClient() {
  const clientId = process.env.ZOOM_CLIENT_ID;
  const clientSecret = process.env.ZOOM_CLIENT_SECRET;
  const accountId = process.env.ZOOM_ACCOUNT_ID;
  const userId = process.env.ZOOM_USER_ID || 'me';

  if (!clientId || !clientSecret || !accountId) {
    throw new Error("Missing Zoom OAuth credentials in environment variables");
  }

  async function getAccessToken() {
    const basicAuth = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
    const res = await fetch(`https://zoom.us/oauth/token?grant_type=account_credentials&account_id=${accountId}`, {
      method: 'POST',
      headers: {
        Authorization: `Basic ${basicAuth}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    });

    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Failed to get Zoom access token: ${text}`);
    }

    const data = await res.json();
    return data.access_token;
  }

  async function createMeeting({ topic, start, duration }) {
    const token = await getAccessToken();

    const res = await fetch(`https://api.zoom.us/v2/users/${userId}/meetings`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        topic,
        type: 2,
        start_time: start,
        duration,
        timezone: 'Europe/Stockholm'
      })
    });

    if (!res.ok) {
      const err = await res.text();
      throw new Error(`Zoom error: ${err}`);
    }

    const result = await res.json();
    console.log(`üìÖ Zoom-m√∂te skapat: ${result.join_url}`);
    return result;
  }

  return { createMeeting };
}

module.exports = createZoomClient;
END: zoomClient.js

====================
üìÑ Fil: shared/notification/sendMail.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-31 08:28:29
üìè Antal rader: 72
üß© Antal funktioner: 2
üí¨ Kommentarst√§ckning: 11 rader (15.3%)
üì• Imports: 1 ‚Äì ["const fetch = require('node-fetch');"]
üîç L√§ngsta funktion: 17 rader
üß† Komplexitetspo√§ng: 3
üß™ TODO/FIXME: 0
====================
START: sendMail.js
const fetch = require('node-fetch');

/**
 * Send mail with HTML body (no newline replacements, allows any HTML).
 * Optionally adds a tracking pixel at the end of the body.
 * @param {Object} param0
 * @param {string} param0.to
 * @param {string} param0.subject
 * @param {string} param0.body - HTML string
 * @param {string|null} [param0.trackingPixelUrl] - Optional tracking pixel image url
 */
async function sendMail({ to, subject, body, trackingPixelUrl = null }) {
  const tenantId = process.env.MS365_TENANT_ID;
  const clientId = process.env.MS365_CLIENT_ID;
  const clientSecret = process.env.MS365_CLIENT_SECRET;
  const sender = process.env.MS365_USER_EMAIL;

  if (!tenantId || !clientId || !clientSecret || !sender) {
    throw new Error("‚ùå Saknar milj√∂variabler f√∂r Microsoft Graph");
  }

  // H√§mta token
  const tokenRes = await fetch(`https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      client_id: clientId,
      scope: 'https://graph.microsoft.com/.default',
      client_secret: clientSecret,
      grant_type: 'client_credentials'
    })
  });

  if (!tokenRes.ok) {
    const error = await tokenRes.text();
    throw new Error(`‚ùå Misslyckades h√§mta token: ${error}`);
  }

  const { access_token } = await tokenRes.json();

  // Prepare HTML body with optional tracking pixel
  const htmlBody =
    trackingPixelUrl
      ? body + `<br><img src="${trackingPixelUrl}" width="1" height="1" style="display:none;">`
      : body;

  const mailRes = await fetch(`https://graph.microsoft.com/v1.0/users/${sender}/sendMail`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${access_token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      message: {
        subject,
        body: {
          contentType: 'HTML',
          content: htmlBody
        },
        toRecipients: [{ emailAddress: { address: to } }]
      },
      saveToSentItems: false
    })
  });

  if (!mailRes.ok) {
    const error = await mailRes.text();
    throw new Error(`‚ùå Misslyckades skicka mail: ${error}`);
  }
}

module.exports = { sendMail };
END: sendMail.js

====================
üìÑ Fil: bookings/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-06-01 14:55:07
üìè Antal rader: 678
üß© Antal funktioner: 6
üí¨ Kommentarst√§ckning: 34 rader (5.0%)
üì• Imports: 7 ‚Äì ["const { getSettings } = require('../shared/config/settingsLoader');", "const pool = require('../shared/db/pgPool');", "const { v4: uuidv4 } = require('uuid');", "const { createDebugLogger } = require('../shared/utils/debugLogger');", "const graphClient = require('../shared/calendar/msGraph')();", "const createZoomClient = require('../shared/calendar/zoomClient');", "const { sendMail } = require('../shared/notification/sendMail');"]
üîç L√§ngsta funktion: 6 rader
üß† Komplexitetspo√§ng: 47
üß™ TODO/FIXME: 0
====================
START: index.js
const { getSettings } = require('../shared/config/settingsLoader');
const pool = require('../shared/db/pgPool');
const { v4: uuidv4 } = require('uuid');
const { createDebugLogger } = require('../shared/utils/debugLogger');
const graphClient = require('../shared/calendar/msGraph')();
const createZoomClient = require('../shared/calendar/zoomClient');
const zoomClient = createZoomClient();
const { sendMail } = require('../shared/notification/sendMail');

module.exports = async function (context, req) {
  context.log('üì• bookings/index.js startar');
  const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
  const userAgent = req.headers['user-agent'] || 'unknown';
  context.log(`üåê IP: ${ipAddress}`);
  context.log(`üß≠ User-Agent: ${userAgent}`);
  const requiredFields = ['meeting_type', 'meeting_length', 'slot_iso'];
  context.log('üîç req.body:', req.body);
  const missing = requiredFields.filter(k => !req.body?.[k]);
  context.log('üîç Saknade f√§lt:', missing);

  if (missing.length > 0) {
    context.log('‚ùå Avbryter pga saknade f√§lt');
    context.res = { status: 400, body: { error: `Missing fields: ${missing.join(', ')}` } };
    return;
  }

  const { email, meeting_type, meeting_length, slot_iso, contact_id, metadata = {} } = req.body;

  let db;
  try {
    db = await pool.connect();

    const contactRes = await db.query('SELECT metadata FROM contact WHERE id = $1', [contact_id]);
    const dbMetadata = (contactRes.rows[0] && contactRes.rows[0].metadata) || {};
    const combinedMetadata = { ...dbMetadata, ...metadata };

    if (!email || typeof email !== 'string' || !email.includes('@')) {
      context.log('‚ùå Ogiltig eller saknad e-postadress:', email);
      context.res = {
        status: 400,
        body: { error: 'Ogiltig eller saknad e-postadress' }
      };
      db.release();
      return;
    }

    const parsedLength = parseInt(meeting_length, 10);
    if (isNaN(parsedLength) || parsedLength <= 0) {
      context.log('‚ùå Ogiltig m√∂tesl√§ngd:', meeting_length);
      context.res = { status: 400, body: { error: "Invalid meeting_length" } };
      db.release();
      return;
    }

    const parsedStart = new Date(slot_iso);
    if (isNaN(parsedStart.getTime())) {
      context.log('‚ùå Ogiltigt slot_iso:', slot_iso);
      context.res = { status: 400, body: { error: "Invalid slot_iso datetime" } };
      db.release();
      return;
    }

    const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
    for (const key of requiredEnv) {
      if (!process.env[key]) {
        context.log('‚ùå Saknar env:', key);
        context.res = { status: 500, body: { error: `Missing environment variable: ${key}` } };
        db.release();
        return;
      }
    }

    const debugHelper = createDebugLogger(context);
    const debugLog = debugHelper.debugLog || ((...args) => context.log('[‚ö†Ô∏è fallback log]', ...args));
    debugLog("üß† debugLogger aktiv ‚Äì DEBUG=" + process.env.DEBUG);
    debugLog("üßæ Metadata efter sammanslagning:", combinedMetadata);
    // L√§s in booking_settings
    const settings = await getSettings(context);

    // Kontrollera att alla required_fields finns i metadata eller req.body
    const requiredFieldsConfig = settings.required_fields || {};
    const baseFields = Array.isArray(requiredFieldsConfig.base) ? requiredFieldsConfig.base : [];
    const specificFields = Array.isArray(requiredFieldsConfig[meeting_type.toLowerCase()])
      ? requiredFieldsConfig[meeting_type.toLowerCase()]
      : [];
    const requiredFieldsFromSettings = [...new Set([...baseFields, ...specificFields])];
    const missingRequired = requiredFieldsFromSettings.filter(field => {
      return !(field in req.body) && !(field in combinedMetadata);
    });

    if (missingRequired.length > 0) {
      context.log('‚ùå Saknade obligatoriska f√§lt enligt settings:', missingRequired);
      context.res = {
        status: 400,
        body: { error: `Saknade obligatoriska f√§lt: ${missingRequired.join(', ')}` }
      };
      db.release();
      return;
    }

    const id = uuidv4();
    // Kontrollera om en bokning redan finns
    const existing = await db.query(
      'SELECT id FROM bookings WHERE contact_id = $1 AND start_time = $2',
      [contact_id || null, parsedStart.toISOString()]
    );
    if (existing.rowCount > 0) {
      context.res = {
        status: 409,
        body: { error: 'Booking already exists for this time.' }
      };
      db.release();
      return;
    }
    const startTime = parsedStart;
    const endTime = new Date(startTime.getTime() + parsedLength * 60000);
    const created_at = new Date();
    const updated_at = created_at;


    combinedMetadata.meeting_length = meeting_length;
    combinedMetadata.ip_address = ipAddress;
    combinedMetadata.user_agent = userAgent;

    const bookingFields = {
      id,
      start_time: startTime.toISOString(),
      end_time: endTime.toISOString(),
      meeting_type,
      metadata: combinedMetadata,
      created_at,
      updated_at,
      contact_id: contact_id || null,
      booking_email: email || null
    };
    debugLog("üì¶ bookingFields inf√∂r DB:", bookingFields);

    let online_link = null;
    if (meeting_type.toLowerCase() === 'teams' && contact_id && email) {
      const subjectTemplates = settings.email_subject_templates || {};
      const subjectTemplate = subjectTemplates[meeting_type.toLowerCase()] || settings.default_meeting_subject || 'M√∂te';
      const emailSubject = subjectTemplate
        .replace('{{first_name}}', combinedMetadata.first_name || '')
        .replace('{{company}}', combinedMetadata.company || 'din organisation');
      const location = combinedMetadata.location || 'Online';
      let eventResult = null;
      try {
        eventResult = await graphClient.createEvent({
          start: startTime.toISOString(),
          end: endTime.toISOString(),
          subject: emailSubject,
          location,
          attendees: [email]
        });
        debugLog("üì® eventResult:", eventResult);
        // Extra loggning enligt instruktion
        if (eventResult) {
          debugLog("üìÑ eventResult.subject:", eventResult.subject);
          debugLog("üìÖ eventResult.start:", eventResult.start);
          debugLog("üìÖ eventResult.end:", eventResult.end);
          debugLog("üìß eventResult.attendees:", eventResult.attendees);
          debugLog("üåê eventResult.webLink:", eventResult.webLink || eventResult.onlineMeetingUrl);
        }
        if (!eventResult) {
          context.log("‚ö†Ô∏è createEvent returnerade null ‚Äì ingen Teams-l√§nk skapades");
        }
        if (eventResult?.onlineMeetingUrl) {
          online_link = eventResult.onlineMeetingUrl;
          combinedMetadata.online_link = online_link;
          combinedMetadata.subject = eventResult.subject || emailSubject || settings.default_meeting_subject || 'M√∂te';
          combinedMetadata.location = eventResult.location || location || 'Online';
        }

        // Extrahera m√∂tesinfo fr√•n bodyPreview oavsett joinUrl
        const body = eventResult?.body?.content || '';
        const idMatch = body.match(/M√∂tes-ID:\s*(\d[\d\s]*)/);
        const pwMatch = body.match(/L√∂senord:\s*([A-Za-z0-9]+)/);

        if (idMatch) combinedMetadata.meeting_id = idMatch[1].trim();
        if (pwMatch) combinedMetadata.passcode = pwMatch[1].trim();
        if (body && !eventResult?.onlineMeetingUrl) {
          combinedMetadata.body_preview = body;
        }

        if (eventResult) {
          // Endast om eventResult finns, markera som synkad
          bookingFields.synced_to_calendar = true;
        }
      } catch (err) {
        // Skicka endast mail om createEvent misslyckades (eventResult === null)
        if (!eventResult) {
          // --- Ny kod f√∂r att skicka Teams-inbjudan via e-post som fallback ---
          const bodyTemplates = settings.email_body_templates || {};
          const rawBody = bodyTemplates[meeting_type.toLowerCase()] || (settings.email_invite_template?.body || '');
          const emailBodyHtml = rawBody
            .replace('{{first_name}}', combinedMetadata.first_name || '')
            .replace('{{company}}', combinedMetadata.company || '')
            .replace('{{start_time}}', startTime.toLocaleString('sv-SE'))
            .replace('{{end_time}}', endTime.toLocaleString('sv-SE'))
            .replace('{{online_link}}', online_link || '')
            .replace('{{phone}}', combinedMetadata.phone || '')
            .replace('{{location}}', combinedMetadata.location || '')
            .replace(/\\n/g, '\n') // tolka "\\n" som newline
            .replace(/\n/g, '<br>');
          const signature = settings.email_signature || '';
          const finalEmailBodyHtml = `<html><body>${emailBodyHtml}<br><br>${signature}</body></html>`;

          await sendMail({
            to: email,
            subject: emailSubject,
            body: finalEmailBodyHtml,
            contentType: 'HTML',
            trackingPixelUrl: `https://klrab.se/track.gif?booking_id=${id}`
          });
          debugLog('‚úÖ Teams-inbjudan skickad via e-post (fallback)');
          // Logga fallback-anv√§ndning till event_log
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_invite_fallback_email', id, { source: 'fallback_email' }]
          );
          // --- Slut p√• ny kod f√∂r Teams-inbjudan fallback ---
        }
      }
    } else if (meeting_type.toLowerCase() === 'zoom') {
      let zoomMeetingCreated = false;
      let icsAttachment = null;
      let result = null;
      try {
        result = await zoomClient.createMeeting({
          topic: combinedMetadata.subject || settings.default_meeting_subject,
          start: startTime.toISOString(),
          duration: parsedLength
        });
        debugLog("üì® Zoom result:", result);
        online_link = result.join_url;
        combinedMetadata.online_link = online_link;
        combinedMetadata.meeting_id = result.id;
        combinedMetadata.subject = result.topic;
        combinedMetadata.location = 'Online';
        bookingFields.synced_to_calendar = true;
        zoomMeetingCreated = true;
      } catch (err) {
        // Fallback: skapa .ics och skicka e-post om Zoom-m√∂tet inte kunde skapas
        const subjectTemplates = settings.email_subject_templates || {};
        const subjectTemplate = subjectTemplates[meeting_type.toLowerCase()] || settings.default_meeting_subject || 'M√∂te';
        const emailSubject = subjectTemplate
          .replace('{{first_name}}', combinedMetadata.first_name || '')
          .replace('{{company}}', combinedMetadata.company || 'din organisation');
        const fallbackLocation = combinedMetadata.location || 'Online';
        const fallbackSubject = combinedMetadata.subject || emailSubject || 'Zoomm√∂te';
        // Skapa .ics-fallback
        const icsBody = `
BEGIN:VCALENDAR
VERSION:2.0
BEGIN:VEVENT
SUMMARY:${fallbackSubject}
DTSTART:${startTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
DTEND:${endTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
LOCATION:${fallbackLocation}
DESCRIPTION:Zoomm√∂te (ingen l√§nk kunde genereras)
END:VEVENT
END:VCALENDAR
`.trim();
        icsAttachment = {
          '@odata.type': '#microsoft.graph.fileAttachment',
          name: 'inbjudan.ics',
          contentType: 'text/calendar',
          contentBytes: Buffer.from(icsBody).toString('base64')
        };
        // Skicka fallback-mail med .ics
        const bodyTemplates = settings.email_body_templates || {};
        const rawBody = bodyTemplates[meeting_type.toLowerCase()] || (settings.email_invite_template?.body || '');
        const emailBodyHtml = rawBody
          .replace('{{first_name}}', combinedMetadata.first_name || '')
          .replace('{{company}}', combinedMetadata.company || '')
          .replace('{{start_time}}', startTime.toLocaleString('sv-SE'))
          .replace('{{end_time}}', endTime.toLocaleString('sv-SE'))
          .replace('{{online_link}}', '')
          .replace('{{phone}}', combinedMetadata.phone || '')
          .replace('{{location}}', fallbackLocation)
          .replace(/\\n/g, '\n')
          .replace(/\n/g, '<br>');
        const signature = settings.email_signature || '';
        const finalEmailBodyHtml = `<html><body>${emailBodyHtml}<br><br>${signature}</body></html>`;
        await sendMail({
          to: email,
          subject: emailSubject,
          body: finalEmailBodyHtml,
          contentType: 'HTML',
          trackingPixelUrl: `https://klrab.se/track.gif?booking_id=${id}`,
          attachments: [icsAttachment]
        });
        await db.query(
          'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
          ['calendar_invite_fallback_ics', id, { source: 'zoom_createMeeting_failed' }]
        );
        debugLog('‚úÖ Zoominbjudan skickad via e-post (fallback .ics)');
      }
      // Skicka INTE mail om Zoom-m√∂tet skapades (zoomMeetingCreated)
    } else if (meeting_type.toLowerCase() === 'facetime') {
      let facetimeEventCreated = false;
      let icsAttachment = null;
      if (combinedMetadata.phone) {
        online_link = `facetime:${combinedMetadata.phone}`;
        combinedMetadata.online_link = online_link;
        const subjectTemplates = settings.email_subject_templates || {};
        const subjectTemplate = subjectTemplates[meeting_type.toLowerCase()] || settings.default_meeting_subject || 'M√∂te';
        const emailSubject = subjectTemplate
          .replace('{{first_name}}', combinedMetadata.first_name || '')
          .replace('{{company}}', combinedMetadata.company || 'din organisation');
        combinedMetadata.subject = combinedMetadata.subject || emailSubject || 'FaceTime';
        combinedMetadata.location = combinedMetadata.location || 'FaceTime';

        // F√∂rs√∂k skapa kalenderinbjudan via Graph
        try {
          const eventResult = await graphClient.createEvent({
            start: startTime.toISOString(),
            end: endTime.toISOString(),
            subject: emailSubject,
            location: 'FaceTime',
            attendees: [email]
          });
          debugLog("üì® eventResult:", eventResult);
          // Extra loggning enligt instruktion
          if (eventResult) {
            debugLog("üìÑ eventResult.subject:", eventResult.subject);
            debugLog("üìÖ eventResult.start:", eventResult.start);
            debugLog("üìÖ eventResult.end:", eventResult.end);
            debugLog("üìß eventResult.attendees:", eventResult.attendees);
            debugLog("üåê eventResult.webLink:", eventResult.webLink || eventResult.onlineMeetingUrl);
          }
          if (eventResult?.location) {
            combinedMetadata.location = eventResult.location;
          }
          if (eventResult?.subject) {
            combinedMetadata.subject = eventResult.subject;
          }
          if (eventResult?.onlineMeetingUrl) {
            combinedMetadata.online_link = eventResult.onlineMeetingUrl;
          }

          if (eventResult?.body?.content) {
            combinedMetadata.body_preview = eventResult.body.content;
          }

          // Nytt: kontrollera eventResult och logga enligt instruktion
          if (eventResult) {
            debugLog('‚úÖ FaceTime-event skapat i kalender via Graph');
            bookingFields.synced_to_calendar = true;
            facetimeEventCreated = true;
          } else {
            debugLog('‚ö†Ô∏è FaceTime-event kunde inte skapas via Graph');
          }
        } catch (err) {
          context.log(`‚ö†Ô∏è FaceTime-kalenderinbjudan via Graph misslyckades: ${err.message}`);
        }

        // Om kalenderinbjudan via Graph misslyckades, skapa .ics som fallback
        if (!facetimeEventCreated) {
          const icsBody = `
BEGIN:VCALENDAR
VERSION:2.0
BEGIN:VEVENT
SUMMARY:${combinedMetadata.subject}
DTSTART:${startTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
DTEND:${endTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
LOCATION:${combinedMetadata.location}
DESCRIPTION:Ring via FaceTime: ${combinedMetadata.phone}
END:VEVENT
END:VCALENDAR
`.trim();

          icsAttachment = {
            '@odata.type': '#microsoft.graph.fileAttachment',
            name: 'inbjudan.ics',
            contentType: 'text/calendar',
            contentBytes: Buffer.from(icsBody).toString('base64')
          };
        }

      // Skicka endast mail om Graph misslyckades (dvs !facetimeEventCreated)
      if (!facetimeEventCreated && icsAttachment) {
        try {
          const bodyTemplates = settings.email_body_templates || {};
          const rawBody = bodyTemplates[meeting_type.toLowerCase()] || (settings.email_invite_template?.body || '');
          const emailBodyHtml = rawBody
            .replace('{{first_name}}', combinedMetadata.first_name || '')
            .replace('{{company}}', combinedMetadata.company || '')
            .replace('{{start_time}}', startTime.toLocaleString('sv-SE'))
            .replace('{{end_time}}', endTime.toLocaleString('sv-SE'))
            .replace('{{online_link}}', combinedMetadata.online_link || online_link || '')
            .replace('{{phone}}', combinedMetadata.phone || '')
            .replace('{{location}}', combinedMetadata.location || '')
            .replace(/\\n/g, '\n') // tolka "\\n" som newline
            .replace(/\n/g, '<br>');
          const signature = settings.email_signature || '';
          const finalEmailBodyHtml = `<html><body>${emailBodyHtml}<br><br>${signature}</body></html>`;
          await sendMail({
            to: email,
            subject: emailSubject,
            body: finalEmailBodyHtml,
            contentType: 'HTML',
            trackingPixelUrl: `https://klrab.se/track.gif?booking_id=${id}`,
            attachments: [icsAttachment]
          });
          // Logga fallback .ics-anv√§ndning till event_log
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_invite_fallback_ics', id, { source: 'fallback_ics' }]
          );
          debugLog('‚úÖ FaceTime-inbjudan skickad via e-post (fallback .ics)');
        } catch (emailErr) {
          context.log("‚ùå Kunde inte skicka FaceTime-inbjudan:", emailErr.message);
        }
      }
      } else {
        context.log("‚ùå FaceTime-bokning saknar telefonnummer ‚Äì kan inte skapa l√§nk eller skicka inbjudan.");
      }
    } else if (meeting_type.toLowerCase() === 'atclient') {
      combinedMetadata.location = combinedMetadata.location || combinedMetadata.address || settings.default_home_address || 'Hos kund';
      const subjectTemplates = settings.email_subject_templates || {};
      const subjectTemplate = subjectTemplates[meeting_type.toLowerCase()] || settings.default_meeting_subject || 'M√∂te';
      const emailSubject = subjectTemplate
        .replace('{{first_name}}', combinedMetadata.first_name || '')
        .replace('{{company}}', combinedMetadata.company || 'din organisation');
      combinedMetadata.subject = combinedMetadata.subject || emailSubject || 'M√∂te hos kund';

      // F√∂rs√∂k skapa kalenderinbjudan via Graph
      let atClientEventCreated = false;
      let icsAttachment = null;
      try {
        const eventResult = await graphClient.createEvent({
          start: startTime.toISOString(),
          end: endTime.toISOString(),
          subject: emailSubject,
          location: combinedMetadata.location,
          attendees: [email]
        });
        debugLog("üì® eventResult:", eventResult);
        // Extra loggning enligt instruktion
        if (eventResult) {
          debugLog("üìÑ eventResult.subject:", eventResult.subject);
          debugLog("üìÖ eventResult.start:", eventResult.start);
          debugLog("üìÖ eventResult.end:", eventResult.end);
          debugLog("üìß eventResult.attendees:", eventResult.attendees);
          debugLog("üåê eventResult.webLink:", eventResult.webLink || eventResult.onlineMeetingUrl);
        }
        bookingFields.synced_to_calendar = true;
        debugLog('‚úÖ atClient-event skapat i kalender via Graph');
        atClientEventCreated = true;
      } catch (err) {
        context.log(`‚ö†Ô∏è atClient-kalenderinbjudan via Graph misslyckades: ${err.message}`);
      }

      // Skapa .ics-fallback om Graph misslyckades
      if (!atClientEventCreated && icsAttachment == null) {
        const icsBody = `
BEGIN:VCALENDAR
VERSION:2.0
BEGIN:VEVENT
SUMMARY:${combinedMetadata.subject}
DTSTART:${startTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
DTEND:${endTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
LOCATION:${combinedMetadata.location}
DESCRIPTION:M√∂te hos kund
END:VEVENT
END:VCALENDAR
`.trim();
        icsAttachment = {
          '@odata.type': '#microsoft.graph.fileAttachment',
          name: 'inbjudan.ics',
          contentType: 'text/calendar',
          contentBytes: Buffer.from(icsBody).toString('base64')
        };
      }

      // Skicka endast mail om Graph misslyckades (dvs !atClientEventCreated)
      if (!atClientEventCreated && icsAttachment) {
        try {
          const bodyTemplates = settings.email_body_templates || {};
          const rawBody = bodyTemplates[meeting_type.toLowerCase()] || (settings.email_invite_template?.body || '');
          const emailBodyHtml = rawBody
            .replace('{{first_name}}', combinedMetadata.first_name || '')
            .replace('{{company}}', combinedMetadata.company || '')
            .replace('{{start_time}}', startTime.toLocaleString('sv-SE'))
            .replace('{{end_time}}', endTime.toLocaleString('sv-SE'))
            .replace('{{online_link}}', online_link || '')
            .replace('{{phone}}', combinedMetadata.phone || '')
            .replace('{{location}}', combinedMetadata.location || '')
            .replace(/\\n/g, '\n') // tolka "\\n" som newline
            .replace(/\n/g, '<br>');
          const signature = settings.email_signature || '';
          const finalEmailBodyHtml = `<html><body>${emailBodyHtml}<br><br>${signature}</body></html>`;
          await sendMail({
            to: email,
            subject: emailSubject,
            body: finalEmailBodyHtml,
            contentType: 'HTML',
            trackingPixelUrl: `https://klrab.se/track.gif?booking_id=${id}`,
            attachments: [icsAttachment]
          });
          // Logga fallback .ics-anv√§ndning till event_log
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_invite_fallback_ics', id, { source: 'fallback_ics' }]
          );
          debugLog('‚úÖ atClient-inbjudan skickad via e-post (fallback .ics)');
        } catch (emailErr) {
        }
      }
    } else if (meeting_type.toLowerCase() === 'atoffice') {
      combinedMetadata.location = combinedMetadata.location || settings.default_office_address || 'Kontoret';
      const subjectTemplates = settings.email_subject_templates || {};
      const subjectTemplate = subjectTemplates[meeting_type.toLowerCase()] || settings.default_meeting_subject || 'M√∂te';
      const emailSubject = subjectTemplate
        .replace('{{first_name}}', combinedMetadata.first_name || '')
        .replace('{{company}}', combinedMetadata.company || 'din organisation');
      combinedMetadata.subject = combinedMetadata.subject || emailSubject || 'M√∂te p√• kontoret';

      // F√∂rs√∂k skapa kalenderinbjudan via Graph
      let atOfficeEventCreated = false;
      let icsAttachment = null;
      try {
        const eventResult = await graphClient.createEvent({
          start: startTime.toISOString(),
          end: endTime.toISOString(),
          subject: emailSubject,
          location: combinedMetadata.location,
          attendees: [email]
        });
        debugLog("üì® eventResult:", eventResult);
        // Extra loggning enligt instruktion
        if (eventResult) {
          debugLog("üìÑ eventResult.subject:", eventResult.subject);
          debugLog("üìÖ eventResult.start:", eventResult.start);
          debugLog("üìÖ eventResult.end:", eventResult.end);
          debugLog("üìß eventResult.attendees:", eventResult.attendees);
          debugLog("üåê eventResult.webLink:", eventResult.webLink || eventResult.onlineMeetingUrl);
        }
        bookingFields.synced_to_calendar = true;
        debugLog('‚úÖ atOffice-event skapat i kalender via Graph');
        atOfficeEventCreated = true;
      } catch (err) {
        context.log(`‚ö†Ô∏è atOffice-kalenderinbjudan via Graph misslyckades: ${err.message}`);
      }

      // Skapa .ics-fallback om Graph misslyckades
      if (!atOfficeEventCreated && icsAttachment == null) {
        const icsBody = `
BEGIN:VCALENDAR
VERSION:2.0
BEGIN:VEVENT
SUMMARY:${combinedMetadata.subject}
DTSTART:${startTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
DTEND:${endTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
LOCATION:${combinedMetadata.location}
DESCRIPTION:M√∂te p√• kontoret
END:VEVENT
END:VCALENDAR
`.trim();
        icsAttachment = {
          '@odata.type': '#microsoft.graph.fileAttachment',
          name: 'inbjudan.ics',
          contentType: 'text/calendar',
          contentBytes: Buffer.from(icsBody).toString('base64')
        };
      }

      // Skicka endast mail om Graph misslyckades (dvs !atOfficeEventCreated)
      if (!atOfficeEventCreated && icsAttachment) {
        try {
          const bodyTemplates = settings.email_body_templates || {};
          const rawBody = bodyTemplates[meeting_type.toLowerCase()] || (settings.email_invite_template?.body || '');
          const emailBodyHtml = rawBody
            .replace('{{first_name}}', combinedMetadata.first_name || '')
            .replace('{{company}}', combinedMetadata.company || '')
            .replace('{{start_time}}', startTime.toLocaleString('sv-SE'))
            .replace('{{end_time}}', endTime.toLocaleString('sv-SE'))
            .replace('{{online_link}}', online_link || '')
            .replace('{{phone}}', combinedMetadata.phone || '')
            .replace('{{location}}', combinedMetadata.location || '')
            .replace(/\\n/g, '\n') // tolka "\\n" som newline
            .replace(/\n/g, '<br>');
          const signature = settings.email_signature || '';
          const finalEmailBodyHtml = `<html><body>${emailBodyHtml}<br><br>${signature}</body></html>`;
          await sendMail({
            to: email,
            subject: emailSubject,
            body: finalEmailBodyHtml,
            contentType: 'HTML',
            trackingPixelUrl: `https://klrab.se/track.gif?booking_id=${id}`,
            attachments: [icsAttachment]
          });
          // Logga fallback .ics-anv√§ndning till event_log
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_invite_fallback_ics', id, { source: 'fallback_ics' }]
          );
          debugLog('‚úÖ atOffice-inbjudan skickad via e-post (fallback .ics)');
        } catch (emailErr) {
        }
      }
    }

    const query = `
      INSERT INTO bookings (
        id, start_time, end_time, meeting_type,
        metadata, created_at, updated_at,
        contact_id, booking_email
      ) VALUES (
        $1, $2, $3, $4,
        $5, $6, $7,
        $8, $9
      )
    `;
    /*
    const values = Object.values(bookingFields);
    */
    const values = [
      bookingFields.id,
      bookingFields.start_time,
      bookingFields.end_time,
      bookingFields.meeting_type,
      bookingFields.metadata,
      bookingFields.created_at,
      bookingFields.updated_at,
      bookingFields.contact_id,
      bookingFields.booking_email
    ];
    await db.query(query, values);
    // Logga pending change f√∂r denna bokning
    await db.query(
      `INSERT INTO pending_changes (id, table_name, record_id, change_type, direction, processed, created_at, booking_id)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        uuidv4(),
        'bookings',
        id,
        'INSERT',
        'cloud_to_local',
        false,
        new Date(),
        id
      ]
    );
    // Simulera att kalendern synkades f√∂r denna demo
    await db.query(
      'INSERT INTO event_log (event_type, booking_id) VALUES ($1, $2)',
      ['booking_created', id]
    );
    debugLog(`‚úÖ Bokning skapad: ${id}, typ: ${meeting_type}, l√§ngd: ${meeting_length}`);

    context.res = {
      status: 200,
      body: {
        status: 'booked',
        booking_id: id,
        calendar_invite_sent: !!online_link
      }
    };
  } catch (err) {
    context.log.error("‚ùå Booking error:", err.message);
    context.log.error("üì¶ Request body:", req.body);
    context.log.error("üåê IP:", ipAddress);
    context.log.error("üß≠ User-Agent:", userAgent);
    context.log.error("‚ùå Fullt felobjekt:", err);
    context.res = {
      status: 500,
      body: {
        error: err.message,
        stack: err.stack,
        full: JSON.stringify(err, Object.getOwnPropertyNames(err))
      }
    };
  } finally {
    if (db) db.release();
  }
};
END: index.js

====================
üìÑ Fil: shared/utils/debugLogger.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 12:50:30
üìè Antal rader: 27
üß© Antal funktioner: 3
üí¨ Kommentarst√§ckning: 0 rader (0.0%)
üì• Imports: 0 ‚Äì Inga
üîç L√§ngsta funktion: 8 rader
üß† Komplexitetspo√§ng: 3
üß™ TODO/FIXME: 0
====================
START: debugLogger.js
function createDebugLogger(context) {
  const isDebug = process.env.DEBUG === 'true';

  const debugLog = (msg) => {
    if (isDebug) {
      if (typeof context?.log === 'function') {
        context.log(msg);
      } else {
        console.log(msg);
      }
    }
  };

  const debugLogSlotsSummary = (slots) => {
    if (!isDebug) return;
    const fmSlots = slots.filter(s => s.slot_part === 'FM');
    const emSlots = slots.filter(s => s.slot_part === 'EM');
    console.log(`üìã Totalt: ${slots.length} | ‚òÄÔ∏è FM: ${fmSlots.length} | üåô EM: ${emSlots.length}`);
  };

  return {
    log: debugLog,
    logSlotsSummary: debugLogSlotsSummary
  };
}

module.exports = { createDebugLogger };
END: debugLogger.js

====================
üìÑ Fil: shared/slots/slotEngine.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-30 14:06:02
üìè Antal rader: 495
üß© Antal funktioner: 11
üí¨ Kommentarst√§ckning: 51 rader (10.3%)
üì• Imports: 7 ‚Äì ["const pool = require('../db/pgPool');", 'const { DateTime } = require("luxon");', "const Holidays = require('date-holidays');", 'const { resolveOriginAddress } = require("../calendar/resolveOrigin");', 'const { resolveTravelTime } = require("../maps/resolveTravelTime");', 'const msGraph = require("../calendar/msGraph");', 'const appleCalendar = require("../calendar/appleCalendar");']
üîç L√§ngsta funktion: 14 rader
üß† Komplexitetspo√§ng: 72
üß™ TODO/FIXME: 0
====================
START: slotEngine.js
const pool = require('../db/pgPool');
const { DateTime } = require("luxon");
const Holidays = require('date-holidays');
const { resolveOriginAddress } = require("../calendar/resolveOrigin");
const { resolveTravelTime } = require("../maps/resolveTravelTime");
const msGraph = require("../calendar/msGraph");
const appleCalendar = require("../calendar/appleCalendar");
const hd = new Holidays('SE'); // Svenska helgdagar
const isDebug = process.env.DEBUG === 'true';

async function generateSlotCandidates({ day, settings, contact, pool, context, graphClient, appleClient, meeting_length, meeting_type, eventCache }) {
  const timezone = settings.timezone || "Europe/Stockholm";
  const holidays = settings.block_holidays ? new Holidays('SE') : null;
  // Generera tidsintervall var 20:e minut i svensk tid mellan √∂ppettid och st√§ngningstid, exkl. lunch
  const open = DateTime.fromISO(`${day}T${settings.open_time}`, { zone: timezone });
  const close = DateTime.fromISO(`${day}T${settings.close_time}`, { zone: timezone });
  const lunchStart = DateTime.fromISO(`${day}T${settings.lunch_start}`, { zone: timezone });
  const lunchEnd = DateTime.fromISO(`${day}T${settings.lunch_end}`, { zone: timezone });

  const startTimes = [];
  let current = open;
  // Anv√§nd context.bookingsByDay som k√§lla till befintliga bokningar per dag
  const bookingsByDay = (typeof context.bookingsByDay === "object" && context.bookingsByDay) ? context.bookingsByDay : {};
  // Vi beh√∂ver slotDateIso f√∂r denna dag
  // day √§r en ISO-str√§ng f√∂r dagen, t.ex. "2024-06-08"
  const slotDateIso = day;
  const existing = bookingsByDay[slotDateIso] || [];
  while (current < close) {
    const end = current.plus({ minutes: meeting_length });
    const overlapsLunch = current < lunchEnd && end > lunchStart;
    if (!overlapsLunch) {
      const isHoliday = settings.block_holidays && holidays?.isHoliday(new Date(current.toISO()));
      if (isHoliday) {
        // if (isDebug) context.log(`‚õî Helgdag ‚Äì hoppar ${current.toISODate()}`);
        current = current.plus({ minutes: 20 });
        continue;
      }
      // --- NY KOD: Kontrollera om sloten krockar med event i bookingsByDay (inkl. heldagsevent) ---
      if (isDebug) {
        context.log(`üìã Befintliga bokningar f√∂r ${slotDateIso}:`);
        for (const ev of existing) {
          const start = new Date(ev.start).toISOString();
          const end = new Date(ev.end).toISOString();
          context.log(`   üìÜ ${start} ‚Üí ${end}`);
        }
      }
      const slotStartMs = current.toMillis();
      const slotEndMs = end.toMillis();
      const bufferMsEarly = (settings.buffer_between_meetings || 0) * 60000;
      if (isDebug) {
        context.log(`üîç Kontroll av konflikt f√∂r slot: ${current.toISO()} ‚Üí ${end.toISO()}`);
        for (const ev of existing) {
          const evStart = new Date(ev.start).toISOString();
          const evEnd = new Date(ev.end).toISOString();
          context.log(`   üìÜ Event: ${evStart} ‚Üí ${evEnd}`);
          context.log(`     ‚Ü™Ô∏é J√§mf√∂relse: ev.start < slotEndMs + bufferMsEarly = ${ev.start} < ${slotEndMs + bufferMsEarly}`);
          context.log(`     ‚Ü™Ô∏é J√§mf√∂relse: ev.end > slotStartMs - bufferMsEarly = ${ev.end} > ${slotStartMs - bufferMsEarly}`);
        }
      }
      const slotConflictsWithEvent = existing.some(ev => {
        return (
          ev.start < slotEndMs + bufferMsEarly &&
          ev.end > slotStartMs - bufferMsEarly
        );
      });
      if (slotConflictsWithEvent) {
        // if (isDebug) context.log(`‚õî Slot krockar med event i bookingsByDay ‚Äì hoppar ${current.toISO()}`);
        current = current.plus({ minutes: 20 });
        continue;
      }
      // --- SLUT NY KOD ---
      startTimes.push(current.toUTC());
    }
    current = current.plus({ minutes: 20 });
  }
  const slots = [];
  // Ber√§kna dagens start och slut
  const fullDayStart = DateTime.fromISO(`${slotDateIso}T${settings.open_time}`, { zone: timezone }).toMillis();
  const fullDayEnd = DateTime.fromISO(`${slotDateIso}T${settings.close_time}`, { zone: timezone }).toMillis();
  const dayEnd = DateTime.fromISO(`${slotDateIso}T${settings.close_time}`, { zone: timezone }).toJSDate();
  const fullDayBlock = existing.some(ev => {
    const evStart = Number(ev.start);
    const evEnd = Number(ev.end);
    const coveredDuration = evEnd - evStart;
    const fullDayDuration = fullDayEnd - fullDayStart;
    return (
      evStart <= fullDayStart + 30 * 60 * 1000 &&
      evEnd >= fullDayEnd - 30 * 60 * 1000 &&
      coveredDuration >= fullDayDuration * 0.95
    );
  });
  if (fullDayBlock) {
    // context.log(`‚õî Hela dagen blockeras av ett heldagsevent ‚Äì hoppar ${slotDateIso}`);
    return [];
  }

  for (const utcStart of startTimes) {
    const eventId = utcStart.toISO();
    const dateObj = utcStart.toJSDate();
    const weekday = dateObj.toLocaleDateString("en-US", { weekday: "long", timeZone: timezone }).toLowerCase();
    const slot_part = utcStart.hour < 12 ? "fm" : "em";
    const slotHourStr = utcStart.setZone(timezone).toFormat('HH:mm');
    if (slotHourStr >= settings.lunch_start && slotHourStr < settings.lunch_end) {
      // if (isDebug) context.log(`üçΩÔ∏è Slot under lunch (${slotHourStr}) ‚Äì hoppar ${eventId}`);
      continue;
    }
    const isWeekend = ["saturday", "sunday"].includes(weekday);
    if (settings.block_weekends && isWeekend) {
      // if (isDebug) context.log(`‚õî Helg blockerad (${weekday}) ‚Äì hoppar ${eventId}`);
      continue;
    }
    if (meeting_type === 'atclient' && Array.isArray(settings.allowed_atclient_meeting_days)) {
      if (!settings.allowed_atclient_meeting_days.includes(weekday)) {
        // if (isDebug) context.log(`‚õî atclient till√•ts ej p√• ${weekday} ‚Äì hoppar ${eventId}`);
        continue;
      }
    }

    // Konvertera dateObj till r√§tt tidszon f√∂r helgdagskontroll
    const localDate = DateTime.fromJSDate(dateObj).setZone(timezone).toJSDate();
    const isHoliday = hd.isHoliday(localDate);
    if (settings.block_holidays && isHoliday) {
      if (isDebug) context.log(`üéå Helgdag ${isHoliday[0]?.name} ‚Äì hoppar ${eventId}`);
      continue;
    }


    const originInfo = await resolveOriginAddress({
      eventId,
      calendarId: 'system',
      pool,
      context,
      graphClient,
      appleClient,
      fallbackOrigin: settings.default_home_address,
      settings,
      eventCache
    });

    if (!originInfo?.origin) {
      // context.log(`‚ö†Ô∏è Kunde inte fastst√§lla origin f√∂r ${eventId}`);
      continue;
    }

    const destination = settings.default_office_address;
    const travelTimeResult = await resolveTravelTime({
      origin: originInfo.origin,
      destination,
      hour: utcStart.hour,
      db: pool,
      accessToken: context.accessToken || null,
      context
    });
    const travelTimeMin = travelTimeResult?.travelTimeMin;
    const travelSource = travelTimeResult?.source || 'fallback';

    if (!travelTimeMin || typeof travelTimeMin !== "number") {
      // context.log.warn(`‚ö†Ô∏è Ogiltig restid, hoppar slot: ${eventId}`);
      continue;
    }

    const endTime = new Date(dateObj.getTime() + meeting_length * 60000);
    // dayStart och dayEnd redan definierade ovan
    if (endTime > dayEnd) {
      // context.log(`‚õî Slot ${eventId} g√•r utanf√∂r √∂ppettid (${settings.close_time}) ‚Äì hoppar`);
      continue;
    }

    // Skip slots that are too soon to reach based on travel time and current time
    const now = Date.now();
    if (dateObj.getTime() - now < travelTimeMin * 60 * 1000) {
      // context.log(`‚õî Slot ${eventId} √§r f√∂r n√§ra i tid ‚Äì restid ${travelTimeMin} min, nu=${new Date(now).toISOString()} ‚Äì hoppar`);
      continue;
    }

    // Build slot object
    const slot = {
      slot_iso: eventId,
      slot_local: DateTime.fromJSDate(dateObj).setZone(timezone).toISO(),
      travel_time_min: travelTimeMin,
      origin: originInfo.origin,
      originEndTime: originInfo.originEndTime,
      source: travelSource,
      require_approval: settings.require_approval,
      meeting_length,
      weekday,
      slot_part
    };


    // --- Score calculation logic ---
    const slotStart = dateObj.getTime();
    const slotEnd = slotStart + meeting_length * 60000;
    // existing redan definierad ovan
    let gapBefore = null;
    let gapAfter = null;

    for (const b of existing) {
      const bStart = b.start;
      const bEnd = b.end;
      if (bEnd <= slotStart) {
        gapBefore = slotStart - bEnd;
      } else if (bStart >= slotEnd && gapAfter === null) {
        gapAfter = bStart - slotEnd;
      }
    }

    const bufferMs = (settings.buffer_between_meetings || 0) * 60000;
    const hasConflict = existing.some(b => {
      return (
        b.start < slotEnd + bufferMs &&
        b.end > slotStart - bufferMs
      );
    });
    if (hasConflict) {
      // context.log(`‚õî Slot ${eventId} krockar med m√∂te inom buffer (${settings.buffer_between_meetings || 0} min) ‚Äì hoppar`);
      // existing.forEach(b => {
      //   const bStartStr = new Date(b.start).toISOString();
      //   const bEndStr = new Date(b.end).toISOString();
      //   if (
      //     b.start < slotEnd + bufferMs &&
      //     b.end > slotStart - bufferMs
      //   ) {
      //     context.log(`   ‚ö†Ô∏è  Konflikt med: ${bStartStr} ‚Üí ${bEndStr}`);
      //   }
      // });
      continue;
    }
    // Blockera √§ven om sloten b√∂rjar exakt n√§r ett event b√∂rjar, eller slutar exakt n√§r ett event slutar
    const hardMatchConflict = existing.some(b => {
      return (
        b.start === slotStart || b.end === slotEnd
      );
    });
    if (hardMatchConflict) {
      // context.log(`‚õî Slot ${eventId} b√∂rjar eller slutar exakt n√§r ett event b√∂rjar/slutar ‚Äì hoppar`);
      continue;
    }


    // Standardpo√§ng √§r 10. Dra av po√§ng f√∂r stor lucka f√∂re eller efter.
    let fragmentationPenalty = 0;
    if ((gapBefore && gapBefore > 45 * 60000) || (gapAfter && gapAfter > 45 * 60000)) {
      fragmentationPenalty = 1;
    }

    slot.score = 10 - fragmentationPenalty;

    slots.push(slot);
    // if (isDebug && travelSource === 'fallback') {
    //   context.log(`‚ö†Ô∏è Slot ${eventId} anv√§nder fallback f√∂r restid (ingen accessToken)`);
    // }
  }

  // Separera f√∂rmiddag och eftermiddag
  const fmSlots = slots.filter(slot => slot.slot_part === 'fm');
  const emSlots = slots.filter(slot => slot.slot_part === 'em');

  // Sorteringsfunktion: h√∂gst po√§ng f√∂rst, d√§refter kortast restid, d√§refter tidigast tid
  const sortSlots = (a, b) =>
    b.score - a.score ||
    a.travel_time_min - b.travel_time_min ||
    new Date(a.slot_iso) - new Date(b.slot_iso);

  // Sortera b√•da grupper
  fmSlots.sort(sortSlots);
  emSlots.sort(sortSlots);

  // V√§lj b√§sta fm och em (om de finns)
  const bestFm = fmSlots[0];
  const bestEm = emSlots.find(em => !bestFm || em.slot_iso !== bestFm.slot_iso);

  // Returnera endast de tv√• b√§sta
  const topSlots = [bestFm, bestEm].filter(Boolean);
  const allSlots = [...fmSlots, ...emSlots];
  // === LOG SELECTED TOP SLOTS ===
  if (isDebug) {
    if (topSlots.length > 0) {
      context.log(`‚úÖ Slot-kandidater valda f√∂r ${slotDateIso}:`);
      topSlots.forEach(slot => {
        const icon = slot.slot_part === 'fm' ? '‚òÄÔ∏è' : 'üåô';
        const t = DateTime.fromISO(slot.slot_iso).setZone(timezone).toFormat("yyyy-MM-dd HH:mm");
        context.log(`   ${icon} ${slot.slot_part.toUpperCase()} ${t} (${slot.score}/10, ${slot.travel_time_min} min restid)`);
      });
    } else {
      context.log(`‚õî Inga valda slot-kandidater f√∂r ${slotDateIso}`);
    }
  }
  // === BLOCK: Slot-summering/debug innan slots loggas ===
  if (isDebug) {
    const blockedSummary = [];
    if (startTimes.length === 0) {
      blockedSummary.push("‚õî Inga starttider genererades p.g.a. heldagsevent, helgdag eller block");
    }
    if (fullDayBlock) {
      blockedSummary.push("‚õî Dagen blockeras helt p.g.a. heldagsevent");
    }
    if (startTimes.length > 0 && allSlots.length === 0) {
      blockedSummary.push("‚õî Alla slots filtrerades bort av regler: t.ex. restid, konflikt, √∂ppettid, veckokvot, m.m.");
    }
    if (blockedSummary.length > 0) {
      context.log(`üßæ Slot-summering ${slotDateIso}:`);
      for (const line of blockedSummary) context.log("   " + line);
    }
  }
  allSlots.forEach(s => {
    const icon = s.slot_part === 'fm' ? '‚òÄÔ∏è' : 'üåô';
    if (isDebug) context.log(`${icon} ${s.slot_part.toUpperCase()}: ${s.slot_iso} ‚Äì score: ${s.score}`);
  });
  return topSlots;
}


async function generateSlotChunks({
  days,
  context,
  contact,
  contact_id,
  meeting_type,
  meeting_length,
  bookingsByDay,
  weeklyMinutesByType,
  settings,
  graphClient,
  appleClient,
  travelCache,
  accessToken,
  timezone,
  debugHelper
}) {
  const { debugLog, skipReasons } = debugHelper || {};
  const chosen = [];

  if (days.length === 0) {
    const fallbackDate = new Date().toISOString().split('T')[0];
    const { rows } = await pool.query(
      'SELECT slots FROM slot_cache WHERE slot_day = $1 LIMIT 1',
      [fallbackDate]
    );
    if (rows.length > 0) {
      context.log(`‚úÖ Anv√§nder slot_cache som fallback (${fallbackDate})`);
      return {
        chosenSlots: rows[0].slots || [],
        slotMapResult: {},
        slotLogSummary: { 'fallback_used': 1 }
      };
    }
  }

  let startIso, endIso;
  try {
    startIso = days[0] instanceof Date ? days[0].toISOString() : new Date(days[0]).toISOString();
    endIso = new Date((days[days.length - 1] instanceof Date ? days[days.length - 1] : new Date(days[days.length - 1])).getTime() + 86400000).toISOString();
  } catch (err) {
    context.log("‚õî Fel vid toISOString p√• days[] ‚Äì ers√§tter med dagens datum");
    const today = new Date();
    startIso = today.toISOString();
    endIso = new Date(today.getTime() + 7 * 86400000).toISOString(); // +7 dagar fallback
  }

  // === L√ÑGG TILL EXTERNA BOKNINGAR (MS + Apple) I bookingsByDay ===

  // Microsoft Graph
  try {
    const msEvents = await graphClient.listUpcomingEvents?.(days.length + 1) || [];
    let msAddedCount = 0;
    for (const ev of msEvents) {
      const start = new Date(ev.start).getTime();
      const end = new Date(ev.end).getTime();
      if (isNaN(start) || isNaN(end)) continue;
      const date = new Date(ev.start).toISOString().split("T")[0];
      if (!bookingsByDay[date]) bookingsByDay[date] = [];
      bookingsByDay[date].push({ start, end });
      msAddedCount++;
    }
    if (isDebug) {
      context.log(`üìÜ MS Graph: ${msEvents.length} h√§ndelser analyserades, ${msAddedCount} lades till bookingsByDay`);
    }
  } catch (err) {
    context.log(`‚ö†Ô∏è Kunde inte ladda MS-bokningar: ${err.message}`);
  }

  // Apple Calendar
  try {
    const startDate = days[0] instanceof Date ? days[0] : new Date(days[0]);
    const endDate = days[days.length - 1] instanceof Date
      ? new Date(days[days.length - 1].getTime() + 86400000)
      : new Date(new Date(days[days.length - 1]).getTime() + 86400000);
    if (isNaN(startDate) || isNaN(endDate)) {
      context.log("‚õî Ogiltiga datum skickas till Apple i slotEngine:", { startDate, endDate });
    }
    const appleEvents = await appleClient.fetchEventsByDateRange?.(startDate, endDate) || [];
    let appleAddedCount = 0;
    for (const ev of appleEvents) {
      try {
        // Ensure start and end are cast to numbers explicitly
        const start = Number(new Date(ev.dtstart));
        const end = Number(new Date(ev.dtend));
        if (isNaN(start) || isNaN(end)) continue;
        const date = new Date(ev.dtstart).toISOString().split("T")[0];
        if (!bookingsByDay[date]) bookingsByDay[date] = [];
        bookingsByDay[date].push({ start, end });
        appleAddedCount++;
      } catch (err) {
        context.log(`‚ö†Ô∏è Apple event parsing error: ${err.message}`);
      }
    }
    if (isDebug) {
      context.log(`üçè Apple Calendar: ${appleEvents.length} h√§ndelser analyserades`);
    }
  } catch (err) {
    context.log(`‚ö†Ô∏è Kunde inte ladda Apple-bokningar: ${err.message}`);
  }

  context.bookingsByDay = bookingsByDay;

  const slotCandidatePromises = days.map(day => {
    const dayStr = day.toISOString().split("T")[0];
    return generateSlotCandidates({
      day: dayStr,
      settings,
      contact,
      pool: context.client || pool,
      context,
      graphClient,
      appleClient,
      meeting_length,
      meeting_type,
      eventCache: context.eventCache instanceof Map ? context.eventCache : new Map()
    });
  });

  const slotCandidatesPerDay = await Promise.all(slotCandidatePromises);

  const slotMap = {};
  days.forEach((day, index) => {
    const dayStr = day.toISOString().split("T")[0];
    const slotCandidates = slotCandidatesPerDay[index];
    for (const slot of slotCandidates) {
      const key = `${dayStr}_${slot.slot_part}`;
      if (!slotMap[key]) slotMap[key] = [];
      slotMap[key].push(slot);
    }
  });

  const bestPerGroup = {};
  for (const [key, slots] of Object.entries(slotMap)) {
    if (slots.length === 0) continue;
    const [datePart, part] = key.split('_');
    if (!bestPerGroup[datePart]) bestPerGroup[datePart] = {};
    if (!bestPerGroup[datePart][part]) {
      bestPerGroup[datePart][part] = slots
        .sort((a, b) => {
          if ((b.score || 0) !== (a.score || 0)) return (b.score || 0) - (a.score || 0);
          return new Date(a.slot_iso) - new Date(b.slot_iso);
        })[0];
    }
  }

  for (const day in bestPerGroup) {
    for (const part in bestPerGroup[day]) {
      const slot = bestPerGroup[day][part];
      const weekKeyStr = day;
      const usedMinutes = (weeklyMinutesByType[meeting_type]?.[weekKeyStr] || 0);
      if (usedMinutes + slot.meeting_length <= settings.max_weekly_booking_minutes) {
        chosen.push(slot);
      } else {
        debugLog?.(`‚õî √ñverskrider veckokvot (${usedMinutes + slot.meeting_length} > ${settings.max_weekly_booking_minutes}) ‚Äì hoppar ${day}_${part}`);
      }
    }
  }

  if (isDebug) {
    for (const day in bestPerGroup) {
      for (const part in bestPerGroup[day]) {
        const slot = bestPerGroup[day][part];
        context.log(`üìÜ Slot: ${slot.slot_iso} score=${slot.score}`);
      }
    }
  }

  const durationMs = Date.now() - context.startTime;
  if (isDebug) context.log(`‚è±Ô∏è Slotgenerering klar p√• ${durationMs} ms`);
  if (isDebug) context.log(`üì§ Response skickas med antal slots: ${chosen.length}`);
  return {
    chosenSlots: chosen.sort((a, b) => new Date(a.slot_iso) - new Date(b.slot_iso)),
    slotMapResult: slotMap,
    slotLogSummary: skipReasons
  };
}

module.exports = {
  generateSlotCandidates,
  generateSlotChunks
};
END: slotEngine.js

====================
üìÑ Fil: trackingPixel/index.js
üìÇ Kodtyp: üìÑ √ñvrigt
üóÇ Filtyp: üü® JavaScript
üìÖ Senast √§ndrad: 2025-05-31 18:24:20
üìè Antal rader: 31
üß© Antal funktioner: 0
üí¨ Kommentarst√§ckning: 1 rader (3.2%)
üì• Imports: 2 ‚Äì ["const { v4: uuidv4 } = require('uuid');", "const pool = require('../shared/db/pgPool');"]
üîç L√§ngsta funktion: 0 rader
üß† Komplexitetspo√§ng: 1
üß™ TODO/FIXME: 0
====================
START: index.js
const { v4: uuidv4 } = require('uuid');
const pool = require('../shared/db/pgPool');

module.exports = async function (context, req) {
    const bookingId = req.query.booking_id || 'unknown';
    const ip = req.headers['x-forwarded-for'] || req.headers['x-client-ip'] || req.socket.remoteAddress;
    const userAgent = req.headers['user-agent'] || 'unknown';
    const now = new Date().toISOString();
  
    try {
      await pool.query(
        `INSERT INTO event_log (id, booking_id, event_type, source, timestamp)
         VALUES ($1, $2, 'email_open', 'tracking_pixel', $3)`,
        [uuidv4(), bookingId, new Date()]
      );
    } catch (err) {
      context.log('‚ö†Ô∏è Kunde inte logga email_open:', err.message);
    }
  
    // Logga till databasen eller event_log (kan du v√§lja sj√§lv senare)
    context.log(`üì© TrackingPixel √∂ppnad | booking_id=${bookingId} | ip=${ip} | ua=${userAgent} | tid=${now}`);
  
    context.res = {
      status: 200,
      headers: {
        'Content-Type': 'image/gif',
        'Cache-Control': 'no-cache, no-store, must-revalidate'
      },
      body: Buffer.from('R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==', 'base64') // 1x1 transparent GIF
    };
  };
END: index.js

üìÅ KONFIGURATIONSFILER (function.json / host.json / package.json / .funcignore)
====================================

üìÑ .funcignore
   # Exclude dev-only files and folders
   .git
   .vscode
   .env
   *.log
   test/
   tests/
   
   # Explicitly include all required files and folders
   !host.json
   !package.json
   !package-lock.json
   
   !node_modules/
   !node_modules/**
   
   !shared/
   !shared/**
   
   !bookings/
   !bookings/**
   !getavailableslots/
   !getavailableslots/**
   !validate_contact/
   !validate_contact/**
   !meeting_types/
   !meeting_types/**
   !refreshCalendarOrigins/
   !refreshCalendarOrigins/**
   !refreshTravelTimes/
   !refreshTravelTimes/**
   !booking_settings/
   !booking_settings/**
   !test_azurecloud/
   !test_azurecloud/**
   !trackingPixel/
   !trackingPixel/**
üìÑ booking_settings/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get"],
         "route": "booking_settings"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ bookings/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "bookings"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ getavailableslots/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "getavailableslots"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ host.json
   {
     "version": "2.0",
     "extensionBundle": {
       "id": "Microsoft.Azure.Functions.ExtensionBundle",
       "version": "[4.*, 5.0.0)"
     },
     "extensions": {
       "http": {
         "cors": {
           "allowedOrigins": [
             "https://www.klrab.se"
           ],
           "supportCredentials": false
         }
       }
     }
   }
üìÑ meeting_types/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": [ "get" ],
         "route": "meeting_types"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ package.json
   {
     "name": "macspot-api",
     "version": "1.0.0",
     "description": "Azure Functions backend f√∂r MacSpot CRM/ERP",
     "scripts": {
       "start": "func start",
       "dev": "func start --verbose",
       "deploy": "func azure functionapp publish macspotbackend",
       "build": "echo 'Nothing to build'"
     },
     "dependencies": {
       "@azure/functions": "^4.7.0",
       "@azure/msal-node": "^3.5.1",
       "@microsoft/microsoft-graph-client": "^3.0.0",
       "date-holidays": "^3.24.3",
       "dav": "^1.8.0",
       "dotenv": "^16.5.0",
       "isomorphic-fetch": "^3.0.0",
       "jsonwebtoken": "^9.0.0",
       "luxon": "^3.4.4",
       "node-fetch": "^2.7.0",
       "node-ical": "^0.20.1",
       "p-limit": "^6.2.0",
       "pg": "^8.15.6",
       "uuid": "^9.0.0",
       "xml2js": "^0.6.2"
     }
   }

üìÑ refreshCalendarOrigins/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ refreshTravelTimes/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ test_azurecloud/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get"],
         "route": "test_azurecloud"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìÑ validate_contact/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get", "post"],
         "route": "validate_contact"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
üìà SUMMERING AV ALLA JS-FILER
====================================
üìè Totalt antal rader kod: 3145
üß© Totalt antal funktioner: 71
üß† Total komplexitetspo√§ng: 338
üß™ Antal TODO/FIXME totalt: 0

üìä Per fil:
fil,rader,funktioner,komplexitet,kommentarer,imports
index.js,47,1,3,1,2
index.js,182,1,28,5,3
index.js,329,10,31,32,9
index.js,36,1,1,0,4
index.js,112,4,8,0,6
appleCalendar.js,198,8,27,0,3
getMsToken.js,57,1,5,12,2
msGraph.js,187,7,15,1,5
resolveOrigin.js,236,2,38,21,0
settingsLoader.js,63,2,11,0,1
verifySettings.js,51,1,8,0,0
pgPool.js,17,1,0,0,2
appleMaps.js,120,5,9,0,2
returnTravelVerifier.js,66,1,9,1,1
resolveTravelTime.js,78,1,16,0,0
zoomClient.js,63,3,3,0,1
sendMail.js,72,2,3,11,1
index.js,678,6,47,34,7
debugLogger.js,27,3,3,0,0
slotEngine.js,495,11,72,51,7
index.js,31,0,1,1,2
üìä MOLNDATABAS (Azure) ‚Äì STRUKTUR & INNEH√ÖLL
====================================

üìÅ Tabell: slot_cache
  ‚Ä¢ created_at (timestamp without time zone)
  ‚Ä¢ slot_day (date)
  ‚Ä¢ slots (jsonb)
  ‚Ä¢ id (uuid)
  ‚Ä¢ meeting_length (integer)
  ‚Ä¢ booking_email (text)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ slot_part (text)
  üîë [p] slot_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: calendar_origin_cache
  ‚Ä¢ created_at (timestamp without time zone)
  ‚Ä¢ timestamp (timestamp with time zone)
  ‚Ä¢ event_date (date)
  ‚Ä¢ id (integer)
  ‚Ä¢ end_time (timestamp without time zone)
  ‚Ä¢ address (text)
  ‚Ä¢ source (text)
  üîë [c] calendar_origin_cache_source_check: CHECK ((source = ANY (ARRAY['Apple Calendar'::text, 'Microsoft 365'::text])))
  üîë [p] calendar_origin_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: available_slots_cache
  ‚Ä¢ id (uuid)
  ‚Ä¢ travel_time_min (integer)
  ‚Ä¢ generated_at (timestamp without time zone)
  ‚Ä¢ expires_at (timestamp without time zone)
  ‚Ä¢ meeting_length (integer)
  ‚Ä¢ slot_day (date)
  ‚Ä¢ slot_score (integer)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ slot_part (text)
  ‚Ä¢ slot_iso (text)
  üîë [p] available_slots_cache_pkey: PRIMARY KEY (id)

üìÅ Tabell: travel_time_cache
  ‚Ä¢ travel_minutes (integer)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ is_fallback (boolean)
  ‚Ä¢ hour (integer)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ to_address (text)
  ‚Ä¢ from_address (text)
  üîë [u] unique_travel_key: UNIQUE (from_address, to_address, hour)
  üß™ Topp 5 rader:
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=8, travel_minutes=20, created_at=2025-06-01 09:13:18.647629+00:00, updated_at=2025-06-01 09:13:18.647629+00:00, is_fallback=False
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=6, travel_minutes=20, created_at=2025-06-01 09:13:18.813239+00:00, updated_at=2025-06-01 09:13:18.813239+00:00, is_fallback=False
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=13, travel_minutes=20, created_at=2025-06-01 09:13:20.160515+00:00, updated_at=2025-06-01 09:13:20.160515+00:00, is_fallback=False
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=7, travel_minutes=20, created_at=2025-06-01 09:13:19.377948+00:00, updated_at=2025-06-01 09:13:19.377948+00:00, is_fallback=False
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=12, travel_minutes=20, created_at=2025-06-01 09:13:19.614583+00:00, updated_at=2025-06-01 09:13:19.614583+00:00, is_fallback=False

üìÅ Tabell: event_log
  ‚Ä¢ received_at (timestamp with time zone)
  ‚Ä¢ record_id (uuid)
  ‚Ä¢ timestamp (timestamp with time zone)
  ‚Ä¢ booking_id (uuid)
  ‚Ä¢ id (uuid)
  ‚Ä¢ payload (jsonb)
  ‚Ä¢ action (text)
  ‚Ä¢ event_type (text)
  ‚Ä¢ source (text)
  ‚Ä¢ table_name (text)
  üîë [p] event_log_pkey: PRIMARY KEY (id)
  üß™ Topp 5 rader:
    - source=None, event_type=None, payload=None, received_at=2025-06-01 09:13:13.013623+00:00, id=6ecb7a17-c6c6-4b32-b1b0-47858a10bb81, action=INSERT, table_name=contact, record_id=ff5d1a4c-08b0-49be-8601-86f022228c88, timestamp=2025-06-01 09:13:13.013623+00:00, booking_id=None
    - source=None, event_type=booking_created, payload=None, received_at=2025-06-01 09:13:32.628997+00:00, id=8f2078ab-af0b-4362-a641-1fdd735193e7, action=None, table_name=None, record_id=None, timestamp=2025-06-01 09:13:32.628997+00:00, booking_id=9a1bfaff-462d-4964-b5e1-c58a011c4c9b
    - source=None, event_type=booking_created, payload=None, received_at=2025-06-01 09:16:46.999838+00:00, id=4c5d6808-d901-4c15-af5b-4c90e97f9426, action=None, table_name=None, record_id=None, timestamp=2025-06-01 09:16:46.999838+00:00, booking_id=7782cdbd-0d37-474e-b4ba-1e0d80968632
    - source=None, event_type=booking_created, payload=None, received_at=2025-06-01 09:34:28.229328+00:00, id=1ff74689-15fa-485a-bf5d-d27b950ce347, action=None, table_name=None, record_id=None, timestamp=2025-06-01 09:34:28.229328+00:00, booking_id=dd9d51e9-8733-4fa0-a5bc-36730d284686
    - source=None, event_type=booking_created, payload=None, received_at=2025-06-01 09:47:12.292423+00:00, id=1a5d7ecc-1cf8-400e-836b-d8d73538bb5d, action=None, table_name=None, record_id=None, timestamp=2025-06-01 09:47:12.292423+00:00, booking_id=fc5fab3c-482e-4c48-b259-e47bc9c441a7

üìÅ Tabell: booking_settings
  ‚Ä¢ value (jsonb)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ key (text)
  ‚Ä¢ value_type (text)
  üîë [u] unique_key: UNIQUE (key)
  üß™ Topp 5 rader:
    - key=default_language, value=sv, value_type=string, updated_at=2025-05-25 10:37:53.619684+00:00
    - key=default_meeting_length_atclient, value=[90, 180, 270, 360], value_type=array, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=default_meeting_length_atoffice, value=[60, 90], value_type=array, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=default_meeting_length_digital, value=[10, 20, 60], value_type=array, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=default_meeting_subject, value=M√∂te med KLRA Ledningsr√•dgivning, value_type=string, updated_at=2025-05-25 10:37:53.619684+00:00

üìÅ Tabell: translation
  ‚Ä¢ key (character varying)
  ‚Ä¢ sv (text)
  ‚Ä¢ en (text)
  üß™ Topp 5 rader:
    - key=error_min_duration_fysiskt_kund, sv=M√∂testiden f√∂r 'Fysiskt hos kund' m√•ste vara minst {{minutes}} minuter. Du visste det redan., en=The meeting time for 'On-site at customer' must be at least {{minutes}} minutes. You knew that.
    - key=error_min_duration_fysiskt_mig, sv=M√∂testiden f√∂r 'Fysiskt hos mig' m√•ste vara minst {{minutes}} minuter. Annars hinner vi bara s√§ga hej., en=The meeting time for 'At my office' must be at least {{minutes}} minutes. Otherwise, we‚Äôll only have time to say hello.
    - key=email_body_booking_received, sv=Hej {{name}}! Vi har tagit emot din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}}. Ingen panik ‚Äì vi √•terkommer med bekr√§ftelse. / Daniel, en=Hello {{name}}, We‚Äôve received your booking for {{meeting_type}} between {{start_time}} and {{end_time}}. No need to panic ‚Äì we‚Äôll confirm shortly. / Daniel
    - key=email_body_booking_confirmed, sv=Hej {{name}}! Din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}} √§r nu spikad. Ser fram emot det! / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} is now locked in. Looking forward! / Daniel
    - key=email_body_booking_cancelled, sv=Hej {{name}}! Din bokning f√∂r {{meeting_type}} mellan {{start_time}} och {{end_time}} √§r avbokad. H√∂r av dig om du vill hitta en ny tid. / Daniel, en=Hello {{name}}, Your booking for {{meeting_type}} between {{start_time}} and {{end_time}} has been cancelled. Let me know if you'd like a new one. / Daniel

üìÅ Tabell: bookings
  ‚Ä¢ start_time (timestamp with time zone)
  ‚Ä¢ end_time (timestamp with time zone)
  ‚Ä¢ id (uuid)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ metadata (jsonb)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ contact_id (uuid)
  ‚Ä¢ meeting_type (text)
  ‚Ä¢ booking_email (text)
  üîë [p] bookings_pkey: PRIMARY KEY (id)
  üîë [f] fk_bookings_contact: FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE SET NULL
  üß™ Topp 5 rader:
    - start_time=2025-06-13 06:00:00+00:00, end_time=2025-06-13 07:30:00+00:00, meeting_type=atclient, metadata={'city': 'STOCKHOLM', 'phone': '0709561480', 'address': 'Kungsgatan 12', 'company': 'Testbolag AB', 'country': 'Sverige', 'subject': 'M√∂te hos Testbolag AB: Daniel | {{company}} & Daniel | Kinnekulle Ledningsr√•dgivning AB', 'location': 'Kungsgatan 12', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'ip_address': '172.226.49.46:64040', 'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Safari/605.1.15', 'postal_code': '112 23', 'meeting_length': 90}, created_at=2025-06-01 09:13:32.100000+00:00, contact_id=ff5d1a4c-08b0-49be-8601-86f022228c88, id=9a1bfaff-462d-4964-b5e1-c58a011c4c9b, updated_at=2025-06-01 09:13:32.100000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-06-03 06:00:00+00:00, end_time=2025-06-03 06:20:00+00:00, meeting_type=facetime, metadata={'city': 'STOCKHOLM', 'phone': '0709561480', 'address': 'Kungsgatan 12', 'company': 'Testbolag AB', 'country': 'Sverige', 'subject': 'FaceTime: Daniel | Testbolag AB & Daniel | Kinnekulle Ledningsr√•dgivning AB (FaceTime)', 'location': 'FaceTime', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'ip_address': '172.226.49.46:63149', 'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Safari/605.1.15', 'online_link': 'facetime:0709561480', 'postal_code': '112 23', 'meeting_length': 20}, created_at=2025-06-01 09:16:46.613000+00:00, contact_id=ff5d1a4c-08b0-49be-8601-86f022228c88, id=7782cdbd-0d37-474e-b4ba-1e0d80968632, updated_at=2025-06-01 09:16:46.613000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-06-03 06:40:00+00:00, end_time=2025-06-03 07:00:00+00:00, meeting_type=facetime, metadata={'city': 'STOCKHOLM', 'phone': '0709561480', 'address': 'Kungsgatan 12', 'company': 'Testbolag AB', 'country': 'Sverige', 'subject': 'FaceTime: Daniel | Testbolag AB & Daniel | Kinnekulle Ledningsr√•dgivning AB (FaceTime)', 'location': 'FaceTime', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'ip_address': '172.226.49.46:64969', 'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Safari/605.1.15', 'online_link': 'facetime:0709561480', 'postal_code': '112 23', 'meeting_length': 20}, created_at=2025-06-01 09:34:27.739000+00:00, contact_id=ff5d1a4c-08b0-49be-8601-86f022228c88, id=dd9d51e9-8733-4fa0-a5bc-36730d284686, updated_at=2025-06-01 09:34:27.739000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-06-11 06:00:00+00:00, end_time=2025-06-11 06:10:00+00:00, meeting_type=teams, metadata={'city': 'STOCKHOLM', 'phone': '0709561480', 'address': 'Kungsgatan 12', 'company': 'Testbolag AB', 'country': 'Sverige', 'subject': 'Teams: Daniel | Testbolag AB & Daniel | Kinnekulle Ledningsr√•dgivning AB', 'location': 'Online', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'ip_address': '172.226.49.46:62912', 'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Safari/605.1.15', 'online_link': 'https://teams.microsoft.com/l/meetup-join/19%3ameeting_YmQ3YjczMzYtNTVmZi00Yjc4LWFjNzQtYzJjNGYyNTYwNmZm%40thread.v2/0?context=%7b%22Tid%22%3a%226f2f8e0c-22fc-4d93-bf68-72a916e2f35f%22%2c%22Oid%22%3a%2285224b32-2747-4b0c-bc0f-3bb4e7192aa9%22%7d', 'postal_code': '112 23', 'meeting_length': 10}, created_at=2025-06-01 09:47:09.077000+00:00, contact_id=ff5d1a4c-08b0-49be-8601-86f022228c88, id=fc5fab3c-482e-4c48-b259-e47bc9c441a7, updated_at=2025-06-01 09:47:09.077000+00:00, booking_email=daniel.kallberg@mac.com
    - start_time=2025-06-10 07:00:00+00:00, end_time=2025-06-10 07:20:00+00:00, meeting_type=facetime, metadata={'city': 'STOCKHOLM', 'phone': '0709561480', 'address': 'Kungsgatan 12', 'company': 'Testbolag AB', 'country': 'Sverige', 'subject': 'FaceTime: Daniel | Testbolag AB & Daniel | Kinnekulle Ledningsr√•dgivning AB (FaceTime)', 'location': 'FaceTime', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'ip_address': '172.226.48.40:21473', 'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Safari/605.1.15', 'online_link': 'facetime:0709561480', 'postal_code': '112 23', 'meeting_length': 20}, created_at=2025-06-01 10:04:12.472000+00:00, contact_id=ff5d1a4c-08b0-49be-8601-86f022228c88, id=522b146e-68b4-4205-949f-71a19c91386e, updated_at=2025-06-01 10:04:12.472000+00:00, booking_email=daniel.kallberg@mac.com

üìÅ Tabell: pending_changes
  ‚Ä¢ booking_id (uuid)
  ‚Ä¢ processed (boolean)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ payload (jsonb)
  ‚Ä¢ id (uuid)
  ‚Ä¢ record_id (uuid)
  ‚Ä¢ table_name (text)
  ‚Ä¢ operation (text)
  ‚Ä¢ change_type (text)
  ‚Ä¢ direction (text)
  üîë [p] pending_changes_pkey: PRIMARY KEY (id)
  üîë [f] fk_pending_changes_booking_id: FOREIGN KEY (booking_id) REFERENCES bookings(id) ON DELETE CASCADE
  üß™ Topp 5 rader:
    - id=a6b7cbbe-d0f1-40fd-903f-97df885a31c9, table_name=contact, record_id=ff5d1a4c-08b0-49be-8601-86f022228c88, change_type=INSERT, direction=out, processed=False, created_at=2025-06-01 09:13:13.013623+00:00, operation=INSERT, payload={'id': 'ff5d1a4c-08b0-49be-8601-86f022228c88', 'email': 'daniel.kallberg@mac.com', 'metadata': {'city': 'STOCKHOLM', 'phone': '0709561480', 'address': 'Kungsgatan 12', 'company': 'Testbolag AB', 'country': 'Sverige', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'postal_code': '112 23'}, 'created_at': '2025-06-01T09:13:13.013623+00:00', 'updated_at': '2025-06-01T09:13:13.013623+00:00', 'booking_email': 'daniel.kallberg@mac.com'}, booking_id=None
    - id=212e0015-2e08-4163-b127-e79ca3db2041, table_name=bookings, record_id=9a1bfaff-462d-4964-b5e1-c58a011c4c9b, change_type=INSERT, direction=out, processed=False, created_at=2025-06-01 09:13:32.573393+00:00, operation=INSERT, payload={'id': '9a1bfaff-462d-4964-b5e1-c58a011c4c9b', 'end_time': '2025-06-13T07:30:00+00:00', 'metadata': {'city': 'STOCKHOLM', 'phone': '0709561480', 'address': 'Kungsgatan 12', 'company': 'Testbolag AB', 'country': 'Sverige', 'subject': 'M√∂te hos Testbolag AB: Daniel | {{company}} & Daniel | Kinnekulle Ledningsr√•dgivning AB', 'location': 'Kungsgatan 12', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'ip_address': '172.226.49.46:64040', 'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Safari/605.1.15', 'postal_code': '112 23', 'meeting_length': 90}, 'contact_id': 'ff5d1a4c-08b0-49be-8601-86f022228c88', 'created_at': '2025-06-01T09:13:32.1+00:00', 'start_time': '2025-06-13T06:00:00+00:00', 'updated_at': '2025-06-01T09:13:32.1+00:00', 'meeting_type': 'atclient', 'booking_email': 'daniel.kallberg@mac.com'}, booking_id=9a1bfaff-462d-4964-b5e1-c58a011c4c9b
    - id=698e4c2c-fbea-4775-bad8-3aaa8612afff, table_name=bookings, record_id=9a1bfaff-462d-4964-b5e1-c58a011c4c9b, change_type=INSERT, direction=cloud_to_local, processed=False, created_at=2025-06-01 09:13:32.576000+00:00, operation=None, payload=None, booking_id=9a1bfaff-462d-4964-b5e1-c58a011c4c9b
    - id=0361d653-2d91-4b38-b6b5-882946f9568f, table_name=bookings, record_id=7782cdbd-0d37-474e-b4ba-1e0d80968632, change_type=INSERT, direction=out, processed=False, created_at=2025-06-01 09:16:46.942487+00:00, operation=INSERT, payload={'id': '7782cdbd-0d37-474e-b4ba-1e0d80968632', 'end_time': '2025-06-03T06:20:00+00:00', 'metadata': {'city': 'STOCKHOLM', 'phone': '0709561480', 'address': 'Kungsgatan 12', 'company': 'Testbolag AB', 'country': 'Sverige', 'subject': 'FaceTime: Daniel | Testbolag AB & Daniel | Kinnekulle Ledningsr√•dgivning AB (FaceTime)', 'location': 'FaceTime', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'ip_address': '172.226.49.46:63149', 'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Safari/605.1.15', 'online_link': 'facetime:0709561480', 'postal_code': '112 23', 'meeting_length': 20}, 'contact_id': 'ff5d1a4c-08b0-49be-8601-86f022228c88', 'created_at': '2025-06-01T09:16:46.613+00:00', 'start_time': '2025-06-03T06:00:00+00:00', 'updated_at': '2025-06-01T09:16:46.613+00:00', 'meeting_type': 'facetime', 'booking_email': 'daniel.kallberg@mac.com'}, booking_id=7782cdbd-0d37-474e-b4ba-1e0d80968632
    - id=a7b398cc-3de3-4ab0-8505-53a309c68126, table_name=bookings, record_id=7782cdbd-0d37-474e-b4ba-1e0d80968632, change_type=INSERT, direction=cloud_to_local, processed=False, created_at=2025-06-01 09:16:46.945000+00:00, operation=None, payload=None, booking_id=7782cdbd-0d37-474e-b4ba-1e0d80968632

üìÅ Tabell: contact
  ‚Ä¢ metadata (jsonb)
  ‚Ä¢ created_at (timestamp with time zone)
  ‚Ä¢ id (uuid)
  ‚Ä¢ updated_at (timestamp with time zone)
  ‚Ä¢ booking_email (text)
  ‚Ä¢ email (text)
  üîë [p] contact_pkey: PRIMARY KEY (id)
  üß™ Topp 5 rader:
    - metadata={'city': 'STOCKHOLM', 'phone': '0709561480', 'address': 'Kungsgatan 12', 'company': 'Testbolag AB', 'country': 'Sverige', 'last_name': 'K√§llberg', 'first_name': 'Daniel', 'postal_code': '112 23'}, created_at=2025-06-01 09:13:13.013623+00:00, id=ff5d1a4c-08b0-49be-8601-86f022228c88, booking_email=daniel.kallberg@mac.com, updated_at=2025-06-01 09:13:13.013623+00:00, email=daniel.kallberg@mac.com

