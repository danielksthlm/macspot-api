ğŸ“‚ KODTRÃ„D
==========
â”œâ”€â”€ bookings
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ getavailableslots
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ meeting_types
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ refreshCalendarOrigins
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ refreshTravelTimes
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ request_verification
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ calendar
â”‚   â”‚   â”œâ”€â”€ appleCalendar.js
â”‚   â”‚   â”œâ”€â”€ getMsToken.js
â”‚   â”‚   â”œâ”€â”€ msGraph.js
â”‚   â”‚   â”œâ”€â”€ resolveOrigin.js
â”‚   â”‚   â”œâ”€â”€ zoomClient.js
â”‚   â”œâ”€â”€ config
â”‚   â”‚   â”œâ”€â”€ settingsLoader.js
â”‚   â”‚   â”œâ”€â”€ verifySettings.js
â”‚   â”œâ”€â”€ db
â”‚   â”‚   â”œâ”€â”€ pgPool.js
â”‚   â”œâ”€â”€ maps
â”‚   â”‚   â”œâ”€â”€ appleMaps.js
â”‚   â”‚   â”œâ”€â”€ resolveTravelTime.js
â”‚   â”‚   â”œâ”€â”€ returnTravelVerifier.js
â”‚   â”œâ”€â”€ notification
â”‚   â”‚   â”œâ”€â”€ sendMail.js
â”‚   â”œâ”€â”€ slots
â”‚   â”‚   â”œâ”€â”€ slotEngine.js
â”‚   â”œâ”€â”€ utils
â”‚   â”‚   â”œâ”€â”€ debugLogger.js
â”œâ”€â”€ tracking
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ validate_contact
â”‚   â”œâ”€â”€ index.js
â”œâ”€â”€ verify_token
â”‚   â”œâ”€â”€ index.js
==========

====================
ğŸ“„ Fil: meeting_types/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 19:37:45
ğŸ“ Antal rader: 47
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 1 rader (2.1%)
ğŸ“¥ Imports: 2 â€“ ["const pool = require('../shared/db/pgPool');", "const { getSettings } = require('../shared/config/settingsLoader');"]
ğŸ” LÃ¤ngsta funktion: 7 rader
ğŸ§  KomplexitetspoÃ¤ng: 3
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const pool = require('../shared/db/pgPool');
const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, req) {
  const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
  for (const key of requiredEnv) {
    if (!process.env[key]) {
      context.log.error(`Missing environment variable: ${key}`);
      context.res = {
        status: 500,
        body: { error: `Missing environment variable: ${key}` }
      };
      return;
    }
  }

  try {
    const settings = await getSettings(context);

    const rawTypes = settings['meeting_types'];
    const meetingTypes = Array.isArray(rawTypes) ? rawTypes.map(t => t.toLowerCase()) : [];
    const lengths = {
      zoom: settings['default_meeting_length_digital'],
      facetime: settings['default_meeting_length_digital'],
      teams: settings['default_meeting_length_digital'],
      atclient: settings['default_meeting_length_atclient'],
      atoffice: settings['default_meeting_length_atoffice']
    };

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        types: meetingTypes,
        lengths
      })
    };
  } catch (error) {
    context.log.error('Database query failed:', error);
    context.res = {
      status: 500,
      body: { error: error.message }
    };
  } finally {
    // pool.end() tas bort â€“ vi Ã¥teranvÃ¤nder en delad pool mellan anrop
  }
};
END: index.js

====================
ğŸ“„ Fil: validate_contact/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-06-24 17:51:09
ğŸ“ Antal rader: 208
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 6 rader (2.9%)
ğŸ“¥ Imports: 3 â€“ ["const { getSettings } = require('../shared/config/settingsLoader');", "const pool = require('../shared/db/pgPool');", "const { v4: uuidv4 } = require('uuid');"]
ğŸ” LÃ¤ngsta funktion: 1 rader
ğŸ§  KomplexitetspoÃ¤ng: 29
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const { getSettings } = require('../shared/config/settingsLoader');
const pool = require('../shared/db/pgPool');
const { v4: uuidv4 } = require('uuid');

module.exports = async function (context, req) {
  try {
    const email = req.body?.email || req.query?.email;
    const meeting_type = req.body?.meeting_type || req.query?.meeting_type;

    if (process.env.DEBUG === 'true') {
      context.log.info('ğŸ›  DEBUG MODE ENABLED');
    }

    if (process.env.DEBUG === 'true') {
      context.log.info('ğŸ“¥ validate_contact triggered with:', { email, meeting_type });
    }

    if (!email || !meeting_type) {
      context.res = { status: 400, body: { error: "email and meeting_type are required" } };
      return;
    }

    const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
    for (const key of requiredEnv) {
      if (!process.env[key]) throw new Error(`Missing environment variable: ${key}`);
    }

    const contactRes = await pool.query(`
      SELECT c.*, ccr.id AS ccrelation_id, ccr.metadata AS ccrelation_metadata
      FROM contact c
      JOIN ccrelation ccr ON c.id = ccr.contact_id
      WHERE ccr.metadata->>'email' = $1
      LIMIT 1
    `, [email]);
    const contact = contactRes.rows[0];

    if ((req.body?.write_if_valid || req.query?.write_if_valid) && contact) {
      // Update existing contact if needed, merging metadata
      let metadataFromClient = req.body?.metadata;
      if (typeof metadataFromClient === 'string') {
        try {
          metadataFromClient = JSON.parse(metadataFromClient);
        } catch {
          metadataFromClient = {};
        }
      }
      if (typeof metadataFromClient === 'object' && metadataFromClient !== null) {
        // Fetch existing metadata
        const existing = await pool.query(`
          SELECT ccr.metadata FROM ccrelation ccr WHERE ccr.metadata->>'email' = $1
        `, [email]);
        const old = existing.rows[0]?.metadata || {};
        const merged = { ...old, ...metadataFromClient };

        // Update each key in metadata individually
        for (const [key, value] of Object.entries(merged)) {
          await pool.query(
            `UPDATE ccrelation
             SET metadata = jsonb_set(ccr.metadata, '{${key}}', to_jsonb($1), true),
                 updated_at = NOW()
             FROM ccrelation ccr
             WHERE ccr.metadata->>'email' = $2`,
            [value, email]
          );
        }
        context.log.info('âœï¸ Befintlig kontakt uppdaterad via validate_contact');
      }
    }

    if ((req.body?.write_if_valid || req.query?.write_if_valid) && !contact) {
      let metadataFromClient = req.body?.metadata;
      if (typeof metadataFromClient === 'string') {
        try {
          metadataFromClient = JSON.parse(metadataFromClient);
        } catch {
          metadataFromClient = {};
        }
      }
      if (typeof metadataFromClient === 'object' && metadataFromClient !== null) {
        metadataFromClient.origin = 'klrab.se';
        const newId = uuidv4();
        await pool.query(`
          INSERT INTO contact (id, metadata, created_at) VALUES ($1, $2, NOW())
        `, [newId, metadataFromClient]);

        const ccrelId = uuidv4();
        await pool.query(`
          INSERT INTO ccrelation (id, contact_id, company_id, role, metadata, created_at)
          VALUES ($1, $2, NULL, 'unknown', jsonb_build_object('email', $3), NOW())
        `, [ccrelId, newId, email]);

        context.log.info('âœ… Ny kontakt skapad via validate_contact');

        if (process.env.DEBUG === 'true') {
          context.log.info('ğŸ“¤ Svarar med status: created');
        }

        context.res = {
          status: 200,
          body: {
            status: "created",
            contact_id: newId,
            ccrelation_id: ccrelId
          }
        };
        return;
      }
    }

    let metadata = {};
    if (contact) {
      const refreshed = await pool.query(`
        SELECT ccr.metadata FROM ccrelation ccr WHERE ccr.metadata->>'email' = $1
      `, [email]);
      metadata = refreshed.rows[0]?.metadata || {};
    }

    if (typeof metadata === 'string') {
      try {
        metadata = JSON.parse(metadata);
      } catch {
        metadata = {};
      }
    }

    if (typeof metadata !== 'object' || metadata === null) metadata = {};

    if (process.env.DEBUG === 'true') {
      context.log.info('ğŸ§¾ Metadata:', metadata);
    }

    const METADATA_KEYS = ['first_name', 'last_name', 'phone', 'company', 'address', 'postal_code', 'city', 'country'];
    const fullMetadata = Object.fromEntries(
      METADATA_KEYS.map(key => [key, metadata[key] ?? ''])
    );
    metadata = fullMetadata;

    const settings = await getSettings(context);
    const digitalTypes = Array.isArray(settings.meeting_digital) ? settings.meeting_digital : [];
    const isDigital = digitalTypes.map(t => t.toLowerCase()).includes(meeting_type.toLowerCase()) || meeting_type === 'atoffice';

    // Dynamically get required fields from booking_settings
    const allRequired = settings.required_fields || {};
    const requiredFields = Array.isArray(allRequired[meeting_type]) ? allRequired[meeting_type] : [];
    // BerÃ¤kna alltid missingFields frÃ¥n metadata som just lÃ¤sts frÃ¥n databasen
    const missingFields = requiredFields.filter(
      field => !metadata[field] || typeof metadata[field] !== 'string' || metadata[field].trim() === ''
    );

    if (process.env.DEBUG === 'true') {
      context.log.info('ğŸ“Œ Saknade fÃ¤lt:', missingFields);
    }

    if (!contact) {
      if (process.env.DEBUG === 'true') {
        context.log.info('ğŸ“¤ Svarar med status: new_customer');
      }
      context.res = {
        status: 200,
        body: {
          status: "new_customer",
          missing_fields: missingFields
        }
      };
    } else if (missingFields.length > 0) {
      if (process.env.DEBUG === 'true') {
        context.log.info('ğŸ“¤ Svarar med status: incomplete');
      }
      context.res = {
        status: 200,
        body: {
          status: "incomplete",
          contact_id: contact.id,
          ccrelation_id: contact.ccrelation_id,
          missing_fields: missingFields,
          metadata
        }
      };
    } else {
      if (process.env.DEBUG === 'true') {
        context.log.info('ğŸ“¤ Svarar med status: existing_customer');
      }
      context.res = {
        status: 200,
        body: {
          status: "existing_customer",
          contact_id: contact.id,
          ccrelation_id: contact.ccrelation_id,
          metadata
        }
      };
    }

  } catch (error) {
    if (process.env.DEBUG === 'true') {
      context.log.error('âŒ Error during validate_contact:', {
        message: error.message,
        stack: error.stack
      });
    }
    context.res = {
      status: 500,
      body: { error: error.message, stack: error.stack }
    };
  } finally {
    // Poolen Ã¤r delad och Ã¥teranvÃ¤nds â€“ vi stÃ¤nger den inte hÃ¤r
  }
};
END: index.js

====================
ğŸ“„ Fil: getavailableslots/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-06-02 22:42:19
ğŸ“ Antal rader: 322
ğŸ§© Antal funktioner: 12
ğŸ’¬ KommentarstÃ¤ckning: 22 rader (6.8%)
ğŸ“¥ Imports: 8 â€“ ['const db = require("../shared/db/pgPool");', "const createMsGraphClient = require('../shared/calendar/msGraph');", "const createAppleClient = require('../shared/calendar/appleCalendar');", "const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');", "const { createDebugLogger } = require('../shared/utils/debugLogger');", "const { getSettings } = require('../shared/config/settingsLoader');", "const verifyBookingSettings = require('../shared/config/verifySettings');", "generateSlotChunks = require('../shared/slots/slotEngine').generateSlotChunks;"]
ğŸ” LÃ¤ngsta funktion: 19 rader
ğŸ§  KomplexitetspoÃ¤ng: 28
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const db = require("../shared/db/pgPool");
const createMsGraphClient = require('../shared/calendar/msGraph');
const createAppleClient = require('../shared/calendar/appleCalendar');
const { getAppleMapsAccessToken } = require('../shared/maps/appleMaps');
const { createDebugLogger } = require('../shared/utils/debugLogger');
const isDebug = process.env.DEBUG === 'true';
const { getSettings } = require('../shared/config/settingsLoader');
const verifyBookingSettings = require('../shared/config/verifySettings');
// console.log("âœ… getavailableslots/index.js laddad");

module.exports = async function (context, req) {
  const debugLog = (msg) => { if (isDebug) context.log(msg); };
  const appleClient = createAppleClient(context);
  // --- Apple-kalenderanropet startas parallellt, men invÃ¤ntas fÃ¶rst senare ---
  const testStart = new Date();
  const testEnd = new Date(Date.now() + 7 * 86400000);
  if (!(testStart instanceof Date) || isNaN(testStart)) {
    debugLog("â›” TEST Apple â€“ Ogiltigt testStart:", testStart);
  }
  if (!(testEnd instanceof Date) || isNaN(testEnd)) {
    debugLog("â›” TEST Apple â€“ Ogiltigt testEnd:", testEnd);
  }
  const appleEventsPromise = appleClient.fetchEventsByDateRange(testStart, testEnd).catch(err => {
    debugLog("âŒ Apple fetchEventsByDateRange FEL:", err.message);
    return [];
  });
  // --- Starta parallell laddning av instÃ¤llningar ---
  const settingsPromise = getSettings(context).catch(err => {
    debugLog("âŒ getSettings FEL:", err.message);
    return null;
  });
  const graphClient = createMsGraphClient();
  // context.log("ğŸ§ª Azure Function entrypoint nÃ¥dd");
  // context.log("ğŸ§ª graphClient.getEvent:", typeof graphClient.getEvent === "function");
  // context.log("ğŸ§ª appleClient.getEvent:", typeof appleClient.getEvent === "function");

  try {
    const client = await db.connect();

    if (!req || !req.body) {
      context.log("âŒ Ingen request body mottagen");
      context.res = { status: 400, body: { error: "Missing request body" } };
      return;
    }

    const { email, meeting_type, meeting_length, contact_id } = req.body;
    debugLog("âœ… Request body innehÃ¥ller: " + JSON.stringify({ email, meeting_type }));
    debugLog("âœ… Steg 1: Anropar DB med contact_id: " + contact_id);

    // Declare allBookings, days, and contact at the top-level scope of the outer try block
    let allBookings = [];
    let days = [];
    let contact;
    let bookingsByDay = {};

    // --- HÃ¤mta Apple-kalenderdata parallellt och lÃ¤gg in i bookingsByDay ---
    const testAppleRange = await appleEventsPromise;
    if (!testAppleRange || testAppleRange.length === 0) {
      debugLog("â›” [BEVIS] Apple CalDAV returnerade inga events â€“ mÃ¶jligt problem med API eller filter.");
    } else {
      debugLog(`âœ… [BEVIS] Apple CalDAV returnerade ${testAppleRange.length} event(s).`);
      const preview = testAppleRange.slice(0, 3);
      for (const ev of preview) {
        debugLog("ğŸ“† [BEVIS] Apple Event:", ev);
      }
    }
    if (Array.isArray(testAppleRange)) {
      for (const ev of testAppleRange) {
        if (ev.start && ev.end) {
          const dateKey = new Date(ev.start).toISOString().split('T')[0];
          if (!bookingsByDay[dateKey]) bookingsByDay[dateKey] = [];
          bookingsByDay[dateKey].push({
            start: new Date(ev.start).getTime(),
            end: new Date(ev.end).getTime()
          });
        }
      }
      debugLog("ğŸ“¥ Apple events insatta i bookingsByDay:");
      Object.entries(bookingsByDay).forEach(([date, events]) => {
        debugLog(`ğŸ“… ${date}: ${events.length} event(s)`);
        events.forEach(ev => {
          const start = new Date(ev.start).toISOString();
          const end = new Date(ev.end).toISOString();
          debugLog(`   â° ${start} â†’ ${end}`);
        });
      });
    }

    try {
      const contactRes = await client.query("SELECT * FROM contact WHERE id = $1", [contact_id]);
      contact = contactRes.rows[0];
      if (contact) {
        debugLog("âœ… Kontakt hittad: " + contact.id);
      } else {
        debugLog("âš ï¸ Ingen kontakt hittad fÃ¶r contact_id: " + contact_id);
      }
    } catch (err) {
      context.log("ğŸ”¥ DB-fel:", err.message);
      context.res = { status: 500, body: { error: "DB error", detail: err.message } };
      client.release();
      return;
    }

    debugLog("âœ… Steg 2: Laddar booking_settings...");

    let settings;
    try {
      settings = await settingsPromise;
      verifyBookingSettings(settings, context);
      debugLog("âœ… Steg 2a: InstÃ¤llningar laddade â€“ nycklar: " + Object.keys(settings).join(', '));
      debugLog("âœ… Steg 2b: InstÃ¤llningar verifierade");

      debugLog("âœ… Steg 3: Genererar days[] och laddar bokningar");

      const maxDays = settings.max_days_in_advance || 14;
      const today = new Date();
      days = Array.from({ length: maxDays }, (_, i) => {
        const date = new Date(today);
        date.setDate(today.getDate() + i);
        return date;
      });

      // ğŸ” Validera days[]
      days = days.filter((d, idx) => {
        const isValid = d instanceof Date && !isNaN(d);
        if (!isValid) {
          debugLog(`â›” Ogiltigt datum i days[${idx}]: ` + d);
        }
        return isValid;
      });

      if (days.length === 0) {
        context.log("â›” Alla datum i days[] var ogiltiga â€“ avbryter exekvering.");
        context.res = { status: 500, body: { error: "Inga giltiga datum kunde genereras" } };
        client.release();
        return;
      }

      const startDateStr = days[0].toISOString().split('T')[0];
      const endDateStr = days[days.length - 1].toISOString().split('T')[0];

      const startDate = days[0];
      const endDate = days[days.length - 1];
      if (!(startDate instanceof Date) || isNaN(startDate)) {
        debugLog("â›” Ogiltigt startDate skickat till fetchEventsByDateRange: " + startDate);
      }
      if (!(endDate instanceof Date) || isNaN(endDate)) {
        debugLog("â›” Ogiltigt endDate skickat till fetchEventsByDateRange: " + endDate);
      }

      const allBookingsRes = await client.query(
        'SELECT start_time, end_time, meeting_type FROM bookings WHERE start_time::date >= $1 AND start_time::date <= $2',
        [startDateStr, endDateStr]
      );
      debugLog("ğŸ”¢ Antal bokningar hÃ¤mtade: " + allBookingsRes.rows.length);

      allBookings = allBookingsRes.rows.map(b => ({
        start: new Date(b.start_time).getTime(),
        end: new Date(b.end_time).getTime(),
        date: new Date(b.start_time).toISOString().split('T')[0],
        meeting_type: b.meeting_type
      }));

      for (const booking of allBookings) {
        if (!bookingsByDay[booking.date]) bookingsByDay[booking.date] = [];
        bookingsByDay[booking.date].push({ start: booking.start, end: booking.end });
      }

      debugLog("âœ… Steg 3: Dagar genererade och bokningar summerade");

    } catch (err) {
      context.log("ğŸ”¥ Fel vid laddning/verifiering av settings:", err.message);
      context.res = { status: 500, body: { error: "Settings error", detail: err.message } };
      client.release();
      return;
    }

    let generateSlotChunks;
    try {
      generateSlotChunks = require('../shared/slots/slotEngine').generateSlotChunks;
      debugLog("âœ… generateSlotChunks import ok");
    } catch (importErr) {
      context.log("âŒ Misslyckades importera generateSlotChunks:", importErr.message);
      context.res = { status: 500, body: { error: "Import error", detail: importErr.message } };
      client.release();
      return;
    }

    const weeklyMinutesByType = {};
    const weekKey = (date) => {
      const start = new Date(date);
      start.setUTCHours(0, 0, 0, 0);
      start.setUTCDate(start.getUTCDate() - start.getUTCDay());
      return start.toISOString().split('T')[0];
    };
    for (const b of allBookings) {
      const type = b.meeting_type || 'unknown';
      const week = weekKey(b.start);
      weeklyMinutesByType[type] = weeklyMinutesByType[type] || {};
      weeklyMinutesByType[type][week] = (weeklyMinutesByType[type][week] || 0) + (b.end - b.start) / 60000;
    }

    const debugHelper = createDebugLogger(context);

    const appleMapsToken = await getAppleMapsAccessToken(context);
    context.accessToken = appleMapsToken;
    if (appleMapsToken) {
      debugLog("âœ… Apple Maps token hÃ¤mtad â€“ lÃ¤ngd: " + appleMapsToken.length);
    } else {
      debugLog("âš ï¸ Apple Maps token saknas â€“ fallback kommer att anvÃ¤ndas");
    }

    // Riktigt anrop till generateSlotChunks
    const slotGroupPicked = {};
    const startSlotGen = Date.now();
    const chosenSlotsResult = await generateSlotChunks({
      days,
      context,
      contact,
      contact_id,
      meeting_type,
      meeting_length,
      bookingsByDay,
      weeklyMinutesByType,
      settings,
      graphClient,
      appleClient,
      travelCache: new Map(),
      accessToken: appleMapsToken,
      timezone: settings.timezone || 'Europe/Stockholm',
      debugHelper,
      client: client,
      slotGroupPicked,
      logSlotContext: true
    });
    const durationMs = Date.now() - startSlotGen;
    debugLog(`â±ï¸ Slotgenerering klar pÃ¥ ${durationMs} ms`);
    debugLog("âœ… generateSlotChunks kÃ¶rdes utan fel");
    debugLog("ğŸ” Efter generateSlotChunks â€“ dags att filtrera FM/EM");

    const slots = Array.isArray(chosenSlotsResult?.chosenSlots) ? chosenSlotsResult.chosenSlots : [];
    const fallbackCount = slots.filter(s => s.source === 'fallback').length;
    const appleCount = slots.filter(s => s.source === 'apple').length;

    // Flyttat block fÃ¶r fm/em loggning precis fÃ¶re slutlogg:
    const fm = slots.filter(s => s.slot_part === 'fm');
    const em = slots.filter(s => s.slot_part === 'em');

    debugLog("ğŸ“‹ TillgÃ¤ngliga FM-slots:\n" + fm.map(s => `â˜€ï¸ ${s.slot_local} (${s.slot_iso}) â€“ score: ${s.score}`).join('\n'));
    debugLog("ğŸ“‹ TillgÃ¤ngliga EM-slots:\n" + em.map(s => `ğŸŒ™ ${s.slot_local} (${s.slot_iso}) â€“ score: ${s.score}`).join('\n'));
    debugHelper.logSlotsSummary(slots);

    // ğŸ“‹ Logga tydlig lista pÃ¥ tillgÃ¤ngliga slots (en rad per slot)
    if (isDebug) {
      const uniqueSlotLog = slots.map(s => `${s.slot_local} (${s.weekday}, ${s.slot_part}, score: ${s.score})`).join('\n');
      debugLog("ğŸ“‹ TillgÃ¤ngliga slots:\n" + uniqueSlotLog);
    }

    debugLog("ğŸ¯ Slut pÃ¥ exekvering av getavailableslots");
    const finalSlots = Array.isArray(chosenSlotsResult?.chosenSlots) ? chosenSlotsResult.chosenSlots : [];
    const finalApple = finalSlots.filter(s => s.source === 'apple').length;
    const finalFallback = finalSlots.filter(s => s.source === 'fallback').length;
    debugLog(`ğŸ‰ Slutlig summering: ${finalSlots.length} slots, ${finalApple} Apple Maps, ${finalFallback} fallback`);
    
    // Moved this debugLog line here, just before sending response:
    debugLog("âœ… getavailableslots/index.js â€“ HELA FUNKTIONEN KÃ–RDES UTAN FEL");
    debugLog("ğŸ“‹ getavailableslots â€“ sista logg fÃ¶re response.");
    context.log("âœ… getavailableslots â€“ context.res sÃ¤tts nu, detta Ã¤r sista logg.");

    // context.log("ğŸ“¦ Slotresultat:", JSON.stringify(chosenSlotsResult?.chosenSlots || [], null, 2));

    // if (chosenSlotsResult?.chosenSlots?.length) {
    //   for (const slot of chosenSlotsResult.chosenSlots) {
    //     const slotHour = new Date(slot.slot_iso).getUTCHours();
    //     context.log(`ğŸ“† Slot: ${slot.slot_iso}, Part: ${slot.slot_part}, Origin: ${slot.origin}, Source: ${slot.source}`);
    //   }
    // }

    debugLog(`ğŸ“Š Slot-kÃ¤llor: ${appleCount} med Apple Maps, ${fallbackCount} med fallback`);

    // context.log("ğŸ“¤ Response skickas med antal slots:", (chosenSlotsResult?.chosenSlots || []).length);
    debugLog("â³ PÃ¥ vÃ¤g att returnera response...");
    try {
      context.res = {
        status: 200,
        body: {
          message: "âœ… getavailableslots Ã¤r kontaktbar och fungerar i full version",
          received: { email, meeting_type, meeting_length },
          travel_stats: {
            apple_count: appleCount,
            fallback_count: fallbackCount
          },
          slots: Array.isArray(chosenSlotsResult?.chosenSlots)
            ? chosenSlotsResult.chosenSlots.map(slot => ({
                ...slot,
                score: slot.score ?? null
              }))
            : []
        }
      };
      client.release();
      debugLog("âœ… Databasanslutning slÃ¤ppt");
      debugLog("âœ… client.release() lyckades");
      debugLog("ğŸ Funktion getavailableslots/index.js avslutad helt utan fel");
      context.log("âœ… Azure Function getavailableslots har returnerat response.");
    } catch (err) {
      debugLog("âŒ Fel vid response/build/release: " + err.message);
      context.res = {
        status: 500,
        body: { error: "Internal error after slot gen", detail: err.message }
      };
      context.log("âœ… Azure Function getavailableslots har returnerat response.");
    }


  } catch (err) {
    context.log("ğŸ”¥ FEL i funktion:", err.message);
    context.res = { status: 500, body: { error: err.message } };
  }
  // (Flyttad summering och slutloggar till rÃ¤tt plats)
  context.log("ğŸ§ª SLUTPUNKT: NÃ¥dde allra sista raden");
};
END: index.js

====================
ğŸ“„ Fil: refreshCalendarOrigins/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 19:34:31
ğŸ“ Antal rader: 36
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 4 â€“ ["const { DateTime } = require('luxon');", "const pool = require('../shared/db/pgPool');", "const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');", "const { getSettings } = require('../shared/config/settingsLoader');"]
ğŸ” LÃ¤ngsta funktion: 4 rader
ğŸ§  KomplexitetspoÃ¤ng: 1
ğŸ§ª TODO/FIXME: 0
====================
START: index.js


const { DateTime } = require('luxon');
const pool = require('../shared/db/pgPool');
const { resolveOriginAddress } = require('../shared/calendar/resolveOrigin');

const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const today = new Date();
  const settings = await getSettings(context);
  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const date = new Date();
    date.setDate(today.getDate() + i);
    return date;
  });

  context.log(`ğŸ” KÃ¶r refreshCalendarOrigins fÃ¶r ${days.length} dagar`);

  for (const date of days) {
    const slotTime = DateTime.fromJSDate(date).set({ hour: 10, minute: 0 }).toJSDate();
    const travelStart = new Date(slotTime.getTime() - (settings.fallback_travel_time_minutes || 20) * 60000);

    await resolveOriginAddress({
      eventId: slotTime.toISOString(),
      calendarId: 'system-refresh',
      pool,
      context,
      fallbackOrigin: settings.default_home_address,
      settings
    });
  }

  context.log('âœ… refreshCalendarOrigins fÃ¤rdig');
};
END: index.js

====================
ğŸ“„ Fil: refreshTravelTimes/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-22 19:35:16
ğŸ“ Antal rader: 112
ğŸ§© Antal funktioner: 4
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 6 â€“ ["const { DateTime } = require('luxon');", "const fetch = require('node-fetch');", "const pool = require('../shared/db/pgPool');", "const { getSettings } = require('../shared/config/settingsLoader');", "const jwt = require('jsonwebtoken');", "const fs = require('fs');"]
ğŸ” LÃ¤ngsta funktion: 10 rader
ğŸ§  KomplexitetspoÃ¤ng: 8
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const { DateTime } = require('luxon');
const fetch = require('node-fetch');
const pool = require('../shared/db/pgPool');
const { getSettings } = require('../shared/config/settingsLoader');

module.exports = async function (context, myTimer) {
  const settings = await getSettings(context);
  const fallbackTravelTime = settings.fallback_travel_time_minutes || 20;
  const today = new Date();
  const timezone = settings.timezone || 'Europe/Stockholm';

  const maxDays = settings.max_days_in_advance || 14;
  const days = Array.from({ length: maxDays }, (_, i) => {
    const d = new Date(today);
    d.setDate(today.getDate() + i);
    return d;
  });

  const destinations = [settings.default_office_address];
  const origins = [settings.default_home_address];

  for (const day of days) {
    for (const hour of [10, 14]) {
      const slotTime = DateTime.fromJSDate(day).set({ hour, minute: 0 }).toJSDate();

      for (const from of origins) {
        for (const to of destinations) {
          const hourKey = slotTime.getUTCHours();
          const key = `${from}|${to}|${hourKey}`;

          const res = await pool.query(
            `SELECT 1 FROM travel_time_cache
             WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
            [from, to, hourKey]
          );

          if (res.rows.length > 0) {
            context.log(`âš¡ Redan i cache: ${key}`);
            continue;
          }

          context.log(`â³ BerÃ¤knar restid: ${key}`);
          try {
            const token = await getAppleMapsAccessToken(context);
            if (!token) throw new Error('Apple Maps-token saknas');

            const url = new URL('https://maps-api.apple.com/v1/directions');
            url.searchParams.append('origin', from);
            url.searchParams.append('destination', to);
            url.searchParams.append('transportType', 'automobile');
            url.searchParams.append('departureTime', slotTime.toISOString());

            const response = await fetch(url.toString(), {
              headers: { Authorization: `Bearer ${token}` }
            });
            const data = await response.json();

            const minutes = Math.round((data.routes?.[0]?.durationSeconds || fallbackTravelTime * 60) / 60);
            await pool.query(
              `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
               VALUES ($1, $2, $3, $4)
               ON CONFLICT (from_address, to_address, hour)
               DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes`,
              [from, to, hourKey, minutes]
            );
            context.log(`âœ… Sparad restid: ${minutes} min (${key})`);
          } catch (err) {
            context.log(`âš ï¸ Misslyckades hÃ¤mta/spara restid fÃ¶r ${key}: ${err.message}`);
          }
        }
      }
    }
  }

  context.log('âœ… refreshTravelTimes fÃ¤rdig');
};

async function getAppleMapsAccessToken(context) {
  try {
    const jwt = require('jsonwebtoken');
    const fs = require('fs');

    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n') ||
                       fs.readFileSync(process.env.APPLE_MAPS_KEY_PATH, 'utf8');

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context.log('âš ï¸ Misslyckades hÃ¤mta Apple Maps token:', err.message);
    return null;
  }
}
END: index.js

====================
ğŸ“„ Fil: shared/calendar/appleCalendar.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-30 15:28:53
ğŸ“ Antal rader: 198
ğŸ§© Antal funktioner: 8
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 3 â€“ ['const fetch = require("node-fetch");', 'const xml2js = require("xml2js");', 'const { DateTime } = require("luxon");']
ğŸ” LÃ¤ngsta funktion: 8 rader
ğŸ§  KomplexitetspoÃ¤ng: 27
ğŸ§ª TODO/FIXME: 0
====================
START: appleCalendar.js
const fetch = require("node-fetch");
const xml2js = require("xml2js");
const { DateTime } = require("luxon");

function createAppleClient(context) {
  const debugLog = (...args) => { if (process.env.DEBUG === 'true') context.log(...args); };
  const DEBUG = process.env.DEBUG === 'true';

  async function getEvent(calendarId, eventId) {
    const caldavUrl = process.env.CALDAV_CALENDAR_URL;
    const username = process.env.CALDAV_USER;
    const password = process.env.CALDAV_PASSWORD;

    if (!caldavUrl || !username || !password) {
      if (DEBUG) context.log("âš ï¸ Missing CalDAV credentials");
      return null;
    }

    try {
      const eventUrl = `${caldavUrl.replace(/\/$/, '')}/${eventId}.ics`;
      const icsRes = await fetch(eventUrl, {
        method: "GET",
        headers: {
          "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64")
        }
      });

      if (!icsRes.ok) {
        if (DEBUG) context.log(`âš ï¸ Misslyckades hÃ¤mta ICS-fil: ${eventUrl}`);
        return null;
      }

      const icsText = await icsRes.text();
      const locationMatch = icsText.match(/LOCATION:(.*)/);
      const endTimeMatch = icsText.match(/DTEND(?:;[^:]*)?:(.*)/);

      const location = locationMatch ? locationMatch[1].trim() : null;
      const endTime = endTimeMatch ? endTimeMatch[1].trim() : null;

      if (location && endTime) {
        if (DEBUG) context.log("âœ… Hittade event med location och endTime:", { location, endTime });
        return { location, endTime };
      }

      if (DEBUG) context.log("âš ï¸ Inget event med bÃ¥de location och endTime hittades.");
      return null;

    } catch (err) {
      if (DEBUG) context.log("âš ï¸ Error i getEvent():", err.message);
      return null;
    }
  }

  async function fetchEventsByDateRange(startDate, endDate) {
    const caldavUrl = process.env.CALDAV_CALENDAR_URL;
    const username = process.env.CALDAV_USER;
    const password = process.env.CALDAV_PASSWORD;


    if (!caldavUrl || !username || !password) {
      if (DEBUG) context.log("âš ï¸ Missing CalDAV credentials");
      return [];
    }

    const parseDate = (d) => {
      if (d instanceof Date) return DateTime.fromJSDate(d);
      const parsed = new Date(d);
      if (!isNaN(parsed.getTime())) return DateTime.fromJSDate(parsed);
      return DateTime.invalid("Ogiltigt datumformat");
    };
    const startIso = parseDate(startDate).toUTC().toFormat("yyyyLLdd'T'HHmmss'Z'");
    const endIso = parseDate(endDate).toUTC().toFormat("yyyyLLdd'T'HHmmss'Z'");
    const xmlBody = `
    <C:calendar-query xmlns:C="urn:ietf:params:xml:ns:caldav"
                      xmlns:D="DAV:">
      <D:prop>
        <D:getetag/>
        <C:calendar-data/>
      </D:prop>
      <C:filter>
        <C:comp-filter name="VCALENDAR">
          <C:comp-filter name="VEVENT">
            <C:time-range start="${startIso}" end="${endIso}"/>
          </C:comp-filter>
        </C:comp-filter>
      </C:filter>
    </C:calendar-query>`;

    try {
      const res = await fetch(caldavUrl, {
        method: "REPORT",
        headers: {
          "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64"),
          "Depth": "1",
          "Content-Type": "application/xml"
        },
        body: xmlBody
      });

      const xml = await res.text();

      if (!xml || xml.length < 20) {
        if (DEBUG) context.log("âš ï¸ XML-svar verkar tomt â€“ avbryter parsing.");
        return [];
      }

      const parsed = await xml2js.parseStringPromise(xml, {
        explicitArray: false,
        tagNameProcessors: [xml2js.processors.stripPrefix],
        mergeAttrs: true
      });

      const responses = parsed?.['multistatus']?.['response'] || parsed?.['D:multistatus']?.['D:response'];

      if (!responses) {
        if (DEBUG) context.log("âš ï¸ Inga responses hittades i CalDAV-XML");
        return [];
      }

      const items = Array.isArray(responses) ? responses : [responses];
      const targetPath = new URL(process.env.CALDAV_CALENDAR_URL.trim()).pathname;

      const filteredItems = items; // TEMP: inaktiverat filter fÃ¶r test

      const results = [];

      for (const item of filteredItems) {
        let calendarData = item?.['propstat']?.['prop']?.['calendar-data'] || item?.['D:propstat']?.['D:prop']?.['C:calendar-data'];

        if (calendarData && typeof calendarData === 'object' && '_' in calendarData) {
          calendarData = calendarData._;
        }

        const href = item['href'] || item['D:href'];
        if (!calendarData || !calendarData.includes('VEVENT')) {
          const fullUrl = `${caldavUrl.replace(/\/$/, '')}${href}`;
          const fallbackRes = await fetch(fullUrl, {
            method: "GET",
            headers: {
              "Authorization": "Basic " + Buffer.from(`${username}:${password}`).toString("base64")
            }
          });
          calendarData = await fallbackRes.text();
          if (!calendarData.includes("VEVENT")) {
            continue;
          }
        }

        const vevents = Array.from(calendarData.matchAll(/BEGIN:VEVENT[\S\s]*?END:VEVENT/g));
        for (const vevent of vevents) {
          const v = vevent[0];
          if (DEBUG) context.log("ğŸ§ª VEVENT RAW:\n", v);
          const summary = v.match(/SUMMARY:(.*)/)?.[1]?.trim() ?? "â€“";
          const dtstart = v.match(/DTSTART(?:;[^:]*)?:(\d{8}(T\d{6})?)/)?.[1]?.trim() ?? "â€“";
          const dtend = v.match(/DTEND(?:;[^:]*)?:(\d{8}(T\d{6})?)/)?.[1]?.trim() ?? "â€“";
          const location = v.match(/LOCATION:(.*)/)?.[1]?.trim() ?? "â€“";
          const uid = v.match(/UID:(.*)/)?.[1]?.trim() ?? "â€“";

          const parseToEpoch = (dt) => {
            const clean = dt.replace(/^(\d{8})$/, '$1T000000');
            return DateTime.fromFormat(clean, "yyyyLLdd'T'HHmmss", { zone: "UTC" })
              .setZone("Europe/Stockholm")
              .toMillis();
          };

          const start = parseToEpoch(dtstart);
          const end = parseToEpoch(dtend);

          results.push({ summary, dtstart, dtend, location, uid, start, end });
          if (DEBUG) context.log("âœ… Parsed Apple Event:", { summary, dtstart, dtend, location, uid });
        }
      }

      results.sort((a, b) => {
        const aTime = new Date(a.dtstart.replace(/^(\d{8})$/, '$1T000000')).getTime();
        const bTime = new Date(b.dtstart.replace(/^(\d{8})$/, '$1T000000')).getTime();
        return aTime - bTime;
      });


      const now = DateTime.local().setZone("Europe/Stockholm");
      const upcoming = results.filter(ev => {
        const dtRaw = ev.dtstart.replace(/^(\d{8})$/, '$1T000000');
        const dt = DateTime.fromFormat(dtRaw, "yyyyLLdd'T'HHmmss", { zone: "UTC" }).setZone("Europe/Stockholm");
        return dt > now;
      });

      return upcoming;
    } catch (err) {
      if (DEBUG) context.log("âŒ Fel i fetchEventsByDateRange try/catch:", err.stack || err.message);
      return [];
    }
  }

  return { getEvent, fetchEventsByDateRange };
}

module.exports = (context) => createAppleClient(context || { log: console.log });
END: appleCalendar.js

====================
ğŸ“„ Fil: shared/calendar/getMsToken.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-30 11:29:41
ğŸ“ Antal rader: 57
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 12 rader (21.1%)
ğŸ“¥ Imports: 2 â€“ ["require('dotenv').config(); // Ladda miljÃ¶variabler frÃ¥n .env", "const fetch = require('node-fetch');"]
ğŸ” LÃ¤ngsta funktion: 4 rader
ğŸ§  KomplexitetspoÃ¤ng: 5
ğŸ§ª TODO/FIXME: 0
====================
START: getMsToken.js
require('dotenv').config(); // Ladda miljÃ¶variabler frÃ¥n .env
const fetch = require('node-fetch');

// console.log("ğŸ§ª getMsToken.js laddades");

module.exports = async function getMsToken(context = { log: console.log }) {
  // context.log("ğŸ§ª getMsToken() anropades â€“ initierar tokenhÃ¤mtning");
  // context.log("ğŸ” MS365_CLIENT_ID:", process.env.MS365_CLIENT_ID?.slice(0, 8));
  // context.log("ğŸ” MS365_CLIENT_SECRET:", process.env.MS365_CLIENT_SECRET ? "[satt]" : "[saknas]");
  // context.log("ğŸ” MS365_TENANT_ID:", process.env.MS365_TENANT_ID?.slice(0, 8));
  if (!process.env.MS365_CLIENT_ID || !process.env.MS365_CLIENT_SECRET || !process.env.MS365_TENANT_ID) {
    context.log("âŒ En eller flera miljÃ¶variabler fÃ¶r MS Graph saknas.");
    return null;
  }
  try {
    const tokenEndpoint = `https://login.microsoftonline.com/${process.env.MS365_TENANT_ID}/oauth2/v2.0/token`;
    const params = new URLSearchParams();
    params.append('client_id', process.env.MS365_CLIENT_ID);
    params.append('client_secret', process.env.MS365_CLIENT_SECRET);
    params.append('scope', 'https://graph.microsoft.com/.default');
    params.append('grant_type', 'client_credentials');

    // context.log("ğŸ“¡ FÃ¶rsÃ¶ker hÃ¤mta token frÃ¥n:", tokenEndpoint);

    const res = await fetch(tokenEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params
    });

    // context.log(`ğŸ“¬ Response status: ${res.status}`);

    if (!res.ok) {
      const errorText = await res.text();
      context.log(`âš ï¸ TokenhÃ¤mtning misslyckades: ${res.status} ${res.statusText}\nSvar: ${errorText}`);
      context.log("ğŸªµ FullstÃ¤ndigt svar frÃ¥n Graph:", errorText);
      return null;
    }

    const data = await res.json();
    return data.access_token;
  } catch (err) {
    context.log(`âš ï¸ TokenhÃ¤mtning fel: ${err.message}`);
    return null;
  }
};

if (require.main === module) {
  (async () => {
    const token = await module.exports();
    // if (token) {
    //   console.log("âœ… Token hÃ¤mtad:", token.slice(0, 20) + "...");
    // } else {
    //   console.log("âŒ Kunde inte hÃ¤mta token.");
    // }
  })();
}
END: getMsToken.js

====================
ğŸ“„ Fil: shared/calendar/msGraph.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-06-01 20:02:44
ğŸ“ Antal rader: 204
ğŸ§© Antal funktioner: 7
ğŸ’¬ KommentarstÃ¤ckning: 7 rader (3.4%)
ğŸ“¥ Imports: 5 â€“ ['const { Client } = require("@microsoft/microsoft-graph-client");', 'require("isomorphic-fetch");', 'const fetch = require("node-fetch");', 'const { loadSettings } = require("../config/settingsLoader");', 'const getMsToken = require("./getMsToken");']
ğŸ” LÃ¤ngsta funktion: 6 rader
ğŸ§  KomplexitetspoÃ¤ng: 17
ğŸ§ª TODO/FIXME: 0
====================
START: msGraph.js
const { Client } = require("@microsoft/microsoft-graph-client");
require("isomorphic-fetch");
const DEBUG = process.env.DEBUG === 'true';
const fetch = require("node-fetch");
const { loadSettings } = require("../config/settingsLoader");
const getMsToken = require("./getMsToken");

function createMsGraphClient(context) {

  const silentLog = context && context.log ? (...args) => context.log("[ğŸ“¡ Graph]", ...args) : console.log;

  async function getEvent(calendarId, eventId) {
    try {
      if (!calendarId || !eventId) {
        return null;
      }

      const authToken = await getMsToken({ log: { log: silentLog } });
      if (!authToken) {
        throw new Error("ğŸ›‘ TokenhÃ¤mtning misslyckades â€“ accessToken saknas. Funktion avbryts.");
      }
      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      try {
        const result = await client
          .api(`/users/${calendarId}/events/${encodeURIComponent(eventId)}`)
          .select("subject,location,start,end")
          .get();

        const location = result.location?.displayName || null;
        const endTime = result.end?.dateTime || null;

        return { location, endTime };
      } catch (err) {
        if (err.statusCode === 404) {
          return { location: null, endTime: null, deleted: true };
        }
        return null;
      }
    } catch (err) {
      return null;
    }
  }

  async function listUpcomingEvents(daysAhead) {
    try {
      if (!daysAhead) {
        const settings = await loadSettings(null);
        daysAhead = settings.max_days_in_advance || 90;
      }
      const calendarId = process.env.MS365_USER_EMAIL;
      if (!calendarId) throw new Error("âŒ MS365_USER_EMAIL saknas");

      const authToken = await getMsToken({ log: { log: silentLog } });
      if (!authToken) {
        throw new Error("ğŸ›‘ TokenhÃ¤mtning misslyckades â€“ accessToken saknas. Funktion avbryts.");
      }
      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const now = new Date();
      const startDate = now.toISOString();
      const endDate = new Date(now.getTime() + daysAhead * 86400000).toISOString();

      const response = await client
        .api(`/users/${calendarId}/calendarView?startDateTime=${startDate}&endDateTime=${endDate}`)
        .top(100)
        .select("subject,start,end,id")
        .orderby("start/dateTime ASC")
        .get();

      const upcoming = response.value.filter(ev => new Date(ev.start.dateTime) > new Date());
      return upcoming.map(ev => ({
        subject: ev.subject,
        start: ev.start.dateTime,
        end: ev.end?.dateTime || null,
        id: ev.id
      }));
    } catch (err) {
      return [];
    }
  }

  async function createEvent(input) {
    // silentLog("ğŸš¨ createEvent() start â€“ raw input:", input);
    if (!input || typeof input !== "object") {
      console.log("âŒ createEvent() fick ogiltig input:", input);
      return null;
    }
    try {
      const { start, end, subject, location, attendees, meetingType } = input;
      // silentLog("ğŸš¦ createEvent() initierad fÃ¶r:", meetingType, "| calendarId:", process.env.MS365_USER_EMAIL);
      const calendarId = process.env.MS365_USER_EMAIL;
      if (!calendarId) throw new Error("âŒ MS365_USER_EMAIL saknas");

      const authToken = await getMsToken({ log: { log: silentLog } });
      // silentLog("ğŸ” TokenhÃ¤mtning gav:", authToken ? authToken.slice(0, 20) + "..." : "null");
      if (!authToken) throw new Error("ğŸ›‘ TokenhÃ¤mtning misslyckades");

      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const event = {
        subject: subject || "MÃ¶te",
        body: {
          contentType: "HTML",
          content: `Detta Ã¤r en inbjudan till mÃ¶te: ${subject || "MÃ¶te"}`
        },
        start: {
          dateTime: start,
          timeZone: "Europe/Stockholm"
        },
        end: {
          dateTime: end,
          timeZone: "Europe/Stockholm"
        },
        location: {
          displayName: location || "Online"
        },
        attendees: (attendees || []).map(email => ({
          emailAddress: { address: email },
          type: "required"
        })),
        allowNewTimeProposals: true
      };

      if (meetingType === "teams") {
        event.isOnlineMeeting = true;
        event.onlineMeetingProvider = "teamsForBusiness";
      }

      // Uppdaterat Graph-anrop fÃ¶r att skicka inbjudan direkt till mottagaren (utan sendUpdates)
      // silentLog("ğŸ“¤ Event som skickas till Graph:", JSON.stringify(event, null, 2));
      // silentLog("ğŸ›  createEvent() reached â€“ preparing to send to Graph...");
      const created = await client
        .api(`/users/${calendarId}/events`)
        .header('Prefer', 'outlook.timezone="Europe/Stockholm"')
        .post(event);
      // silentLog("ğŸ“¥ Graph API svar:", created);

      return {
        eventId: created?.id || null,
        onlineMeetingUrl: created?.onlineMeeting?.joinUrl || null,
        subject: created?.subject || null,
        location: created?.location?.displayName || null,
        body: created?.body || null,
        start: created?.start || null,
        end: created?.end || null,
        attendees: created?.attendees || null,
        webLink: created?.webLink || null
      };
    } catch (err) {
      silentLog("âŒ Graph createEvent error (full):", err.stack || err.toString());
      if (err.response) {
        const body = await err.response.text();
        silentLog("ğŸ“¡ Graph response error details:", body);
      }
      return null;
    }
  }

  async function sendEmailInvite({ to, subject, body }) {
    try {
      const senderEmail = process.env.MS365_USER_EMAIL;
      const authToken = await getMsToken({ log: { log: silentLog } });
      if (!authToken) throw new Error("âŒ Kunde inte hÃ¤mta Graph-token");

      const client = Client.init({
        authProvider: (done) => done(null, authToken)
      });

      const message = {
        message: {
          subject,
          body: {
            contentType: "HTML",
            content: body
          },
          toRecipients: [
            {
              emailAddress: {
                address: to
              }
            }
          ]
        },
        saveToSentItems: "true"
      };

      await client.api(`/users/${senderEmail}/sendMail`).post(message);
      return { status: "sent" };
    } catch (err) {
      return null;
    }
  }

  return { getEvent, listUpcomingEvents, createEvent, sendEmailInvite };
}

module.exports = createMsGraphClient;
END: msGraph.js

====================
ğŸ“„ Fil: shared/calendar/resolveOrigin.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-30 13:19:22
ğŸ“ Antal rader: 236
ğŸ§© Antal funktioner: 2
ğŸ’¬ KommentarstÃ¤ckning: 21 rader (8.9%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 2 rader
ğŸ§  KomplexitetspoÃ¤ng: 38
ğŸ§ª TODO/FIXME: 0
====================
START: resolveOrigin.js
/**
 * resolveOriginAddress
 * --------------------
 * HÃ¤mtar origin-adress fÃ¶r ett kalender-event frÃ¥n:
 * 1. Memory-cache
 * 2. PostgreSQL-cache (om SKIP_DB inte Ã¤r satt)
 * 3. MS Graph
 * 4. Apple Calendar
 * Fallback anvÃ¤nds vid miss.
 *
 * MiljÃ¶variabler:
 * - SKIP_DB=true  â†’ hoppar Ã¶ver all databaslogik (lÃ¤s/skriv)
 */
const memoryCache = {};

function cleanAddress(address) {
  return address.replace(/\n/g, ', ').replace(/\\,/g, ',').replace(/\+/g, ' ').trim();
}

async function resolveOriginAddress({ eventId, calendarId, pool, context, graphClient, appleClient, fallbackOrigin, settings, eventCache }) {
  const cacheKey = `${calendarId}:${eventId}`;
  const debugLog = (msg) => {
    if (process.env.DEBUG === 'true' && context?.log) context.log(msg);
  };
  debugLog(`ğŸ” resolveOriginAddress â†’ calendarId: ${calendarId}, eventId: ${eventId}`);
  const eventDateOnly = eventId.split('T')[0];

  const useCacheEvents = eventCache?.has(eventDateOnly);
  const cachedEvents = useCacheEvents ? eventCache.get(eventDateOnly) : null;

  if (memoryCache[cacheKey]) {
    // Provide originEndTime as well
    let originEndTime = null;
    if (memoryCache[cacheKey].originSource === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = memoryCache[cacheKey].originEndTime || null;
    }
    debugLog(`âœ… Hittade origin frÃ¥n cache: ${memoryCache[cacheKey].origin}`);
    return {
      origin: cleanAddress(memoryCache[cacheKey].origin),
      originSource: memoryCache[cacheKey].originSource,
      originEndTime
    };
  }


  // Try database cache first
  let dbRes;
  if (!process.env.SKIP_DB) {
    try {
      dbRes = await pool.query(
        'SELECT address, source, end_time FROM calendar_origin_cache WHERE event_date = $1',
        [eventDateOnly]
      );
      debugLog(`ğŸ“‚ DB-kontroll: Hittade ${dbRes?.rows?.length || 0} rader fÃ¶r ${eventDateOnly}`);
    } catch (err) {
      context.log(`âš ï¸ DB error in resolveOriginAddress: ${err.message}`);
    }
  }
  if (dbRes && dbRes.rows && dbRes.rows.length > 0) {
    // Special case: if source is fallback, return immediately
    if (dbRes.rows[0].source === 'fallback') {
      const originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
      memoryCache[cacheKey] = {
        origin: dbRes.rows[0].address,
        originSource: dbRes.rows[0].source,
        originEndTime
      };
      debugLog(`ğŸ›‘ DB-trÃ¤ff var fallback â€“ hoppar Ã¶vriga fÃ¶rsÃ¶k`);
      return {
        origin: cleanAddress(dbRes.rows[0].address),
        originSource: dbRes.rows[0].source,
        originEndTime
      };
    }
    let originEndTime = null;
    if (dbRes.rows[0].source === 'fallback') {
      originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
    } else {
      originEndTime = dbRes.rows[0].end_time || null;
    }
    memoryCache[cacheKey] = {
      origin: dbRes.rows[0].address,
      originSource: dbRes.rows[0].source,
      originEndTime: originEndTime
    };
    debugLog(`âœ… Hittade origin frÃ¥n DB: ${dbRes.rows[0].address}`);
    return {
      origin: cleanAddress(dbRes.rows[0].address),
      originSource: dbRes.rows[0].source,
      originEndTime
    };
  }
  debugLog(`ğŸ•³ï¸ Inget cachetrÃ¤ff i DB fÃ¶r ${eventDateOnly}`);

  let latestOrigin;
  let originEndTime = null;
  let originSource = 'unknown';

  if (!latestOrigin && memoryCache[`${calendarId}:${eventDateOnly}`]) {
    const { origin, originSource, originEndTime } = memoryCache[`${calendarId}:${eventDateOnly}`];
    debugLog(`ğŸ” Ã…teranvÃ¤nder memoryCache fÃ¶r dag: ${eventDateOnly}`);
    return { origin: cleanAddress(origin), originSource, originEndTime };
  }
  if (graphClient && typeof graphClient.getEvent === 'function') {
    if (!latestOrigin && !memoryCache[`${calendarId}:${eventDateOnly}`]) {
      try {
        const graphCalendarId = settings.ms_sender_email;
        const appleCalendarId = process.env.CALDAV_USER;
        const msEvent = await graphClient.getEvent(graphCalendarId, eventId);
        if (msEvent && msEvent.location) {
          latestOrigin = msEvent.location;
          originSource = 'Microsoft 365';
          debugLog(`âœ… Hittade origin frÃ¥n MS Graph: ${latestOrigin}`);
        }
      } catch (err) {
        context.log(`âš ï¸ MS Graph error in resolveOriginAddress: ${err.message}`);
      }
    }
  } else if (graphClient) {
    context.log(`âš ï¸ graphClient saknar getEvent-metod eller Ã¤r null`);
  }

  // Try fetching from Apple calendar if not found
  if (!latestOrigin && appleClient && typeof appleClient.fetchEventsByDateRange === 'function') {
    try {
      const startRange = `${eventDateOnly}T00:00:00Z`;
      const endRange = `${eventDateOnly}T23:59:59Z`;
      const appleCalendarId = process.env.CALDAV_USER;
      const events = cachedEvents || await appleClient.fetchEventsByDateRange(startRange, endRange, appleCalendarId);
      if (!cachedEvents && eventCache) eventCache.set(eventDateOnly, events);
      let mostRecent = null;
      const eventStartTime = new Date(eventId);
      for (const e of events) {
        const dtend = new Date(e.dtend || '');
        if (dtend && dtend <= eventStartTime) {
          if (!mostRecent || dtend > new Date(mostRecent.dtend || 0)) {
            mostRecent = e;
          }
        }
      }

      // Om ingen med location hittades, ta det senaste med dtend
      if (!mostRecent) {
        for (const e of events) {
          const dtend = new Date(e.dtend || '');
          if (dtend && dtend <= eventStartTime) {
            if (!mostRecent || dtend > new Date(mostRecent.dtend || 0)) {
              mostRecent = e;
            }
          }
        }
      }

      if (mostRecent) {
        latestOrigin = mostRecent.location || fallbackOrigin || '';
        originSource = mostRecent.location ? 'Apple Calendar' : 'fallback';
        debugLog(`âœ… Hittade origin frÃ¥n Apple (eller fallback): ${latestOrigin}`);

        if (mostRecent.dtend && typeof mostRecent.dtend === 'string') {
          const dt = mostRecent.dtend.replace(/[^0-9T]/g, '');
          const parsed = new Date(dt.length === 8 ? `${dt}T00:00:00Z` : dt);
          originEndTime = !isNaN(parsed.getTime())
            ? parsed
            : new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
        } else {
          originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
        }
      }
    } catch (err) {
      context.log(`âš ï¸ Apple error in resolveOriginAddress: ${err.message}`);
    }
  } else if (!latestOrigin && appleClient) {
    context.log(`âš ï¸ appleClient saknar fetchEventsByDateRange-metod eller Ã¤r null`);
  }

  // Fallback if not found
  if (!latestOrigin) {
    if (originEndTime) {
      debugLog(`âš ï¸ LOCATION saknas men endTime finns â€“ anvÃ¤nder fallback som origin`);
      latestOrigin = fallbackOrigin || '';
      originSource = 'fallback';
    } else {
      debugLog(`ğŸš¨ Ingen trÃ¤ff i varken cache, DB, Graph eller Apple â€“ anvÃ¤nder fallback`);
      latestOrigin = fallbackOrigin || '';
      originSource = 'fallback';
    }
    debugLog(`âš ï¸ Fallback anvÃ¤nds som origin: ${latestOrigin}`);
  }

  memoryCache[`${calendarId}:${eventDateOnly}`] = {
    origin: latestOrigin,
    originSource,
    originEndTime
  };

  // Write to DB cache unless fallback
  originEndTime = originEndTime || null;
  if (originSource === 'fallback') {
    originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
  }
  // Ensure originEndTime fallback value before DB insert (unless fallback)
  if (!originEndTime && originSource !== 'fallback') {
    originEndTime = new Date(`${eventDateOnly}T${settings.travel_time_window_start || '06:00'}:00`);
  }
  if (!process.env.SKIP_DB && originSource !== 'fallback') {
    try {
      await pool.query(
        `INSERT INTO calendar_origin_cache (event_date, source, address, end_time)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT DO NOTHING`,
        [eventDateOnly, originSource, latestOrigin, originEndTime]
      );
    } catch (err) {
      context.log(`âš ï¸ DB write error in resolveOriginAddress: ${err.message}`);
    }
  }

  memoryCache[cacheKey] = {
    origin: latestOrigin,
    originSource,
    originEndTime
  };
  debugLog(`ğŸ§  resolveOriginAddress resultat: ${latestOrigin} (kÃ¤lla: ${originSource})`);
  if (process.env.DEBUG === 'true' && context?.log) {
    context.log(`ğŸ“¤ resolveOriginAddress return: ${latestOrigin} (kÃ¤lla: ${originSource}, endTime: ${originEndTime?.toISOString?.() || 'null'})`);
  }
  return { origin: cleanAddress(latestOrigin), originSource, originEndTime };
}

module.exports = { resolveOriginAddress };

if (process.env.NODE_ENV === 'test') {
  module.exports._test = { memoryCache };
}
END: resolveOrigin.js

====================
ğŸ“„ Fil: shared/config/settingsLoader.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-30 11:32:26
ğŸ“ Antal rader: 63
ğŸ§© Antal funktioner: 2
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 1 â€“ ['const pool = require("../db/pgPool");']
ğŸ” LÃ¤ngsta funktion: 8 rader
ğŸ§  KomplexitetspoÃ¤ng: 11
ğŸ§ª TODO/FIXME: 0
====================
START: settingsLoader.js
const pool = require("../db/pgPool");

async function getSettings(context) {
  try {
    const settings = {};
    const isDebug = process.env.DEBUG === 'true';
    const debugLog = (msg) => {
      if (isDebug && context && context.log) {
        context.log(msg);
      }
    };
    const settingsRes = await pool.query('SELECT key, value, value_type FROM booking_settings');
    for (const row of settingsRes.rows) {
      if (
        row.value_type === 'json' ||
        row.value_type === 'array' ||
        (typeof row.value_type === 'string' && /\[\]$/.test(row.value_type))
      ) {
        try {
          settings[row.key] = JSON.parse(typeof row.value === 'string' ? row.value : JSON.stringify(row.value));
        } catch (_) {}
      } else if (row.value_type === 'int') {
        settings[row.key] = parseInt(row.value);
      } else if (row.value_type === 'bool') {
        settings[row.key] = row.value === 'true' || row.value === true;
      } else if (row.value_type === 'string') {
        settings[row.key] = String(row.value).replace(/^"(.*)"$/, '$1');
      } else {
        settings[row.key] = row.value;
      }
    }
    settings.field_labels = {
      first_name: 'FÃ¶rnamn',
      last_name: 'Efternamn',
      phone: 'Telefonnummer',
      company: 'FÃ¶retag',
      address: 'Gatuadress',
      postal_code: 'Postnummer',
      city: 'Stad',
      country: 'Land'
    };
    return settings;
  } catch (err) {
    if (context && context.log) {
      context.log(`âš ï¸ Fel vid laddning av booking_settings: ${err.message}`);
    } else {
      console.warn(`âš ï¸ Fel vid laddning av booking_settings: ${err.message}`);
    }
    throw err;
  }
}

function getCloudSecretsOnly() {
  const secrets = {};
  for (const [key, value] of Object.entries(process.env)) {
    if (key.startsWith('MS365_')) {
      secrets[key] = value;
    }
  }
  return secrets;
}

module.exports = { getSettings, getCloudSecretsOnly };
END: settingsLoader.js

====================
ğŸ“„ Fil: shared/config/verifySettings.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-30 11:33:36
ğŸ“ Antal rader: 51
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 24 rader
ğŸ§  KomplexitetspoÃ¤ng: 8
ğŸ§ª TODO/FIXME: 0
====================
START: verifySettings.js
function verifyBookingSettings(settings, context) {
  const expected = {
    default_office_address: 'string',
    default_home_address: 'string',
    fallback_travel_time_minutes: 'number',
    buffer_between_meetings: 'number',
    default_meeting_length_atoffice: 'array',
    default_meeting_length_atclient: 'array',
    default_meeting_length_digital: 'array',
    meeting_types: 'array',
    block_weekends: 'boolean',
    open_time: 'string',
    close_time: 'string',
    lunch_start: 'string',
    lunch_end: 'string',
    travel_time_window_start: 'string',
    travel_time_window_end: 'string',
    require_approval: 'boolean',
    max_days_in_advance: 'number',
    max_weekly_booking_minutes: 'number',
    cache_ttl_minutes: 'number',
    allowed_atclient_meeting_days: 'array',
    timezone: 'string'
  };

  const issues = [];
  for (const [key, type] of Object.entries(expected)) {
    const val = settings[key];
    if (val === undefined || val === null || (key === 'timezone' && String(val).trim() === '')) {
      issues.push(`âŒ Saknar instÃ¤llning: ${key}`);
    } else if (key === 'allowed_atclient_meeting_days') {
      if (!Array.isArray(val) || !val.every(v => typeof v === 'string')) {
        issues.push(`âš ï¸ Typfel fÃ¶r ${key}: ska vara array av strÃ¤ngar`);
      }
    } else if (key === 'require_approval') {
      if (typeof val !== 'boolean') {
        issues.push(`âš ï¸ Typfel fÃ¶r ${key}: ska vara boolean`);
      }
    } else if (type === 'array' ? !Array.isArray(val) : typeof val !== type) {
      issues.push(`âš ï¸ Typfel fÃ¶r ${key}: har ${typeof val}, fÃ¶rvÃ¤ntade ${type}`);
    }
  }

  if (issues.length > 0) {
    const message = 'ğŸ›‘ Problem med booking_settings:\n' + issues.join('\n');
    context.log.warn(message);
    throw new Error(message);
  }
}

module.exports = verifyBookingSettings;
END: verifySettings.js

====================
ğŸ“„ Fil: shared/db/pgPool.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-30 13:01:56
ğŸ“ Antal rader: 17
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ["const { Pool } = require('pg');", "require('dotenv').config();"]
ğŸ” LÃ¤ngsta funktion: 7 rader
ğŸ§  KomplexitetspoÃ¤ng: 0
ğŸ§ª TODO/FIXME: 0
====================
START: pgPool.js
const { Pool } = require('pg');
require('dotenv').config();

const useSSL = process.env.PG_USE_SSL === 'true';
const sslConfig = useSSL ? { rejectUnauthorized: false } : false;


const pool = new Pool({
  user: process.env.PGUSER,
  host: process.env.PGHOST,
  database: process.env.PGDATABASE,
  password: process.env.PGPASSWORD,
  port: parseInt(process.env.PGPORT || '5432', 10),
  ssl: sslConfig
});

module.exports = pool;
END: pgPool.js

====================
ğŸ“„ Fil: shared/maps/appleMaps.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-30 11:30:29
ğŸ“ Antal rader: 120
ğŸ§© Antal funktioner: 5
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 2 â€“ ["const jwt = require('jsonwebtoken');", "const fetch = require('node-fetch');"]
ğŸ” LÃ¤ngsta funktion: 10 rader
ğŸ§  KomplexitetspoÃ¤ng: 9
ğŸ§ª TODO/FIXME: 0
====================
START: appleMaps.js
const jwt = require('jsonwebtoken');
const fetch = require('node-fetch');

async function getAppleMapsAccessToken(context) {
  try {
    const teamId = process.env.APPLE_MAPS_TEAM_ID;
    const keyId = process.env.APPLE_MAPS_KEY_ID;
    const privateKey = process.env.APPLE_MAPS_PRIVATE_KEY?.replace(/\\n/g, '\n');

    if (!privateKey) {
      throw new Error('Apple Maps private key saknas â€“ kontrollera APPLE_MAPS_PRIVATE_KEY');
    }

    const token = jwt.sign({}, privateKey, {
      algorithm: 'ES256',
      issuer: teamId,
      keyid: keyId,
      expiresIn: '1h',
      header: {
        alg: 'ES256',
        kid: keyId,
        typ: 'JWT'
      }
    });

    const res = await fetch('https://maps-api.apple.com/v1/token', {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();
    return data.accessToken;
  } catch (err) {
    context?.log?.('âš ï¸ Misslyckades hÃ¤mta Apple Maps token:', err.message);
    if (err.code === 'EAI_AGAIN') {
      context?.log?.('ğŸŒ DNS-fel (EAI_AGAIN) â€“ kunde inte nÃ¥ servern:', err.message);
    }
    return null;
  }
}


async function getTravelTimeInMinutes(origin, destination, departureTime, accessToken, context) {
  try {
    const url = `https://maps-api.apple.com/v1/directions?origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&departureTime=${encodeURIComponent(departureTime)}&transportType=automobile&includeTravelTimeBreakdown=true`;

    const res = await fetch(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });

    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`âŒ Apple Maps-directions misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const travelTimeSeconds = data.routes?.[0]?.expectedTravelTime;
    return travelTimeSeconds ? Math.ceil(travelTimeSeconds / 60) : null;
  } catch (err) {
    context?.log?.(`âŒ Fel vid directions-anrop: ${err.message}`);
    return null;
  }
}

async function getTravelTime(origin, destination, departureTime, context) {
  try {
    const token = await getAppleMapsAccessToken(context);
    if (!token) {
      context?.log?.('âš ï¸ Kunde inte hÃ¤mta Apple Maps-token');
      return null;
    }
    return await getTravelTimeInMinutes(origin, destination, departureTime, token, context);
  } catch (err) {
    context?.log?.(`âŒ Fel i getTravelTime: ${err.message}`);
    return null;
  }
}

async function safeGetTravelTime(origin, destination, departureTime, accessToken, context) {
  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', origin);
    url.searchParams.append('destination', destination);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', departureTime);

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 8000); // max 8s

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` },
      signal: controller.signal
    });

    clearTimeout(timeout);
    if (!res.ok) {
      const text = await res.text();
      context?.log?.(`âŒ Apple Maps misslyckades (${res.status}): ${text}`);
      return null;
    }

    const data = await res.json();
    const seconds = data.routes?.[0]?.durationSeconds || data.routes?.[0]?.expectedTravelTime;
    return seconds ? Math.round(seconds / 60) : null;
  } catch (err) {
    context?.log?.(`âš ï¸ safeGetTravelTime error: ${err.message}`);
    return null;
  }
}

module.exports = {
  getAppleMapsAccessToken,
  getTravelTimeInMinutes,
  getTravelTime,
  safeGetTravelTime
};
END: appleMaps.js

====================
ğŸ“„ Fil: shared/maps/returnTravelVerifier.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-30 13:09:44
ğŸ“ Antal rader: 66
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 1 rader (1.5%)
ğŸ“¥ Imports: 1 â€“ ["const { URL } = require('url');"]
ğŸ” LÃ¤ngsta funktion: 2 rader
ğŸ§  KomplexitetspoÃ¤ng: 9
ğŸ§ª TODO/FIXME: 0
====================
START: returnTravelVerifier.js
const DEBUG = process.env.DEBUG === 'true';
const { URL } = require('url');

async function verifyReturnTravelFeasibility({
  previousBooking,
  contact,
  slotTime,
  settings,
  accessToken,
  db,
  context,
  travelCache
}) {
  const from = previousBooking.address || settings.default_office_address;
  const to = `${contact.metadata.address} ${contact.metadata.postal_code} ${contact.metadata.city}`;
  const prevEnd = new Date(previousBooking.end);

  if (from === to) {
    if (DEBUG) context.log(`ğŸ’¾ Returrestid Ã¤r 0 min (${from} â†’ ${to}) â€“ ingen cache behÃ¶vs`);
    return { isFeasible: true };
  }

  try {
    const url = new URL('https://maps-api.apple.com/v1/directions');
    url.searchParams.append('origin', from);
    url.searchParams.append('destination', to);
    url.searchParams.append('transportType', 'automobile');
    url.searchParams.append('departureTime', prevEnd.toISOString());

    const res = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${accessToken}` }
    });

    const data = await res.json();
    const returnMinutes = Math.round((data.routes?.[0]?.durationSeconds || 0) / 60);
    const arrivalTime = new Date(prevEnd.getTime() + returnMinutes * 60000);

    // Cache return time in memory and DB
    const hour = prevEnd.getUTCHours();
    const returnCacheKey = `${from}|${to}|${hour}`;
    travelCache.set(returnCacheKey, returnMinutes);
    if (from && to) {
      await db.query(`
        INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (from_address, to_address, hour)
        DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes
      `, [from, to, hour, returnMinutes]);
      if (DEBUG) context.log(`ğŸ’¾ Returrestid sparad: ${returnMinutes} min (${from} â†’ ${to} @ ${hour}:00)`);
    } else {
      if (DEBUG) context.log(`âš ï¸ Hoppar caching av retur â€“ saknar from_address (${from}) eller to_address (${to})`);
    }

    if (arrivalTime > slotTime) {
      if (DEBUG) context.log(`â›” Slot ${slotTime.toISOString()} avvisad â€“ retur frÃ¥n tidigare mÃ¶te hinner inte fram i tid (ankomst ${arrivalTime.toISOString()})`);
      return { isFeasible: false, reason: 'retur hinner inte fram', arrivalTime };
    }

    return { isFeasible: true };
  } catch (err) {
    if (DEBUG) context.log(`âš ï¸ Kunde inte verifiera returrestid frÃ¥n tidigare mÃ¶te: ${err.message}`);
    return { isFeasible: true }; // fail open
  }
}

module.exports = { verifyReturnTravelFeasibility };
END: returnTravelVerifier.js

====================
ğŸ“„ Fil: shared/maps/resolveTravelTime.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-30 13:10:31
ğŸ“ Antal rader: 78
ğŸ§© Antal funktioner: 1
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 2 rader
ğŸ§  KomplexitetspoÃ¤ng: 16
ğŸ§ª TODO/FIXME: 0
====================
START: resolveTravelTime.js
const DEBUG = process.env.DEBUG === 'true';

async function resolveTravelTime({ origin, destination, hour, db, accessToken, context }) {
  let travelTimeMin = 20;
  const cacheKey = `${origin}|${destination}|${hour}`;
  let cacheHit = false;
  let isFallback = false;

  if (!origin || !destination) {
    if (DEBUG) context.log(`âš ï¸ Kan inte berÃ¤kna restid â€“ origin eller destination saknas`);
    return { travelTimeMin, cacheHit: false, isFallback };
  }

  if (!db || typeof db.query !== 'function') {
    if (DEBUG) context.log(`âŒ db saknas eller saknar query-metod i resolveTravelTime`);
    return { travelTimeMin, cacheHit: false, isFallback: true };
  }

  try {
    const cacheRes = await db.query(
      `SELECT travel_minutes, is_fallback FROM travel_time_cache WHERE from_address = $1 AND to_address = $2 AND hour = $3 LIMIT 1`,
      [origin, destination, hour]
    );
    if (cacheRes.rows.length > 0) {
      travelTimeMin = cacheRes.rows[0].travel_minutes;
      isFallback = cacheRes.rows[0].is_fallback === true;
      cacheHit = true;
      if (DEBUG) context.log(`âš¡ Cache hit (db): ${origin} â†’ ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
    }
  } catch (err) {
    if (DEBUG) context.log(`âš ï¸ Kunde inte lÃ¤sa frÃ¥n travel_time_cache: ${err.message}`);
  }

  if (!accessToken) {
    if (DEBUG) context.log(`âš ï¸ accessToken saknas â€“ anvÃ¤nder fallback`);
    return { travelTimeMin, cacheHit: false, isFallback: true };
  }

  if (!cacheHit && accessToken) {
    try {
      const url = new URL('https://maps-api.apple.com/v1/directions');
      url.searchParams.append('origin', origin);
      url.searchParams.append('destination', destination);
      url.searchParams.append('transportType', 'automobile');
      url.searchParams.append('departureTime', new Date().toISOString());

      const res = await fetch(url.toString(), {
        headers: { Authorization: `Bearer ${accessToken}` }
      });
      const data = await res.json();
      const travelSeconds = data.routes?.[0]?.durationSeconds;
      if (travelSeconds) {
        travelTimeMin = Math.round(travelSeconds / 60);
        await db.query(
          `INSERT INTO travel_time_cache (from_address, to_address, hour, travel_minutes, is_fallback)
           VALUES ($1, $2, $3, $4, false)
           ON CONFLICT (from_address, to_address, hour)
           DO UPDATE SET travel_minutes = EXCLUDED.travel_minutes, is_fallback = false`,
          [origin, destination, hour, travelTimeMin]
        );
        if (DEBUG) context.log(`ğŸ’¾ Sparade Apple Maps-restid i cache: ${origin} â†’ ${destination} @ ${hour}:00 = ${travelTimeMin} min`);
      } else {
        if (DEBUG) context.log(`âš ï¸ Apple Maps-data saknas â€“ anvÃ¤nder fallback`);
      }
    } catch (err) {
      if (DEBUG) context.log(`âš ï¸ Fel vid Apple Maps-anrop: ${err.message}`);
    }
  }

  return {
    travelTimeMin,
    cacheHit,
    isFallback,
    source: isFallback ? 'fallback' : 'apple'
  };
}

module.exports = { resolveTravelTime };
END: resolveTravelTime.js

====================
ğŸ“„ Fil: shared/calendar/zoomClient.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-26 11:07:48
ğŸ“ Antal rader: 63
ğŸ§© Antal funktioner: 3
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 1 â€“ ["const fetch = require('node-fetch');"]
ğŸ” LÃ¤ngsta funktion: 13 rader
ğŸ§  KomplexitetspoÃ¤ng: 3
ğŸ§ª TODO/FIXME: 0
====================
START: zoomClient.js
const fetch = require('node-fetch');

function createZoomClient() {
  const clientId = process.env.ZOOM_CLIENT_ID;
  const clientSecret = process.env.ZOOM_CLIENT_SECRET;
  const accountId = process.env.ZOOM_ACCOUNT_ID;
  const userId = process.env.ZOOM_USER_ID || 'me';

  if (!clientId || !clientSecret || !accountId) {
    throw new Error("Missing Zoom OAuth credentials in environment variables");
  }

  async function getAccessToken() {
    const basicAuth = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
    const res = await fetch(`https://zoom.us/oauth/token?grant_type=account_credentials&account_id=${accountId}`, {
      method: 'POST',
      headers: {
        Authorization: `Basic ${basicAuth}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    });

    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Failed to get Zoom access token: ${text}`);
    }

    const data = await res.json();
    return data.access_token;
  }

  async function createMeeting({ topic, start, duration }) {
    const token = await getAccessToken();

    const res = await fetch(`https://api.zoom.us/v2/users/${userId}/meetings`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        topic,
        type: 2,
        start_time: start,
        duration,
        timezone: 'Europe/Stockholm'
      })
    });

    if (!res.ok) {
      const err = await res.text();
      throw new Error(`Zoom error: ${err}`);
    }

    const result = await res.json();
    console.log(`ğŸ“… Zoom-mÃ¶te skapat: ${result.join_url}`);
    return result;
  }

  return { createMeeting };
}

module.exports = createZoomClient;
END: zoomClient.js

====================
ğŸ“„ Fil: shared/notification/sendMail.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-06-01 22:02:09
ğŸ“ Antal rader: 88
ğŸ§© Antal funktioner: 2
ğŸ’¬ KommentarstÃ¤ckning: 14 rader (15.9%)
ğŸ“¥ Imports: 1 â€“ ["const fetch = require('node-fetch');"]
ğŸ” LÃ¤ngsta funktion: 17 rader
ğŸ§  KomplexitetspoÃ¤ng: 5
ğŸ§ª TODO/FIXME: 0
====================
START: sendMail.js
const fetch = require('node-fetch');

/**
 * Send mail with HTML body (no newline replacements, allows any HTML).
 * Optionally adds a tracking pixel at the end of the body.
 * Can be used to send Zoom/Teams invitations or in-person meeting details,
 * based on meeting_type and booking_settings formatting.
 *
 * @param {Object} param0
 * @param {string} param0.to
 * @param {string} param0.subject
 * @param {string} param0.body - HTML string
 * @param {string|null} [param0.trackingPixelUrl] - Optional tracking pixel image url
 */
async function sendMail({ to, subject, body, trackingPixelUrl = null }) {
  const tenantId = process.env.MS365_TENANT_ID;
  const clientId = process.env.MS365_CLIENT_ID;
  const clientSecret = process.env.MS365_CLIENT_SECRET;
  const sender = process.env.MS365_USER_EMAIL;

  if (!tenantId || !clientId || !clientSecret || !sender) {
    throw new Error("âŒ Saknar miljÃ¶variabler fÃ¶r Microsoft Graph");
  }

  // HÃ¤mta token
  const tokenRes = await fetch(`https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      client_id: clientId,
      scope: 'https://graph.microsoft.com/.default',
      client_secret: clientSecret,
      grant_type: 'client_credentials'
    })
  });

  if (!tokenRes.ok) {
    const error = await tokenRes.text();
    throw new Error(`âŒ Misslyckades hÃ¤mta token: ${error}`);
  }

  const { access_token } = await tokenRes.json();

  // Prepare HTML body with optional tracking pixel
  const htmlBody =
    trackingPixelUrl
      ? body + `<br><img src="${trackingPixelUrl}" width="1" height="1" style="display:none;">`
      : body;

  const mailRes = await fetch(`https://graph.microsoft.com/v1.0/users/${sender}/sendMail`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${access_token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      message: {
        subject,
        body: {
          contentType: 'HTML',
          content: htmlBody
        },
        toRecipients: [{ emailAddress: { address: to } }]
      },
      saveToSentItems: false
    })
  });

  if (mailRes.ok && process.env.DEBUG_EMAIL === 'true') {
    console.log(`âœ… E-post skickad till ${to} via Graph API`);
    console.log(`ğŸ“§ MailinnehÃ¥ll skickat till: ${to}`);
    console.log(`ğŸ§¾ Ã„mne: ${subject}`);
    console.log(`ğŸ“ Body (start): ${body.substring(0, 60).replace(/\n/g, ' ')}...`);
  }

  if (process.env.DEBUG_EMAIL === 'true') {
    console.log(`ğŸ“¤ E-post skickas till: ${to}`);
    console.log(`âœ‰ï¸ Ã„mne: ${subject}`);
  }

  if (!mailRes.ok) {
    const error = await mailRes.text();
    console.error(`âŒ Misslyckades skicka mail till ${to} â€“ Ã¤mne: ${subject}`);
    throw new Error(`âŒ Fel frÃ¥n Graph API: ${error}`);
  }
}

module.exports = { sendMail };
END: sendMail.js

====================
ğŸ“„ Fil: bookings/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-06-01 23:09:18
ğŸ“ Antal rader: 811
ğŸ§© Antal funktioner: 11
ğŸ’¬ KommentarstÃ¤ckning: 51 rader (6.3%)
ğŸ“¥ Imports: 7 â€“ ["const { getSettings } = require('../shared/config/settingsLoader');", "const pool = require('../shared/db/pgPool');", "const { v4: uuidv4 } = require('uuid');", "const { createDebugLogger } = require('../shared/utils/debugLogger');", "const createZoomClient = require('../shared/calendar/zoomClient');", "const { sendMail } = require('../shared/notification/sendMail');", "const graphClient = require('../shared/calendar/msGraph')(context);"]
ğŸ” LÃ¤ngsta funktion: 7 rader
ğŸ§  KomplexitetspoÃ¤ng: 54
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const { getSettings } = require('../shared/config/settingsLoader');
const pool = require('../shared/db/pgPool');
const { v4: uuidv4 } = require('uuid');
const { createDebugLogger } = require('../shared/utils/debugLogger');
const createZoomClient = require('../shared/calendar/zoomClient');
const zoomClient = createZoomClient();
const { sendMail } = require('../shared/notification/sendMail');

// DebugLog kommer deklareras senare, sÃ¥ vi mÃ¥ste vÃ¤nta tills vi har context fÃ¶r att anvÃ¤nda debugLog.

module.exports = async function (context, req) {
  const graphClient = require('../shared/calendar/msGraph')(context);
  context.log('ğŸ“¥ bookings/index.js startar');
  const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
  const userAgent = req.headers['user-agent'] || 'unknown';
  context.log(`ğŸŒ IP: ${ipAddress}`);
  context.log(`ğŸ§­ User-Agent: ${userAgent}`);
  const requiredFields = ['meeting_type', 'meeting_length', 'slot_iso'];
  context.log('ğŸ” req.body:', req.body);
  const missing = requiredFields.filter(k => !req.body?.[k]);
  context.log('ğŸ” Saknade fÃ¤lt:', missing);

  if (missing.length > 0) {
    context.log('âŒ Avbryter pga saknade fÃ¤lt');
    context.res = { status: 400, body: { error: `Missing fields: ${missing.join(', ')}` } };
    return;
  }

  const { email, meeting_type, meeting_length, slot_iso, contact_id, metadata = {} } = req.body;

  let db;
  try {
    db = await pool.connect();

    const contactRes = await db.query('SELECT metadata FROM contact WHERE id = $1', [contact_id]);
    const dbMetadata = (contactRes.rows[0] && contactRes.rows[0].metadata) || {};
    const combinedMetadata = { ...dbMetadata, ...metadata };

    if (!email || typeof email !== 'string' || !email.includes('@')) {
      context.log('âŒ Ogiltig eller saknad e-postadress:', email);
      context.res = {
        status: 400,
        body: { error: 'Ogiltig eller saknad e-postadress' }
      };
      db.release();
      return;
    }

    const parsedLength = parseInt(meeting_length, 10);
    if (isNaN(parsedLength) || parsedLength <= 0) {
      context.log('âŒ Ogiltig mÃ¶teslÃ¤ngd:', meeting_length);
      context.res = { status: 400, body: { error: "Invalid meeting_length" } };
      db.release();
      return;
    }

    const parsedStart = new Date(slot_iso);
    if (isNaN(parsedStart.getTime())) {
      context.log('âŒ Ogiltigt slot_iso:', slot_iso);
      context.res = { status: 400, body: { error: "Invalid slot_iso datetime" } };
      db.release();
      return;
    }

    const requiredEnv = ['PGUSER', 'PGHOST', 'PGDATABASE', 'PGPASSWORD', 'PGPORT'];
    for (const key of requiredEnv) {
      if (!process.env[key]) {
        context.log('âŒ Saknar env:', key);
        context.res = { status: 500, body: { error: `Missing environment variable: ${key}` } };
        db.release();
        return;
      }
    }

    const debugHelper = createDebugLogger(context);
    const debugLog = debugHelper.debugLog || ((...args) => context.log('[âš ï¸ fallback log]', ...args));
  debugLog("ğŸ”§ graphClient.createEvent finns:", typeof graphClient.createEvent === "function");
    debugLog("ğŸ§  debugLogger aktiv â€“ DEBUG=" + process.env.DEBUG);
    debugLog("ğŸ§¾ Metadata efter sammanslagning:", combinedMetadata);
    // LÃ¤s in booking_settings
    const settings = await getSettings(context);

    // Kontrollera att alla required_fields finns i metadata eller req.body
    const requiredFieldsConfig = settings.required_fields || {};
    const baseFields = Array.isArray(requiredFieldsConfig.base) ? requiredFieldsConfig.base : [];
    const specificFields = Array.isArray(requiredFieldsConfig[meeting_type.toLowerCase()])
      ? requiredFieldsConfig[meeting_type.toLowerCase()]
      : [];
    const requiredFieldsFromSettings = [...new Set([...baseFields, ...specificFields])];
    const missingRequired = requiredFieldsFromSettings.filter(field => {
      return !(field in req.body) && !(field in combinedMetadata);
    });

    if (missingRequired.length > 0) {
      context.log('âŒ Saknade obligatoriska fÃ¤lt enligt settings:', missingRequired);
      context.res = {
        status: 400,
        body: { error: `Saknade obligatoriska fÃ¤lt: ${missingRequired.join(', ')}` }
      };
      db.release();
      return;
    }

    const id = uuidv4();
    // Kontrollera om en bokning redan finns
    const existing = await db.query(
      'SELECT id FROM bookings WHERE contact_id = $1 AND start_time = $2',
      [contact_id || null, parsedStart.toISOString()]
    );
    if (existing.rowCount > 0) {
      context.res = {
        status: 409,
        body: { error: 'Booking already exists for this time.' }
      };
      db.release();
      return;
    }
    const startTime = parsedStart;
    const endTime = new Date(startTime.getTime() + parsedLength * 60000);
    const created_at = new Date();
    const updated_at = created_at;


    combinedMetadata.meeting_length = meeting_length;
    combinedMetadata.ip_address = ipAddress;
    combinedMetadata.user_agent = userAgent;

    const bookingFields = {
      id,
      start_time: startTime.toISOString(),
      end_time: endTime.toISOString(),
      meeting_type,
      metadata: combinedMetadata,
      created_at,
      updated_at,
      contact_id: contact_id || null,
      booking_email: email || null
    };
    debugLog("ğŸ“¦ bookingFields infÃ¶r DB:", bookingFields);

    let online_link = null;
    // TEAMS-flÃ¶de
    if (meeting_type.toLowerCase() === 'teams' && contact_id && email) {
      const subjectTemplates = settings.email_subject_templates || {};
      const subjectTemplate = subjectTemplates[meeting_type.toLowerCase()] || settings.default_meeting_subject || 'MÃ¶te';
      const emailSubject = subjectTemplate
        .replace('{{first_name}}', combinedMetadata.first_name || '')
        .replace('{{company}}', combinedMetadata.company || 'din organisation');
      combinedMetadata.subject = emailSubject;
      const location = combinedMetadata.location || 'Online';
      let eventResult = null;
      try {
        eventResult = await graphClient.createEvent({
          start: startTime.toISOString(),
          end: endTime.toISOString(),
          subject: emailSubject,
          location,
          attendees: [email],
          meetingType: meeting_type
        });
        debugLog("ğŸ“¨ eventResult:", eventResult);
        // Spara kalenderstatus om den finns (Teams)
        if (eventResult?.attendees && Array.isArray(eventResult.attendees)) {
          const attendeeSelf = eventResult.attendees.find(a => a.emailAddress?.address === email);
          if (attendeeSelf?.status?.response) {
            combinedMetadata.calendar_response_status = attendeeSelf.status.response; // t.ex. 'none', 'accepted', 'declined'
            await db.query(
              'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
              ['calendar_response_status', id, { response: attendeeSelf.status.response }]
            );
          }
        }
        if (!eventResult) {
          context.log("âš ï¸ createEvent returnerade null â€“ ingen Teams-lÃ¤nk skapades");
        }
        if (eventResult?.onlineMeetingUrl) {
          online_link = eventResult.onlineMeetingUrl;
          combinedMetadata.online_link = online_link;
          combinedMetadata.subject = eventResult.subject || emailSubject || settings.default_meeting_subject || 'MÃ¶te';
          combinedMetadata.location = eventResult.location || location || 'Online';
        }

        // Extrahera mÃ¶tesinfo frÃ¥n bodyPreview oavsett joinUrl
        const body = eventResult?.body?.content || '';
        const idMatch = body.match(/MÃ¶tes-ID:\s*(\d[\d\s]*)/);
        const pwMatch = body.match(/LÃ¶senord:\s*([A-Za-z0-9]+)/);

        if (idMatch) combinedMetadata.meeting_id = idMatch[1].trim();
        if (pwMatch) combinedMetadata.passcode = pwMatch[1].trim();
        if (body && !eventResult?.onlineMeetingUrl) {
          combinedMetadata.body_preview = body;
        }

        if (eventResult) {
          // Endast om eventResult finns, markera som synkad
          bookingFields.synced_to_calendar = true;
          // Logga till event_log fÃ¶r lyckad kalenderinbjudan
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_invite_sent', id, {
              subject: eventResult?.subject || null,
              location: eventResult?.location || null,
              webLink: eventResult?.webLink || null
            }]
          );
          // Logga hela eventResult som calendar_event_created
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_event_created', id, eventResult]
          );
        }
      } catch (err) {
        // Skicka endast mail om createEvent misslyckades (eventResult === null)
        if (eventResult === null) {
          // --- Ny kod fÃ¶r att skicka Teams-inbjudan via e-post som fallback ---
          const bodyTemplates = settings.email_body_templates || {};
          const rawBody = bodyTemplates[meeting_type.toLowerCase()] || (settings.email_invite_template?.body || '');
          const emailBodyHtml = rawBody
            .replace('{{first_name}}', combinedMetadata.first_name || '')
            .replace('{{company}}', combinedMetadata.company || '')
            .replace('{{start_time}}', startTime.toLocaleString('sv-SE'))
            .replace('{{end_time}}', endTime.toLocaleString('sv-SE'))
            .replace('{{online_link}}', online_link || '')
            .replace('{{phone}}', combinedMetadata.phone || '')
            .replace('{{location}}', combinedMetadata.location || '')
            .replace(/\\n/g, '\n') // tolka "\\n" som newline
            .replace(/\n/g, '<br>');
          const signature = settings.email_signature || '';
          const finalEmailBodyHtml = `<html><body>${emailBodyHtml}<br><br>${signature}</body></html>`;

          await sendMail({
            to: email,
            subject: emailSubject,
            body: finalEmailBodyHtml,
            contentType: 'HTML',
            trackingPixelUrl: `https://klrab.se/track.gif?booking_id=${id}`
          });
          debugLog('âœ… Teams-inbjudan skickad via e-post (fallback)');
          // Logga fallback-anvÃ¤ndning till event_log
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_invite_fallback_email', id, { source: 'fallback_email' }]
          );
          // --- Slut pÃ¥ ny kod fÃ¶r Teams-inbjudan fallback ---
        }
      }
    } else if (meeting_type.toLowerCase() === 'zoom') {
      let zoomMeetingCreated = false;
      let icsAttachment = null;
      let result = null;
      // Bygg subject enligt email_subject_templates.zoom
      const subjectTemplates = settings.email_subject_templates || {};
      const subjectTemplate = subjectTemplates['zoom'] || settings.default_meeting_subject || 'MÃ¶te';
      const emailSubject = subjectTemplate
        .replace('{{first_name}}', combinedMetadata.first_name || '')
        .replace('{{company}}', combinedMetadata.company || 'din organisation');
      combinedMetadata.subject = emailSubject;
      try {
        result = await zoomClient.createMeeting({
          topic: emailSubject,
          start: startTime.toISOString(),
          duration: parsedLength
        });
        debugLog("ğŸ“¨ Zoom result:", result);
        // Skapa Ã¤ven kalenderinbjudan via Graph API sÃ¥ den syns i din kalender
        try {
          const eventResult = await graphClient.createEvent({
            start: startTime.toISOString(),
            end: endTime.toISOString(),
            subject: emailSubject,
            location: 'Online',
            attendees: [email],
            meetingType: meeting_type
          });
          debugLog("ğŸ“¨ ZoommÃ¶te Ã¤ven skapat som kalenderinbjudan:", eventResult);
          if (eventResult?.attendees && Array.isArray(eventResult.attendees)) {
            const attendeeSelf = eventResult.attendees.find(a => a.emailAddress?.address === email);
            if (attendeeSelf?.status?.response) {
              combinedMetadata.calendar_response_status = attendeeSelf.status.response;
              await db.query(
                'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
                ['calendar_response_status', id, { response: attendeeSelf.status.response }]
              );
            }
          }
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_invite_sent', id, {
              subject: eventResult?.subject || null,
              location: eventResult?.location || null,
              webLink: eventResult?.webLink || null
            }]
          );
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_event_created', id, eventResult]
          );
        } catch (calendarErr) {
          debugLog("âš ï¸ Kunde inte skapa kalenderinbjudan fÃ¶r Zoom-mÃ¶te:", calendarErr.message);
        }
        online_link = result.join_url;
        combinedMetadata.online_link = online_link;
        combinedMetadata.meeting_id = result.id;
        combinedMetadata.subject = emailSubject;
        combinedMetadata.location = 'Online';
        bookingFields.synced_to_calendar = true;
        // Logga till event_log fÃ¶r lyckad kalenderinbjudan (Zoom)
        await db.query(
          'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
          ['calendar_invite_sent', id, {
            subject: result?.topic || null,
            location: 'Online',
            webLink: result?.join_url || null
          }]
        );
        // Logga hela result som calendar_event_created
        await db.query(
          'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
          ['calendar_event_created', id, result]
        );
        // Skicka INTE e-post om Zoom-mÃ¶te skapades korrekt
        zoomMeetingCreated = true;
        // return; // Ta bort eller kommentera ut denna rad sÃ¥ att loggningen kÃ¶rs
      } catch (err) {
        // Fallback: skapa .ics och skicka e-post om Zoom-mÃ¶tet inte kunde skapas
        const fallbackLocation = combinedMetadata.location || 'Online';
        const fallbackSubject = combinedMetadata.subject || emailSubject || 'ZoommÃ¶te';
        // Skapa .ics-fallback
        const icsBody = `
BEGIN:VCALENDAR
VERSION:2.0
BEGIN:VEVENT
SUMMARY:${fallbackSubject}
DTSTART:${startTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
DTEND:${endTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
LOCATION:${fallbackLocation}
DESCRIPTION:ZoommÃ¶te (ingen lÃ¤nk kunde genereras)
END:VEVENT
END:VCALENDAR
`.trim();
        icsAttachment = {
          '@odata.type': '#microsoft.graph.fileAttachment',
          name: 'inbjudan.ics',
          contentType: 'text/calendar',
          contentBytes: Buffer.from(icsBody).toString('base64')
        };
        // Skicka fallback-mail med .ics
        const bodyTemplates = settings.email_body_templates || {};
        // Zoom ska anvÃ¤nda email_body_templates.zoom om det finns, annars email_invite_template.body
        const rawBody = (bodyTemplates['zoom'] || (settings.email_invite_template?.body || ''));
        const emailBodyHtml = rawBody
          .replace('{{first_name}}', combinedMetadata.first_name || '')
          .replace('{{company}}', combinedMetadata.company || '')
          .replace('{{start_time}}', startTime.toLocaleString('sv-SE'))
          .replace('{{end_time}}', endTime.toLocaleString('sv-SE'))
          .replace('{{online_link}}', '')
          .replace('{{phone}}', combinedMetadata.phone || '')
          .replace('{{location}}', fallbackLocation)
          .replace(/\\n/g, '\n')
          .replace(/\n/g, '<br>');
        const signature = settings.email_signature || '';
        const finalEmailBodyHtml = `<html><body>${emailBodyHtml}<br><br>${signature}</body></html>`;
        await sendMail({
          to: email,
          subject: emailSubject,
          body: finalEmailBodyHtml,
          contentType: 'HTML',
          trackingPixelUrl: `https://klrab.se/track.gif?booking_id=${id}`,
          attachments: [icsAttachment]
        });
        await db.query(
          'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
          ['calendar_invite_fallback_ics', id, { source: 'zoom_createMeeting_failed' }]
        );
        debugLog('âœ… Zoominbjudan skickad via e-post (fallback .ics)');
      }
      // Skicka INTE mail om Zoom-mÃ¶tet skapades (zoomMeetingCreated)
    } else if (meeting_type.toLowerCase() === 'facetime') {
      let facetimeEventCreated = false;
      let icsAttachment = null;
      if (combinedMetadata.phone) {
        online_link = `facetime:${combinedMetadata.phone}`;
        combinedMetadata.online_link = online_link;
        const subjectTemplates = settings.email_subject_templates || {};
        const subjectTemplate = subjectTemplates[meeting_type.toLowerCase()] || settings.default_meeting_subject || 'MÃ¶te';
        const emailSubject = subjectTemplate
          .replace('{{first_name}}', combinedMetadata.first_name || '')
          .replace('{{company}}', combinedMetadata.company || 'din organisation');
        combinedMetadata.subject = emailSubject;
        combinedMetadata.location = combinedMetadata.location || 'FaceTime';

        // FÃ¶rsÃ¶k skapa kalenderinbjudan via Graph
        let eventResult = null;
        try {
          eventResult = await graphClient.createEvent({
            start: startTime.toISOString(),
            end: endTime.toISOString(),
            subject: emailSubject,
            location: 'FaceTime',
            attendees: [email],
            meetingType: meeting_type
          });
          debugLog("ğŸ“¨ eventResult:", eventResult);
          // Spara kalenderstatus om den finns (FaceTime)
          if (eventResult?.attendees && Array.isArray(eventResult.attendees)) {
            const attendeeSelf = eventResult.attendees.find(a => a.emailAddress?.address === email);
            if (attendeeSelf?.status?.response) {
              combinedMetadata.calendar_response_status = attendeeSelf.status.response; // t.ex. 'none', 'accepted', 'declined'
              await db.query(
                'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
                ['calendar_response_status', id, { response: attendeeSelf.status.response }]
              );
            }
          }
        } catch (err) {
          debugLog("ğŸ’¥ createEvent kastade ett fel:", err.stack || err.toString());
        }
        if (eventResult?.location) {
          combinedMetadata.location = eventResult.location;
        }
        if (eventResult?.subject) {
          combinedMetadata.subject = eventResult.subject;
        }
        if (eventResult?.onlineMeetingUrl) {
          combinedMetadata.online_link = eventResult.onlineMeetingUrl;
        }

        if (eventResult?.body?.content) {
          combinedMetadata.body_preview = eventResult.body.content;
        }

        // Nytt: kontrollera eventResult och logga enligt instruktion
        if (eventResult) {
          debugLog('âœ… FaceTime-event skapat i kalender via Graph');
          bookingFields.synced_to_calendar = true;
          facetimeEventCreated = true;
          // Logga till event_log fÃ¶r lyckad kalenderinbjudan
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_invite_sent', id, {
              subject: eventResult?.subject || null,
              location: eventResult?.location || null,
              webLink: eventResult?.webLink || null
            }]
          );
          // Logga hela eventResult som calendar_event_created
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_event_created', id, eventResult]
          );
        } else {
          debugLog('âš ï¸ FaceTime-event kunde inte skapas via Graph');
        }

        // Om kalenderinbjudan via Graph misslyckades, skapa .ics som fallback
        if (!facetimeEventCreated) {
          const icsBody = `
BEGIN:VCALENDAR
VERSION:2.0
BEGIN:VEVENT
SUMMARY:${combinedMetadata.subject}
DTSTART:${startTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
DTEND:${endTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
LOCATION:${combinedMetadata.location}
DESCRIPTION:Ring via FaceTime: ${combinedMetadata.phone}
END:VEVENT
END:VCALENDAR
`.trim();

          icsAttachment = {
            '@odata.type': '#microsoft.graph.fileAttachment',
            name: 'inbjudan.ics',
            contentType: 'text/calendar',
            contentBytes: Buffer.from(icsBody).toString('base64')
          };
        }

      // Skicka endast mail om Graph misslyckades (dvs !facetimeEventCreated)
      if (!facetimeEventCreated && icsAttachment) {
        try {
          const bodyTemplates = settings.email_body_templates || {};
          const rawBody = bodyTemplates[meeting_type.toLowerCase()] || (settings.email_invite_template?.body || '');
          const emailBodyHtml = rawBody
            .replace('{{first_name}}', combinedMetadata.first_name || '')
            .replace('{{company}}', combinedMetadata.company || '')
            .replace('{{start_time}}', startTime.toLocaleString('sv-SE'))
            .replace('{{end_time}}', endTime.toLocaleString('sv-SE'))
            .replace('{{online_link}}', combinedMetadata.online_link || online_link || '')
            .replace('{{phone}}', combinedMetadata.phone || '')
            .replace('{{location}}', combinedMetadata.location || '')
            .replace(/\\n/g, '\n') // tolka "\\n" som newline
            .replace(/\n/g, '<br>');
          const signature = settings.email_signature || '';
          const finalEmailBodyHtml = `<html><body>${emailBodyHtml}<br><br>${signature}</body></html>`;
          await sendMail({
            to: email,
            subject: emailSubject,
            body: finalEmailBodyHtml,
            contentType: 'HTML',
            trackingPixelUrl: `https://klrab.se/track.gif?booking_id=${id}`,
            attachments: [icsAttachment]
          });
          // Logga fallback .ics-anvÃ¤ndning till event_log
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_invite_fallback_ics', id, { source: 'fallback_ics' }]
          );
          debugLog('âœ… FaceTime-inbjudan skickad via e-post (fallback .ics)');
        } catch (emailErr) {
          context.log("âŒ Kunde inte skicka FaceTime-inbjudan:", emailErr.message);
        }
      }
      } else {
        context.log("âŒ FaceTime-bokning saknar telefonnummer â€“ kan inte skapa lÃ¤nk eller skicka inbjudan.");
      }
    } else if (meeting_type.toLowerCase() === 'atclient') {
      combinedMetadata.location = combinedMetadata.location || combinedMetadata.address || settings.default_home_address || 'Hos kund';
      const subjectTemplates = settings.email_subject_templates || {};
      const subjectTemplate = subjectTemplates[meeting_type.toLowerCase()] || settings.default_meeting_subject || 'MÃ¶te';
      const emailSubject = subjectTemplate
        .replace('{{first_name}}', combinedMetadata.first_name || '')
        .replace('{{company}}', combinedMetadata.company || 'din organisation');
      combinedMetadata.subject = emailSubject;

      // FÃ¶rsÃ¶k skapa kalenderinbjudan via Graph
      let atClientEventCreated = false;
      let icsAttachment = null;
      try {
        const eventResult = await graphClient.createEvent({
          start: startTime.toISOString(),
          end: endTime.toISOString(),
          subject: emailSubject,
          location: combinedMetadata.location,
          attendees: [email],
          meetingType: meeting_type
        });
        debugLog("ğŸ“¨ eventResult:", eventResult);
        // Spara kalenderstatus om den finns (atClient)
        if (eventResult?.attendees && Array.isArray(eventResult.attendees)) {
          const attendeeSelf = eventResult.attendees.find(a => a.emailAddress?.address === email);
          if (attendeeSelf?.status?.response) {
            combinedMetadata.calendar_response_status = attendeeSelf.status.response; // t.ex. 'none', 'accepted', 'declined'
            await db.query(
              'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
              ['calendar_response_status', id, { response: attendeeSelf.status.response }]
            );
          }
        }
        bookingFields.synced_to_calendar = true;
        debugLog('âœ… atClient-event skapat i kalender via Graph');
        atClientEventCreated = true;
        // Logga till event_log fÃ¶r lyckad kalenderinbjudan
        await db.query(
          'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
          ['calendar_invite_sent', id, {
            subject: eventResult?.subject || null,
            location: eventResult?.location || null,
            webLink: eventResult?.webLink || null
          }]
        );
        // Logga hela eventResult som calendar_event_created
        await db.query(
          'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
          ['calendar_event_created', id, eventResult]
        );
      } catch (err) {
        context.log(`âš ï¸ atClient-kalenderinbjudan via Graph misslyckades: ${err.message}`);
      }

      // Skapa .ics-fallback om Graph misslyckades
      if (!atClientEventCreated && icsAttachment == null) {
        const icsBody = `
BEGIN:VCALENDAR
VERSION:2.0
BEGIN:VEVENT
SUMMARY:${combinedMetadata.subject}
DTSTART:${startTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
DTEND:${endTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
LOCATION:${combinedMetadata.location}
DESCRIPTION:MÃ¶te hos kund
END:VEVENT
END:VCALENDAR
`.trim();
        icsAttachment = {
          '@odata.type': '#microsoft.graph.fileAttachment',
          name: 'inbjudan.ics',
          contentType: 'text/calendar',
          contentBytes: Buffer.from(icsBody).toString('base64')
        };
      }

      // Skicka endast mail om Graph misslyckades (dvs !atClientEventCreated)
      if (!atClientEventCreated && icsAttachment) {
        try {
          const bodyTemplates = settings.email_body_templates || {};
          const rawBody = bodyTemplates[meeting_type.toLowerCase()] || (settings.email_invite_template?.body || '');
          const emailBodyHtml = rawBody
            .replace('{{first_name}}', combinedMetadata.first_name || '')
            .replace('{{company}}', combinedMetadata.company || '')
            .replace('{{start_time}}', startTime.toLocaleString('sv-SE'))
            .replace('{{end_time}}', endTime.toLocaleString('sv-SE'))
            .replace('{{online_link}}', online_link || '')
            .replace('{{phone}}', combinedMetadata.phone || '')
            .replace('{{location}}', combinedMetadata.location || '')
            .replace(/\\n/g, '\n') // tolka "\\n" som newline
            .replace(/\n/g, '<br>');
          const signature = settings.email_signature || '';
          const finalEmailBodyHtml = `<html><body>${emailBodyHtml}<br><br>${signature}</body></html>`;
          await sendMail({
            to: email,
            subject: emailSubject,
            body: finalEmailBodyHtml,
            contentType: 'HTML',
            trackingPixelUrl: `https://klrab.se/track.gif?booking_id=${id}`,
            attachments: [icsAttachment]
          });
          // Logga fallback .ics-anvÃ¤ndning till event_log
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_invite_fallback_ics', id, { source: 'fallback_ics' }]
          );
          debugLog('âœ… atClient-inbjudan skickad via e-post (fallback .ics)');
        } catch (emailErr) {
        }
      }
    } else if (meeting_type.toLowerCase() === 'atoffice') {
      combinedMetadata.location = combinedMetadata.location || settings.default_office_address || 'Kontoret';
      const subjectTemplates = settings.email_subject_templates || {};
      const subjectTemplate = subjectTemplates[meeting_type.toLowerCase()] || settings.default_meeting_subject || 'MÃ¶te';
      const emailSubject = subjectTemplate
        .replace('{{first_name}}', combinedMetadata.first_name || '')
        .replace('{{company}}', combinedMetadata.company || 'din organisation');
      combinedMetadata.subject = emailSubject;

      // FÃ¶rsÃ¶k skapa kalenderinbjudan via Graph
      let atOfficeEventCreated = false;
      let icsAttachment = null;
      try {
        const eventResult = await graphClient.createEvent({
          start: startTime.toISOString(),
          end: endTime.toISOString(),
          subject: emailSubject,
          location: combinedMetadata.location,
          attendees: [email],
          meetingType: meeting_type
        });
        debugLog("ğŸ“¨ eventResult:", eventResult);
        // Spara kalenderstatus om den finns (atOffice)
        if (eventResult?.attendees && Array.isArray(eventResult.attendees)) {
          const attendeeSelf = eventResult.attendees.find(a => a.emailAddress?.address === email);
          if (attendeeSelf?.status?.response) {
            combinedMetadata.calendar_response_status = attendeeSelf.status.response; // t.ex. 'none', 'accepted', 'declined'
            await db.query(
              'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
              ['calendar_response_status', id, { response: attendeeSelf.status.response }]
            );
          }
        }
        bookingFields.synced_to_calendar = true;
        debugLog('âœ… atOffice-event skapat i kalender via Graph');
        atOfficeEventCreated = true;
        // Logga till event_log fÃ¶r lyckad kalenderinbjudan
        await db.query(
          'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
          ['calendar_invite_sent', id, {
            subject: eventResult?.subject || null,
            location: eventResult?.location || null,
            webLink: eventResult?.webLink || null
          }]
        );
        // Logga hela eventResult som calendar_event_created
        await db.query(
          'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
          ['calendar_event_created', id, eventResult]
        );
      } catch (err) {
        context.log(`âš ï¸ atOffice-kalenderinbjudan via Graph misslyckades: ${err.message}`);
      }

      // Skapa .ics-fallback om Graph misslyckades
      if (!atOfficeEventCreated && icsAttachment == null) {
        const icsBody = `
BEGIN:VCALENDAR
VERSION:2.0
BEGIN:VEVENT
SUMMARY:${combinedMetadata.subject}
DTSTART:${startTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
DTEND:${endTime.toISOString().replace(/[-:]/g, '').replace('.000Z', 'Z')}
LOCATION:${combinedMetadata.location}
DESCRIPTION:MÃ¶te pÃ¥ kontoret
END:VEVENT
END:VCALENDAR
`.trim();
        icsAttachment = {
          '@odata.type': '#microsoft.graph.fileAttachment',
          name: 'inbjudan.ics',
          contentType: 'text/calendar',
          contentBytes: Buffer.from(icsBody).toString('base64')
        };
      }

      // Skicka endast mail om Graph misslyckades (dvs !atOfficeEventCreated)
      if (!atOfficeEventCreated && icsAttachment) {
        try {
          const bodyTemplates = settings.email_body_templates || {};
          const rawBody = bodyTemplates[meeting_type.toLowerCase()] || (settings.email_invite_template?.body || '');
          const emailBodyHtml = rawBody
            .replace('{{first_name}}', combinedMetadata.first_name || '')
            .replace('{{company}}', combinedMetadata.company || '')
            .replace('{{start_time}}', startTime.toLocaleString('sv-SE'))
            .replace('{{end_time}}', endTime.toLocaleString('sv-SE'))
            .replace('{{online_link}}', online_link || '')
            .replace('{{phone}}', combinedMetadata.phone || '')
            .replace('{{location}}', combinedMetadata.location || '')
            .replace(/\\n/g, '\n') // tolka "\\n" som newline
            .replace(/\n/g, '<br>');
          const signature = settings.email_signature || '';
          const finalEmailBodyHtml = `<html><body>${emailBodyHtml}<br><br>${signature}</body></html>`;
          await sendMail({
            to: email,
            subject: emailSubject,
            body: finalEmailBodyHtml,
            contentType: 'HTML',
            trackingPixelUrl: `https://klrab.se/track.gif?booking_id=${id}`,
            attachments: [icsAttachment]
          });
          // Logga fallback .ics-anvÃ¤ndning till event_log
          await db.query(
            'INSERT INTO event_log (event_type, booking_id, payload) VALUES ($1, $2, $3)',
            ['calendar_invite_fallback_ics', id, { source: 'fallback_ics' }]
          );
          debugLog('âœ… atOffice-inbjudan skickad via e-post (fallback .ics)');
        } catch (emailErr) {
        }
      }
    }

    const query = `
      INSERT INTO bookings (
        id, start_time, end_time, meeting_type,
        metadata, created_at, updated_at,
        contact_id, booking_email
      ) VALUES (
        $1, $2, $3, $4,
        $5, $6, $7,
        $8, $9
      )
    `;
    /*
    const values = Object.values(bookingFields);
    */
    const values = [
      bookingFields.id,
      bookingFields.start_time,
      bookingFields.end_time,
      bookingFields.meeting_type,
      bookingFields.metadata,
      bookingFields.created_at,
      bookingFields.updated_at,
      bookingFields.contact_id,
      bookingFields.booking_email
    ];
    await db.query(query, values);
    // Logga pending change fÃ¶r denna bokning
    await db.query(
      `INSERT INTO pending_changes (id, table_name, record_id, change_type, direction, processed, created_at, booking_id)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        uuidv4(),
        'bookings',
        id,
        'INSERT',
        'cloud_to_local',
        false,
        new Date(),
        id
      ]
    );
    // Simulera att kalendern synkades fÃ¶r denna demo
    await db.query(
      'INSERT INTO event_log (event_type, booking_id) VALUES ($1, $2)',
      ['booking_created', id]
    );
    debugLog(`âœ… Bokning skapad: ${id}, typ: ${meeting_type}, lÃ¤ngd: ${meeting_length}`);

    context.res = {
      status: 200,
      body: {
        status: 'booked',
        booking_id: id,
        calendar_invite_sent: bookingFields.synced_to_calendar === true
      }
    };
  } catch (err) {
    context.log.error("âŒ Booking error:", err.message);
    context.log.error("ğŸ“¦ Request body:", req.body);
    context.log.error("ğŸŒ IP:", ipAddress);
    context.log.error("ğŸ§­ User-Agent:", userAgent);
    context.log.error("âŒ Fullt felobjekt:", err);
    context.res = {
      status: 500,
      body: {
        error: err.message,
        stack: err.stack,
        full: JSON.stringify(err, Object.getOwnPropertyNames(err))
      }
    };
  } finally {
    if (db) db.release();
  }
};
END: index.js

====================
ğŸ“„ Fil: shared/utils/debugLogger.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-30 12:50:30
ğŸ“ Antal rader: 27
ğŸ§© Antal funktioner: 3
ğŸ’¬ KommentarstÃ¤ckning: 0 rader (0.0%)
ğŸ“¥ Imports: 0 â€“ Inga
ğŸ” LÃ¤ngsta funktion: 8 rader
ğŸ§  KomplexitetspoÃ¤ng: 3
ğŸ§ª TODO/FIXME: 0
====================
START: debugLogger.js
function createDebugLogger(context) {
  const isDebug = process.env.DEBUG === 'true';

  const debugLog = (msg) => {
    if (isDebug) {
      if (typeof context?.log === 'function') {
        context.log(msg);
      } else {
        console.log(msg);
      }
    }
  };

  const debugLogSlotsSummary = (slots) => {
    if (!isDebug) return;
    const fmSlots = slots.filter(s => s.slot_part === 'FM');
    const emSlots = slots.filter(s => s.slot_part === 'EM');
    console.log(`ğŸ“‹ Totalt: ${slots.length} | â˜€ï¸ FM: ${fmSlots.length} | ğŸŒ™ EM: ${emSlots.length}`);
  };

  return {
    log: debugLog,
    logSlotsSummary: debugLogSlotsSummary
  };
}

module.exports = { createDebugLogger };
END: debugLogger.js

====================
ğŸ“„ Fil: shared/slots/slotEngine.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-05-30 14:06:02
ğŸ“ Antal rader: 495
ğŸ§© Antal funktioner: 11
ğŸ’¬ KommentarstÃ¤ckning: 51 rader (10.3%)
ğŸ“¥ Imports: 7 â€“ ["const pool = require('../db/pgPool');", 'const { DateTime } = require("luxon");', "const Holidays = require('date-holidays');", 'const { resolveOriginAddress } = require("../calendar/resolveOrigin");', 'const { resolveTravelTime } = require("../maps/resolveTravelTime");', 'const msGraph = require("../calendar/msGraph");', 'const appleCalendar = require("../calendar/appleCalendar");']
ğŸ” LÃ¤ngsta funktion: 14 rader
ğŸ§  KomplexitetspoÃ¤ng: 72
ğŸ§ª TODO/FIXME: 0
====================
START: slotEngine.js
const pool = require('../db/pgPool');
const { DateTime } = require("luxon");
const Holidays = require('date-holidays');
const { resolveOriginAddress } = require("../calendar/resolveOrigin");
const { resolveTravelTime } = require("../maps/resolveTravelTime");
const msGraph = require("../calendar/msGraph");
const appleCalendar = require("../calendar/appleCalendar");
const hd = new Holidays('SE'); // Svenska helgdagar
const isDebug = process.env.DEBUG === 'true';

async function generateSlotCandidates({ day, settings, contact, pool, context, graphClient, appleClient, meeting_length, meeting_type, eventCache }) {
  const timezone = settings.timezone || "Europe/Stockholm";
  const holidays = settings.block_holidays ? new Holidays('SE') : null;
  // Generera tidsintervall var 20:e minut i svensk tid mellan Ã¶ppettid och stÃ¤ngningstid, exkl. lunch
  const open = DateTime.fromISO(`${day}T${settings.open_time}`, { zone: timezone });
  const close = DateTime.fromISO(`${day}T${settings.close_time}`, { zone: timezone });
  const lunchStart = DateTime.fromISO(`${day}T${settings.lunch_start}`, { zone: timezone });
  const lunchEnd = DateTime.fromISO(`${day}T${settings.lunch_end}`, { zone: timezone });

  const startTimes = [];
  let current = open;
  // AnvÃ¤nd context.bookingsByDay som kÃ¤lla till befintliga bokningar per dag
  const bookingsByDay = (typeof context.bookingsByDay === "object" && context.bookingsByDay) ? context.bookingsByDay : {};
  // Vi behÃ¶ver slotDateIso fÃ¶r denna dag
  // day Ã¤r en ISO-strÃ¤ng fÃ¶r dagen, t.ex. "2024-06-08"
  const slotDateIso = day;
  const existing = bookingsByDay[slotDateIso] || [];
  while (current < close) {
    const end = current.plus({ minutes: meeting_length });
    const overlapsLunch = current < lunchEnd && end > lunchStart;
    if (!overlapsLunch) {
      const isHoliday = settings.block_holidays && holidays?.isHoliday(new Date(current.toISO()));
      if (isHoliday) {
        // if (isDebug) context.log(`â›” Helgdag â€“ hoppar ${current.toISODate()}`);
        current = current.plus({ minutes: 20 });
        continue;
      }
      // --- NY KOD: Kontrollera om sloten krockar med event i bookingsByDay (inkl. heldagsevent) ---
      if (isDebug) {
        context.log(`ğŸ“‹ Befintliga bokningar fÃ¶r ${slotDateIso}:`);
        for (const ev of existing) {
          const start = new Date(ev.start).toISOString();
          const end = new Date(ev.end).toISOString();
          context.log(`   ğŸ“† ${start} â†’ ${end}`);
        }
      }
      const slotStartMs = current.toMillis();
      const slotEndMs = end.toMillis();
      const bufferMsEarly = (settings.buffer_between_meetings || 0) * 60000;
      if (isDebug) {
        context.log(`ğŸ” Kontroll av konflikt fÃ¶r slot: ${current.toISO()} â†’ ${end.toISO()}`);
        for (const ev of existing) {
          const evStart = new Date(ev.start).toISOString();
          const evEnd = new Date(ev.end).toISOString();
          context.log(`   ğŸ“† Event: ${evStart} â†’ ${evEnd}`);
          context.log(`     â†ªï¸ JÃ¤mfÃ¶relse: ev.start < slotEndMs + bufferMsEarly = ${ev.start} < ${slotEndMs + bufferMsEarly}`);
          context.log(`     â†ªï¸ JÃ¤mfÃ¶relse: ev.end > slotStartMs - bufferMsEarly = ${ev.end} > ${slotStartMs - bufferMsEarly}`);
        }
      }
      const slotConflictsWithEvent = existing.some(ev => {
        return (
          ev.start < slotEndMs + bufferMsEarly &&
          ev.end > slotStartMs - bufferMsEarly
        );
      });
      if (slotConflictsWithEvent) {
        // if (isDebug) context.log(`â›” Slot krockar med event i bookingsByDay â€“ hoppar ${current.toISO()}`);
        current = current.plus({ minutes: 20 });
        continue;
      }
      // --- SLUT NY KOD ---
      startTimes.push(current.toUTC());
    }
    current = current.plus({ minutes: 20 });
  }
  const slots = [];
  // BerÃ¤kna dagens start och slut
  const fullDayStart = DateTime.fromISO(`${slotDateIso}T${settings.open_time}`, { zone: timezone }).toMillis();
  const fullDayEnd = DateTime.fromISO(`${slotDateIso}T${settings.close_time}`, { zone: timezone }).toMillis();
  const dayEnd = DateTime.fromISO(`${slotDateIso}T${settings.close_time}`, { zone: timezone }).toJSDate();
  const fullDayBlock = existing.some(ev => {
    const evStart = Number(ev.start);
    const evEnd = Number(ev.end);
    const coveredDuration = evEnd - evStart;
    const fullDayDuration = fullDayEnd - fullDayStart;
    return (
      evStart <= fullDayStart + 30 * 60 * 1000 &&
      evEnd >= fullDayEnd - 30 * 60 * 1000 &&
      coveredDuration >= fullDayDuration * 0.95
    );
  });
  if (fullDayBlock) {
    // context.log(`â›” Hela dagen blockeras av ett heldagsevent â€“ hoppar ${slotDateIso}`);
    return [];
  }

  for (const utcStart of startTimes) {
    const eventId = utcStart.toISO();
    const dateObj = utcStart.toJSDate();
    const weekday = dateObj.toLocaleDateString("en-US", { weekday: "long", timeZone: timezone }).toLowerCase();
    const slot_part = utcStart.hour < 12 ? "fm" : "em";
    const slotHourStr = utcStart.setZone(timezone).toFormat('HH:mm');
    if (slotHourStr >= settings.lunch_start && slotHourStr < settings.lunch_end) {
      // if (isDebug) context.log(`ğŸ½ï¸ Slot under lunch (${slotHourStr}) â€“ hoppar ${eventId}`);
      continue;
    }
    const isWeekend = ["saturday", "sunday"].includes(weekday);
    if (settings.block_weekends && isWeekend) {
      // if (isDebug) context.log(`â›” Helg blockerad (${weekday}) â€“ hoppar ${eventId}`);
      continue;
    }
    if (meeting_type === 'atclient' && Array.isArray(settings.allowed_atclient_meeting_days)) {
      if (!settings.allowed_atclient_meeting_days.includes(weekday)) {
        // if (isDebug) context.log(`â›” atclient tillÃ¥ts ej pÃ¥ ${weekday} â€“ hoppar ${eventId}`);
        continue;
      }
    }

    // Konvertera dateObj till rÃ¤tt tidszon fÃ¶r helgdagskontroll
    const localDate = DateTime.fromJSDate(dateObj).setZone(timezone).toJSDate();
    const isHoliday = hd.isHoliday(localDate);
    if (settings.block_holidays && isHoliday) {
      if (isDebug) context.log(`ğŸŒ Helgdag ${isHoliday[0]?.name} â€“ hoppar ${eventId}`);
      continue;
    }


    const originInfo = await resolveOriginAddress({
      eventId,
      calendarId: 'system',
      pool,
      context,
      graphClient,
      appleClient,
      fallbackOrigin: settings.default_home_address,
      settings,
      eventCache
    });

    if (!originInfo?.origin) {
      // context.log(`âš ï¸ Kunde inte faststÃ¤lla origin fÃ¶r ${eventId}`);
      continue;
    }

    const destination = settings.default_office_address;
    const travelTimeResult = await resolveTravelTime({
      origin: originInfo.origin,
      destination,
      hour: utcStart.hour,
      db: pool,
      accessToken: context.accessToken || null,
      context
    });
    const travelTimeMin = travelTimeResult?.travelTimeMin;
    const travelSource = travelTimeResult?.source || 'fallback';

    if (!travelTimeMin || typeof travelTimeMin !== "number") {
      // context.log.warn(`âš ï¸ Ogiltig restid, hoppar slot: ${eventId}`);
      continue;
    }

    const endTime = new Date(dateObj.getTime() + meeting_length * 60000);
    // dayStart och dayEnd redan definierade ovan
    if (endTime > dayEnd) {
      // context.log(`â›” Slot ${eventId} gÃ¥r utanfÃ¶r Ã¶ppettid (${settings.close_time}) â€“ hoppar`);
      continue;
    }

    // Skip slots that are too soon to reach based on travel time and current time
    const now = Date.now();
    if (dateObj.getTime() - now < travelTimeMin * 60 * 1000) {
      // context.log(`â›” Slot ${eventId} Ã¤r fÃ¶r nÃ¤ra i tid â€“ restid ${travelTimeMin} min, nu=${new Date(now).toISOString()} â€“ hoppar`);
      continue;
    }

    // Build slot object
    const slot = {
      slot_iso: eventId,
      slot_local: DateTime.fromJSDate(dateObj).setZone(timezone).toISO(),
      travel_time_min: travelTimeMin,
      origin: originInfo.origin,
      originEndTime: originInfo.originEndTime,
      source: travelSource,
      require_approval: settings.require_approval,
      meeting_length,
      weekday,
      slot_part
    };


    // --- Score calculation logic ---
    const slotStart = dateObj.getTime();
    const slotEnd = slotStart + meeting_length * 60000;
    // existing redan definierad ovan
    let gapBefore = null;
    let gapAfter = null;

    for (const b of existing) {
      const bStart = b.start;
      const bEnd = b.end;
      if (bEnd <= slotStart) {
        gapBefore = slotStart - bEnd;
      } else if (bStart >= slotEnd && gapAfter === null) {
        gapAfter = bStart - slotEnd;
      }
    }

    const bufferMs = (settings.buffer_between_meetings || 0) * 60000;
    const hasConflict = existing.some(b => {
      return (
        b.start < slotEnd + bufferMs &&
        b.end > slotStart - bufferMs
      );
    });
    if (hasConflict) {
      // context.log(`â›” Slot ${eventId} krockar med mÃ¶te inom buffer (${settings.buffer_between_meetings || 0} min) â€“ hoppar`);
      // existing.forEach(b => {
      //   const bStartStr = new Date(b.start).toISOString();
      //   const bEndStr = new Date(b.end).toISOString();
      //   if (
      //     b.start < slotEnd + bufferMs &&
      //     b.end > slotStart - bufferMs
      //   ) {
      //     context.log(`   âš ï¸  Konflikt med: ${bStartStr} â†’ ${bEndStr}`);
      //   }
      // });
      continue;
    }
    // Blockera Ã¤ven om sloten bÃ¶rjar exakt nÃ¤r ett event bÃ¶rjar, eller slutar exakt nÃ¤r ett event slutar
    const hardMatchConflict = existing.some(b => {
      return (
        b.start === slotStart || b.end === slotEnd
      );
    });
    if (hardMatchConflict) {
      // context.log(`â›” Slot ${eventId} bÃ¶rjar eller slutar exakt nÃ¤r ett event bÃ¶rjar/slutar â€“ hoppar`);
      continue;
    }


    // StandardpoÃ¤ng Ã¤r 10. Dra av poÃ¤ng fÃ¶r stor lucka fÃ¶re eller efter.
    let fragmentationPenalty = 0;
    if ((gapBefore && gapBefore > 45 * 60000) || (gapAfter && gapAfter > 45 * 60000)) {
      fragmentationPenalty = 1;
    }

    slot.score = 10 - fragmentationPenalty;

    slots.push(slot);
    // if (isDebug && travelSource === 'fallback') {
    //   context.log(`âš ï¸ Slot ${eventId} anvÃ¤nder fallback fÃ¶r restid (ingen accessToken)`);
    // }
  }

  // Separera fÃ¶rmiddag och eftermiddag
  const fmSlots = slots.filter(slot => slot.slot_part === 'fm');
  const emSlots = slots.filter(slot => slot.slot_part === 'em');

  // Sorteringsfunktion: hÃ¶gst poÃ¤ng fÃ¶rst, dÃ¤refter kortast restid, dÃ¤refter tidigast tid
  const sortSlots = (a, b) =>
    b.score - a.score ||
    a.travel_time_min - b.travel_time_min ||
    new Date(a.slot_iso) - new Date(b.slot_iso);

  // Sortera bÃ¥da grupper
  fmSlots.sort(sortSlots);
  emSlots.sort(sortSlots);

  // VÃ¤lj bÃ¤sta fm och em (om de finns)
  const bestFm = fmSlots[0];
  const bestEm = emSlots.find(em => !bestFm || em.slot_iso !== bestFm.slot_iso);

  // Returnera endast de tvÃ¥ bÃ¤sta
  const topSlots = [bestFm, bestEm].filter(Boolean);
  const allSlots = [...fmSlots, ...emSlots];
  // === LOG SELECTED TOP SLOTS ===
  if (isDebug) {
    if (topSlots.length > 0) {
      context.log(`âœ… Slot-kandidater valda fÃ¶r ${slotDateIso}:`);
      topSlots.forEach(slot => {
        const icon = slot.slot_part === 'fm' ? 'â˜€ï¸' : 'ğŸŒ™';
        const t = DateTime.fromISO(slot.slot_iso).setZone(timezone).toFormat("yyyy-MM-dd HH:mm");
        context.log(`   ${icon} ${slot.slot_part.toUpperCase()} ${t} (${slot.score}/10, ${slot.travel_time_min} min restid)`);
      });
    } else {
      context.log(`â›” Inga valda slot-kandidater fÃ¶r ${slotDateIso}`);
    }
  }
  // === BLOCK: Slot-summering/debug innan slots loggas ===
  if (isDebug) {
    const blockedSummary = [];
    if (startTimes.length === 0) {
      blockedSummary.push("â›” Inga starttider genererades p.g.a. heldagsevent, helgdag eller block");
    }
    if (fullDayBlock) {
      blockedSummary.push("â›” Dagen blockeras helt p.g.a. heldagsevent");
    }
    if (startTimes.length > 0 && allSlots.length === 0) {
      blockedSummary.push("â›” Alla slots filtrerades bort av regler: t.ex. restid, konflikt, Ã¶ppettid, veckokvot, m.m.");
    }
    if (blockedSummary.length > 0) {
      context.log(`ğŸ§¾ Slot-summering ${slotDateIso}:`);
      for (const line of blockedSummary) context.log("   " + line);
    }
  }
  allSlots.forEach(s => {
    const icon = s.slot_part === 'fm' ? 'â˜€ï¸' : 'ğŸŒ™';
    if (isDebug) context.log(`${icon} ${s.slot_part.toUpperCase()}: ${s.slot_iso} â€“ score: ${s.score}`);
  });
  return topSlots;
}


async function generateSlotChunks({
  days,
  context,
  contact,
  contact_id,
  meeting_type,
  meeting_length,
  bookingsByDay,
  weeklyMinutesByType,
  settings,
  graphClient,
  appleClient,
  travelCache,
  accessToken,
  timezone,
  debugHelper
}) {
  const { debugLog, skipReasons } = debugHelper || {};
  const chosen = [];

  if (days.length === 0) {
    const fallbackDate = new Date().toISOString().split('T')[0];
    const { rows } = await pool.query(
      'SELECT slots FROM slot_cache WHERE slot_day = $1 LIMIT 1',
      [fallbackDate]
    );
    if (rows.length > 0) {
      context.log(`âœ… AnvÃ¤nder slot_cache som fallback (${fallbackDate})`);
      return {
        chosenSlots: rows[0].slots || [],
        slotMapResult: {},
        slotLogSummary: { 'fallback_used': 1 }
      };
    }
  }

  let startIso, endIso;
  try {
    startIso = days[0] instanceof Date ? days[0].toISOString() : new Date(days[0]).toISOString();
    endIso = new Date((days[days.length - 1] instanceof Date ? days[days.length - 1] : new Date(days[days.length - 1])).getTime() + 86400000).toISOString();
  } catch (err) {
    context.log("â›” Fel vid toISOString pÃ¥ days[] â€“ ersÃ¤tter med dagens datum");
    const today = new Date();
    startIso = today.toISOString();
    endIso = new Date(today.getTime() + 7 * 86400000).toISOString(); // +7 dagar fallback
  }

  // === LÃ„GG TILL EXTERNA BOKNINGAR (MS + Apple) I bookingsByDay ===

  // Microsoft Graph
  try {
    const msEvents = await graphClient.listUpcomingEvents?.(days.length + 1) || [];
    let msAddedCount = 0;
    for (const ev of msEvents) {
      const start = new Date(ev.start).getTime();
      const end = new Date(ev.end).getTime();
      if (isNaN(start) || isNaN(end)) continue;
      const date = new Date(ev.start).toISOString().split("T")[0];
      if (!bookingsByDay[date]) bookingsByDay[date] = [];
      bookingsByDay[date].push({ start, end });
      msAddedCount++;
    }
    if (isDebug) {
      context.log(`ğŸ“† MS Graph: ${msEvents.length} hÃ¤ndelser analyserades, ${msAddedCount} lades till bookingsByDay`);
    }
  } catch (err) {
    context.log(`âš ï¸ Kunde inte ladda MS-bokningar: ${err.message}`);
  }

  // Apple Calendar
  try {
    const startDate = days[0] instanceof Date ? days[0] : new Date(days[0]);
    const endDate = days[days.length - 1] instanceof Date
      ? new Date(days[days.length - 1].getTime() + 86400000)
      : new Date(new Date(days[days.length - 1]).getTime() + 86400000);
    if (isNaN(startDate) || isNaN(endDate)) {
      context.log("â›” Ogiltiga datum skickas till Apple i slotEngine:", { startDate, endDate });
    }
    const appleEvents = await appleClient.fetchEventsByDateRange?.(startDate, endDate) || [];
    let appleAddedCount = 0;
    for (const ev of appleEvents) {
      try {
        // Ensure start and end are cast to numbers explicitly
        const start = Number(new Date(ev.dtstart));
        const end = Number(new Date(ev.dtend));
        if (isNaN(start) || isNaN(end)) continue;
        const date = new Date(ev.dtstart).toISOString().split("T")[0];
        if (!bookingsByDay[date]) bookingsByDay[date] = [];
        bookingsByDay[date].push({ start, end });
        appleAddedCount++;
      } catch (err) {
        context.log(`âš ï¸ Apple event parsing error: ${err.message}`);
      }
    }
    if (isDebug) {
      context.log(`ğŸ Apple Calendar: ${appleEvents.length} hÃ¤ndelser analyserades`);
    }
  } catch (err) {
    context.log(`âš ï¸ Kunde inte ladda Apple-bokningar: ${err.message}`);
  }

  context.bookingsByDay = bookingsByDay;

  const slotCandidatePromises = days.map(day => {
    const dayStr = day.toISOString().split("T")[0];
    return generateSlotCandidates({
      day: dayStr,
      settings,
      contact,
      pool: context.client || pool,
      context,
      graphClient,
      appleClient,
      meeting_length,
      meeting_type,
      eventCache: context.eventCache instanceof Map ? context.eventCache : new Map()
    });
  });

  const slotCandidatesPerDay = await Promise.all(slotCandidatePromises);

  const slotMap = {};
  days.forEach((day, index) => {
    const dayStr = day.toISOString().split("T")[0];
    const slotCandidates = slotCandidatesPerDay[index];
    for (const slot of slotCandidates) {
      const key = `${dayStr}_${slot.slot_part}`;
      if (!slotMap[key]) slotMap[key] = [];
      slotMap[key].push(slot);
    }
  });

  const bestPerGroup = {};
  for (const [key, slots] of Object.entries(slotMap)) {
    if (slots.length === 0) continue;
    const [datePart, part] = key.split('_');
    if (!bestPerGroup[datePart]) bestPerGroup[datePart] = {};
    if (!bestPerGroup[datePart][part]) {
      bestPerGroup[datePart][part] = slots
        .sort((a, b) => {
          if ((b.score || 0) !== (a.score || 0)) return (b.score || 0) - (a.score || 0);
          return new Date(a.slot_iso) - new Date(b.slot_iso);
        })[0];
    }
  }

  for (const day in bestPerGroup) {
    for (const part in bestPerGroup[day]) {
      const slot = bestPerGroup[day][part];
      const weekKeyStr = day;
      const usedMinutes = (weeklyMinutesByType[meeting_type]?.[weekKeyStr] || 0);
      if (usedMinutes + slot.meeting_length <= settings.max_weekly_booking_minutes) {
        chosen.push(slot);
      } else {
        debugLog?.(`â›” Ã–verskrider veckokvot (${usedMinutes + slot.meeting_length} > ${settings.max_weekly_booking_minutes}) â€“ hoppar ${day}_${part}`);
      }
    }
  }

  if (isDebug) {
    for (const day in bestPerGroup) {
      for (const part in bestPerGroup[day]) {
        const slot = bestPerGroup[day][part];
        context.log(`ğŸ“† Slot: ${slot.slot_iso} score=${slot.score}`);
      }
    }
  }

  const durationMs = Date.now() - context.startTime;
  if (isDebug) context.log(`â±ï¸ Slotgenerering klar pÃ¥ ${durationMs} ms`);
  if (isDebug) context.log(`ğŸ“¤ Response skickas med antal slots: ${chosen.length}`);
  return {
    chosenSlots: chosen.sort((a, b) => new Date(a.slot_iso) - new Date(b.slot_iso)),
    slotMapResult: slotMap,
    slotLogSummary: skipReasons
  };
}

module.exports = {
  generateSlotCandidates,
  generateSlotChunks
};
END: slotEngine.js

====================
ğŸ“„ Fil: tracking/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-06-04 11:00:57
ğŸ“ Antal rader: 133
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 5 rader (3.8%)
ğŸ“¥ Imports: 1 â€“ ["const pool = require('../shared/db/pgPool');"]
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 10
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
// Tracking-logik fÃ¶r insamling av event
const pool = require('../shared/db/pgPool');

const allowedEvents = ['page_view', 'click', 'scroll_50', 'form_submit', 'session_end', 'page_unload'];

// Detta Ã¤r tracking-logik
module.exports = async function (context, req) {
  if (req.method !== 'POST') {
    context.res = {
      status: 405,
      body: 'Only POST requests allowed',
    };
    return;
  }

  let body = req.body;
  context.log('[tracking] RÃ¥ inkommande body:', body);

  if (typeof body === 'string') {
    try {
      body = JSON.parse(body);
    } catch (err) {
      context.log.error('[tracking] Kunde inte parsa JSON:', err.message);
      context.res = {
        status: 400,
        body: 'Malformed JSON',
      };
      return;
    }
  }

  if (!body || !body.visitor_id || !body.event_type) {
    context.res = {
      status: 400,
      body: 'Missing required fields',
    };
    return;
  }

  const {
    visitor_id,
    event_type,
    url,
    timestamp,
    referrer,
    utm_source,
    utm_medium,
    utm_campaign,
    metadata,
  } = body;

  const eventTimestamp = timestamp || new Date().toISOString();
  const safeMetadata = (typeof metadata === 'object' && metadata !== null) ? metadata : {};

  // TillÃ¥tna event_type
  if (!allowedEvents.includes(event_type)) {
    context.log.warn('[tracking] âš ï¸ OkÃ¤nt event_type:', event_type);
  }

  // Blockera vissa user_agents
  if (!safeMetadata.user_agent || safeMetadata.user_agent === '' || safeMetadata.user_agent.includes('curl') || safeMetadata.user_agent.includes('bot')) {
    context.log.warn('[tracking] ğŸ”’ Blockerat pga user_agent:', safeMetadata.user_agent);
    context.res = { status: 204 };
    return;
  }

  // SlÃ¥ ihop metadata + kontext till en sammanhÃ¤ngande JSONB
  const finalMetadata = {
    ...safeMetadata,
    url,
    referrer,
    utm: {
      source: utm_source,
      medium: utm_medium,
      campaign: utm_campaign,
    },
  };

  const ip = safeMetadata?.ip_address;

  if (ip) {
    try {
      const res = await fetch(`https://ipapi.co/${ip}/json/`);
      if (res.ok) {
        const geo = await res.json();
        finalMetadata.geo = {
          country: geo.country_name,
          country_code: geo.country_code,
          city: geo.city,
          region: geo.region,
          latitude: geo.latitude,
          longitude: geo.longitude
        };
      }
    } catch (err) {
      context.log.warn('[geoip] Kunde inte hÃ¤mta plats fÃ¶r IP:', ip, err.message);
    }
  }

  try {
    context.log('[tracking] Sparar event:', {
      visitor_id,
      event_type,
      timestamp: eventTimestamp,
      metadata: finalMetadata,
    });

    await pool.query(
      `INSERT INTO tracking_event (
        visitor_id, event_type, timestamp, metadata
      ) VALUES ($1, $2, $3, $4)`,
      [
        visitor_id,
        event_type,
        eventTimestamp,
        finalMetadata,
      ]
    );

    const who = finalMetadata?.email || 'anonym';
    context.log(`[TRACK] ${event_type} frÃ¥n ${visitor_id} (${who})`);
    context.res = {
      status: 200,
      body: 'Event saved',
    };
  } catch (error) {
    context.log.error('Tracking DB error:', error);
    context.res = {
      status: 500,
      body: 'Error saving tracking data',
    };
  }
};
END: index.js

====================
ğŸ“„ Fil: verify_token/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-06-13 16:47:37
ğŸ“ Antal rader: 68
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 2 rader (2.9%)
ğŸ“¥ Imports: 1 â€“ ["const pool = require('../shared/db/pgPool');"]
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 6
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const pool = require('../shared/db/pgPool');

module.exports = async function (context, req) {
  const token = req.query.token || (req.body && req.body.token);

  if (!token) {
    context.res = { status: 400, body: { error: 'token krÃ¤vs' } };
    return;
  }

  try {
    // Rensa gamla tokens som aldrig anvÃ¤nts (Ã¤ldre Ã¤n 2 dagar)
    await pool.query(`
      DELETE FROM pending_verification
      WHERE used_at IS NULL AND created_at < NOW() - INTERVAL '2 days'
    `);
    const result = await pool.query(
      `SELECT email, metadata, created_at FROM pending_verification WHERE token = $1 AND used_at IS NULL LIMIT 1`,
      [token]
    );

    if (result.rowCount === 0) {
      context.res = { status: 404, body: { error: 'Ogiltig eller anvÃ¤nd token' } };
      return;
    }

    const row = result.rows[0];
    const createdAt = new Date(row.metadata?.created_at || row.created_at);
    const maxAgeMs = 24 * 60 * 60 * 1000; // 24h
    if (Date.now() - createdAt.getTime() > maxAgeMs) {
      context.res = { status: 410, body: { error: 'Token har gÃ¥tt ut' } };
      return;
    }

    const { email, metadata } = row;
    const action = metadata?.action;

    await pool.query(
      `UPDATE pending_verification SET used_at = NOW() WHERE token = $1`,
      [token]
    );

    // Logga event efter att token Ã¤r bekrÃ¤ftad som giltig
    if (action === 'newsletter') {
      await pool.query(
        `INSERT INTO event_log (event_type, payload, created_at)
         VALUES ($1, $2, NOW())`,
        ['newsletter_verified', { email }]
      );
    } else if (action === 'download_pdf') {
      await pool.query(
        `INSERT INTO event_log (event_type, payload, created_at)
         VALUES ($1, $2, NOW())`,
        ['pdf_verified', { email, action }]
      );
    }

    context.res = {
      status: 200,
      body: { email, action }
    };
  } catch (err) {
    context.res = {
      status: 500,
      body: { error: err.message }
    };
  }
};

END: index.js

====================
ğŸ“„ Fil: request_verification/index.js
ğŸ“‚ Kodtyp: ğŸ“„ Ã–vrigt
ğŸ—‚ Filtyp: ğŸŸ¨ JavaScript
ğŸ“… Senast Ã¤ndrad: 2025-06-24 18:07:54
ğŸ“ Antal rader: 111
ğŸ§© Antal funktioner: 0
ğŸ’¬ KommentarstÃ¤ckning: 2 rader (1.8%)
ğŸ“¥ Imports: 3 â€“ ["const pool = require('../shared/db/pgPool');", "const { sendMail } = require('../shared/notification/sendMail');", "const { v4: uuidv4 } = require('uuid');"]
ğŸ” LÃ¤ngsta funktion: 0 rader
ğŸ§  KomplexitetspoÃ¤ng: 7
ğŸ§ª TODO/FIXME: 0
====================
START: index.js
const pool = require('../shared/db/pgPool');
const { sendMail } = require('../shared/notification/sendMail');
const { v4: uuidv4 } = require('uuid');

module.exports = async function (context, req) {
  const token = req.body?.token || req.query?.token;

  if (!token) {
    context.res = { status: 400, body: { error: 'token krÃ¤vs' } };
    return;
  }

  try {
    // Rensa gamla tokens som aldrig anvÃ¤nts (Ã¤ldre Ã¤n 2 dagar)
    await pool.query(`
      DELETE FROM pending_verification
      WHERE used_at IS NULL AND created_at < NOW() - INTERVAL '2 days'
    `);
    const res = await pool.query(
      `SELECT email, metadata, created_at FROM pending_verification WHERE token = $1 AND used_at IS NULL LIMIT 1`,
      [token]
    );
    const row = res.rows[0];

    if (!row) {
      context.res = { status: 404, body: { error: 'Ogiltig eller redan anvÃ¤nd token' } };
      return;
    }

    const createdAt = new Date(row.metadata?.created_at || row.created_at);
    const maxAgeMs = 24 * 60 * 60 * 1000; // 24h
    if (Date.now() - createdAt.getTime() > maxAgeMs) {
      context.res = { status: 410, body: { error: 'Token har gÃ¥tt ut' } };
      return;
    }

    const { email, metadata } = row;
    const action = metadata?.action;

    if (action === 'newsletter') {
      // Kontrollera om kontakt redan finns
      const contactRes = await pool.query(
        `SELECT c.id AS contact_id, ccr.id AS ccrelation_id, ccr.metadata
         FROM contact c
         JOIN ccrelation ccr ON c.id = ccr.contact_id
         WHERE ccr.metadata->>'email' = $1
         LIMIT 1`,
        [email]
      );
      if (contactRes.rows.length > 0) {
        const ccrelation_id = contactRes.rows[0].ccrelation_id;
        await pool.query(
          `UPDATE ccrelation
           SET metadata = jsonb_set(metadata, '{subscribed_to_newsletter}', 'true'::jsonb, true),
               updated_at = NOW()
           WHERE id = $1`,
          [ccrelation_id]
        );
      } else {
        const newContactId = uuidv4();
        await pool.query(
          `INSERT INTO contact (id, created_at) VALUES ($1, NOW())`,
          [newContactId]
        );

        const newRelationId = uuidv4();
        await pool.query(
          `INSERT INTO ccrelation (id, contact_id, metadata, role, created_at)
           VALUES ($1, $2, $3, 'newsletter', NOW())`,
          [newRelationId, newContactId, { email, subscribed_to_newsletter: true }]
        );
      }

      await pool.query(
        `UPDATE pending_verification SET used_at = NOW() WHERE token = $1`,
        [token]
      );

      context.res = {
        status: 200,
        body: { status: 'confirmed', message: 'Prenumerationen Ã¤r nu bekrÃ¤ftad.' }
      };
      return;
    }

    if (action === 'download_pdf') {
      await pool.query(
        `UPDATE pending_verification SET used_at = NOW() WHERE token = $1`,
        [token]
      );
      context.res = {
        status: 200,
        body: {
          status: 'confirmed',
          download_url: 'https://klrab.se/files/whitepaper.pdf'
        }
      };
      return;
    }

    context.res = {
      status: 400,
      body: { error: 'OkÃ¤nd Ã¥tgÃ¤rd kopplad till token.' }
    };
  } catch (err) {
    context.res = {
      status: 500,
      body: { error: err.message }
    };
  }
};
END: index.js

ğŸ“ KONFIGURATIONSFILER (function.json / host.json / package.json / .funcignore)
====================================

ğŸ“„ .funcignore
   # Exclude dev-only files and folders
   .git
   .vscode
   .env
   *.log
   test/
   tests/
   
   # Explicitly include all required files and folders
   !host.json
   !package.json
   !package-lock.json
   
   !node_modules/
   !node_modules/**
   
   !shared/
   !shared/**
   
   !bookings/
   !bookings/**
   !getavailableslots/
   !getavailableslots/**
   !validate_contact/
   !validate_contact/**
   !meeting_types/
   !meeting_types/**
   !refreshCalendarOrigins/
   !refreshCalendarOrigins/**
   !refreshTravelTimes/
   !refreshTravelTimes/**
   !booking_settings/
   !booking_settings/**
   !test_azurecloud/
   !test_azurecloud/**
   !tracking/
   !tracking/**
   !verify_token/
   !verify_token/**
   !request_verification/
   !request_verification/**
ğŸ“„ booking_settings/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get"],
         "route": "booking_settings"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ bookings/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "bookings"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ getavailableslots/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "getavailableslots"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ host.json
   {
     "version": "2.0",
     "extensionBundle": {
       "id": "Microsoft.Azure.Functions.ExtensionBundle",
       "version": "[4.*, 5.0.0)"
     },
     "extensions": {
       "http": {
         "cors": {
           "allowedOrigins": [
             "https://www.klrab.se"
           ],
           "supportCredentials": false
         }
       }
     }
   }
ğŸ“„ local_frontend/package.json
   {
     "name": "local_frontend",
     "version": "1.0.0",
     "type": "module",
     "main": "vite.config.js",
     "scripts": {
       "dev": "vite",
       "build": "vite build",
       "preview": "vite preview"
     },
     "keywords": [],
     "author": "",
     "license": "ISC",
     "dependencies": {
       "react": "^19.1.0",
       "react-dom": "^19.1.0",
       "react-icons": "^5.5.0",
       "react-router-dom": "^6.30.1",
       "vite": "^6.3.5"
     },
     "devDependencies": {
       "@tailwindcss/postcss": "^4.1.8",
       "@vitejs/plugin-react": "^4.5.1",
       "autoprefixer": "^10.4.21",
       "postcss": "^8.5.4",
       "tailwindcss": "^4.1.8"
     },
     "description": ""
   }

ğŸ“„ meeting_types/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": [ "get" ],
         "route": "meeting_types"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ package.json
   {
     "name": "macspot-api",
     "version": "1.0.0",
     "description": "Azure Functions backend fÃ¶r MacSpot CRM/ERP",
     "scripts": {
       "start": "func start",
       "dev": "func start --verbose",
       "deploy": "func azure functionapp publish macspotbackend",
       "build": "echo 'Nothing to build'"
     },
     "dependencies": {
       "@azure/functions": "^4.7.0",
       "@azure/msal-node": "^3.5.1",
       "@microsoft/microsoft-graph-client": "^3.0.0",
       "date-holidays": "^3.24.3",
       "dav": "^1.8.0",
       "dotenv": "^16.5.0",
       "isomorphic-fetch": "^3.0.0",
       "jsonwebtoken": "^9.0.0",
       "luxon": "^3.4.4",
       "node-fetch": "^2.7.0",
       "node-ical": "^0.20.1",
       "p-limit": "^6.2.0",
       "pg": "^8.15.6",
       "react": "^19.1.0",
       "react-dom": "^19.1.0",
       "uuid": "^9.0.0",
       "vite": "^6.3.5",
       "xml2js": "^0.6.2"
     },
     "devDependencies": {
       "autoprefixer": "^10.4.21",
       "postcss": "^8.5.4",
       "tailwindcss": "^4.1.8"
     }
   }

ğŸ“„ refreshCalendarOrigins/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ refreshTravelTimes/function.json
   {
     "bindings": [
       {
         "name": "myTimer",
         "type": "timerTrigger",
         "direction": "in",
         "schedule": "0 0 * * * *"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ request_verification/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "request_verification"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ test_azurecloud/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get"],
         "route": "test_azurecloud"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ tracking/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "tracking"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ validate_contact/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["get", "post"],
         "route": "validate_contact"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“„ verify_token/function.json
   {
     "bindings": [
       {
         "authLevel": "anonymous",
         "type": "httpTrigger",
         "direction": "in",
         "name": "req",
         "methods": ["post", "options"],
         "route": "verify_token"
       },
       {
         "type": "http",
         "direction": "out",
         "name": "res"
       }
     ],
     "scriptFile": "index.js"
   }
ğŸ“ˆ SUMMERING AV ALLA JS-FILER
====================================
ğŸ“ Totalt antal rader kod: 3611
ğŸ§© Totalt antal funktioner: 78
ğŸ§  Total komplexitetspoÃ¤ng: 369
ğŸ§ª Antal TODO/FIXME totalt: 0

ğŸ“Š Per fil:
fil,rader,funktioner,komplexitet,kommentarer,imports
index.js,47,1,3,1,2
index.js,208,1,29,6,3
index.js,322,12,28,22,8
index.js,36,1,1,0,4
index.js,112,4,8,0,6
appleCalendar.js,198,8,27,0,3
getMsToken.js,57,1,5,12,2
msGraph.js,204,7,17,7,5
resolveOrigin.js,236,2,38,21,0
settingsLoader.js,63,2,11,0,1
verifySettings.js,51,1,8,0,0
pgPool.js,17,1,0,0,2
appleMaps.js,120,5,9,0,2
returnTravelVerifier.js,66,1,9,1,1
resolveTravelTime.js,78,1,16,0,0
zoomClient.js,63,3,3,0,1
sendMail.js,88,2,5,14,1
index.js,811,11,54,51,7
debugLogger.js,27,3,3,0,0
slotEngine.js,495,11,72,51,7
index.js,133,0,10,5,1
index.js,68,0,6,2,1
index.js,111,0,7,2,3
ğŸ“Š MOLNDATABAS (Azure) â€“ STRUKTUR & INNEHÃ…LL
====================================

ğŸ“ Tabell: tracking_event
  â€¢ id (uuid)
  â€¢ timestamp (timestamp with time zone)
  â€¢ metadata (jsonb)
  â€¢ synced_at (timestamp with time zone)
  â€¢ visitor_id (text)
  â€¢ event_type (text)
  ğŸ”‘ [p] tracking_event_pkey: PRIMARY KEY (id)
  ğŸ§ª Topp 5 rader:
    - id=5c8d2c59-f605-45c7-b123-6c799bdb83af, visitor_id=1e3d4e99-17c6-40f3-af62-8d7c152e4cd9, event_type=page_view, timestamp=2025-06-24 19:40:13.831000+00:00, metadata={'url': '/', 'utm': {'medium': None, 'source': None, 'campaign': None}, 'screen': {'width': 1920, 'height': 1080, 'devicePixelRatio': 1}, 'language': 'en-US', 'nav_type': 0, 'platform': 'Linux x86_64', 'referrer': None, 'timezone': 'UTC', 'viewport': {'scrollY': 0, 'innerHeight': 850}, 'is_mobile': False, 'ip_address': None, 'user_agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/119.0.6045.0 Safari/537.36 (Webflow/1.0 - Site Screenshot)', 'color_depth': 24, 'fingerprint': 'e0a2de4b2a33862305afbb7b4d670439883fe5a172e14b1036a7019e9eb05d3d', 'deviceMemory': 0.5, 'do_not_track': False, 'performance_now': 4925, 'hardwareConcurrency': 2, 'timezone_offset_min': 0}, synced_at=None
    - id=eb9cd474-0eea-46bf-910d-d2ebacfe95c7, visitor_id=1e3d4e99-17c6-40f3-af62-8d7c152e4cd9, event_type=page_view, timestamp=2025-06-24 19:40:13.971000+00:00, metadata={'url': '/', 'utm': {'medium': None, 'source': None, 'campaign': None}, 'screen': {'width': 1920, 'height': 1080, 'devicePixelRatio': 1}, 'language': 'en-US', 'nav_type': 0, 'platform': 'Linux x86_64', 'referrer': None, 'timezone': 'UTC', 'viewport': {'scrollY': 0, 'innerHeight': 954}, 'is_mobile': False, 'ip_address': None, 'user_agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/119.0.6045.0 Safari/537.36 (Webflow/1.0 - Site Screenshot)', 'color_depth': 24, 'fingerprint': 'e0a2de4b2a33862305afbb7b4d670439883fe5a172e14b1036a7019e9eb05d3d', 'deviceMemory': 0.5, 'do_not_track': False, 'performance_now': 5045, 'hardwareConcurrency': 2, 'timezone_offset_min': 0}, synced_at=None

ğŸ“ Tabell: slot_cache
  â€¢ created_at (timestamp without time zone)
  â€¢ slot_day (date)
  â€¢ slots (jsonb)
  â€¢ id (uuid)
  â€¢ meeting_length (integer)
  â€¢ booking_email (text)
  â€¢ meeting_type (text)
  â€¢ slot_part (text)
  ğŸ”‘ [p] slot_cache_pkey: PRIMARY KEY (id)

ğŸ“ Tabell: calendar_origin_cache
  â€¢ created_at (timestamp without time zone)
  â€¢ timestamp (timestamp with time zone)
  â€¢ event_date (date)
  â€¢ id (integer)
  â€¢ end_time (timestamp without time zone)
  â€¢ address (text)
  â€¢ source (text)
  ğŸ”‘ [c] calendar_origin_cache_source_check: CHECK ((source = ANY (ARRAY['Apple Calendar'::text, 'Microsoft 365'::text])))
  ğŸ”‘ [p] calendar_origin_cache_pkey: PRIMARY KEY (id)

ğŸ“ Tabell: available_slots_cache
  â€¢ id (uuid)
  â€¢ travel_time_min (integer)
  â€¢ generated_at (timestamp without time zone)
  â€¢ expires_at (timestamp without time zone)
  â€¢ meeting_length (integer)
  â€¢ slot_day (date)
  â€¢ slot_score (integer)
  â€¢ meeting_type (text)
  â€¢ slot_part (text)
  â€¢ slot_iso (text)
  ğŸ”‘ [p] available_slots_cache_pkey: PRIMARY KEY (id)

ğŸ“ Tabell: pending_verification
  â€¢ id (uuid)
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp without time zone)
  â€¢ used_at (timestamp without time zone)
  â€¢ email (text)
  â€¢ token (text)
  ğŸ”‘ [p] pending_verification_pkey: PRIMARY KEY (id)
  ğŸ”‘ [u] pending_verification_token_key: UNIQUE (token)

ğŸ“ Tabell: travel_time_cache
  â€¢ travel_minutes (integer)
  â€¢ updated_at (timestamp with time zone)
  â€¢ is_fallback (boolean)
  â€¢ hour (integer)
  â€¢ created_at (timestamp with time zone)
  â€¢ to_address (text)
  â€¢ from_address (text)
  ğŸ”‘ [u] unique_travel_key: UNIQUE (from_address, to_address, hour)
  ğŸ§ª Topp 5 rader:
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=10, travel_minutes=33, created_at=2025-06-24 14:00:01.374226+00:00, updated_at=2025-06-24 14:00:01.374226+00:00, is_fallback=False
    - from_address=Taxgatan 4, 115 45 Stockholm, to_address=Maria Skolgata 79A, 118 53 Stockholm, hour=14, travel_minutes=32, created_at=2025-06-24 14:00:02.181381+00:00, updated_at=2025-06-24 14:00:02.181381+00:00, is_fallback=False

ğŸ“ Tabell: event_log
  â€¢ received_at (timestamp with time zone)
  â€¢ record_id (uuid)
  â€¢ timestamp (timestamp with time zone)
  â€¢ booking_id (uuid)
  â€¢ id (uuid)
  â€¢ payload (jsonb)
  â€¢ action (text)
  â€¢ event_type (text)
  â€¢ source (text)
  â€¢ table_name (text)
  ğŸ”‘ [p] event_log_pkey: PRIMARY KEY (id)

ğŸ“ Tabell: booking_settings
  â€¢ value (jsonb)
  â€¢ updated_at (timestamp with time zone)
  â€¢ key (text)
  â€¢ value_type (text)
  ğŸ”‘ [u] unique_key: UNIQUE (key)
  ğŸ§ª Topp 5 rader:
    - key=email_subject_templates, value={'zoom': 'ZoommÃ¶te: {{first_name}} | {{company}} & Daniel | Kinnekulle LedningsrÃ¥dgivning AB', 'teams': 'TeamsmÃ¶te: {{first_name}} | {{company}} & Daniel | Kinnekulle LedningsrÃ¥dgivning AB', 'atclient': 'MÃ¶te hos {{company}}: {{first_name}} | {{company}} & Daniel | Kinnekulle LedningsrÃ¥dgivning AB', 'atoffice': 'MÃ¶te hos KLR AB (Stockholm | SÃ¶dermalm): {{first_name}} | {{company}} & Daniel | Kinnekulle LedningsrÃ¥dgivning AB', 'facetime': 'FaceTime-mÃ¶te: {{first_name}} | {{company}} & Daniel | Kinnekulle LedningsrÃ¥dgivning AB'}, value_type=json, updated_at=2025-05-30 20:46:14.058171+00:00
    - key=default_language, value=sv, value_type=string, updated_at=2025-05-25 10:37:53.619684+00:00
    - key=default_meeting_length_atclient, value=[90, 180, 270, 360], value_type=array, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=default_meeting_length_atoffice, value=[60, 90], value_type=array, updated_at=2025-04-23 12:48:49.778155+00:00
    - key=default_meeting_length_digital, value=[10, 20, 60], value_type=array, updated_at=2025-04-23 12:48:49.778155+00:00

ğŸ“ Tabell: translation
  â€¢ key (character varying)
  â€¢ sv (text)
  â€¢ en (text)
  ğŸ§ª Topp 5 rader:
    - key=error_invalid_phone, sv=Ogiltigt telefonnummer. Vi vet att det Ã¤r svÃ¥rt att komma ihÃ¥g sitt nummer., en=Invalid phone number. We know remembering your own number is hard.
    - key=error_invalid_name, sv=Namnet Ã¤r ogiltigt (minst 2 tecken, max 50). Smeknamn som "X" Ã¤r fÃ¶r Elon., en=Invalid name (min 2 characters, max 50). Nicknames like "X" are taken.
    - key=error_missing_fields, sv=Alla fÃ¤lt mÃ¥ste vara ifyllda. Vi Ã¤r petiga sÃ¥ du slipper bli det senare., en=All fields must be filled. Weâ€™re picky so you donâ€™t have to be later.
    - key=error_missing_meeting_link, sv=MÃ¶teslÃ¤nk krÃ¤vs. Om inte mÃ¶tet sker via brevduva., en=A meeting link is required. Unless the meeting is via carrier pigeon.
    - key=error_missing_recaptcha, sv=reCAPTCHA mÃ¥ste verifieras. Nej, det Ã¤r inte en kÃ¤nslomÃ¤ssig frÃ¥ga., en=reCAPTCHA verification required. And no, itâ€™s not a personality test.

ğŸ“ Tabell: bookings
  â€¢ start_time (timestamp with time zone)
  â€¢ end_time (timestamp with time zone)
  â€¢ id (uuid)
  â€¢ updated_at (timestamp with time zone)
  â€¢ metadata (jsonb)
  â€¢ created_at (timestamp with time zone)
  â€¢ contact_id (uuid)
  â€¢ meeting_type (text)
  â€¢ booking_email (text)
  ğŸ”‘ [p] bookings_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] fk_bookings_contact: FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE SET NULL

ğŸ“ Tabell: pending_changes
  â€¢ booking_id (uuid)
  â€¢ processed (boolean)
  â€¢ created_at (timestamp with time zone)
  â€¢ payload (jsonb)
  â€¢ id (uuid)
  â€¢ record_id (uuid)
  â€¢ table_name (text)
  â€¢ operation (text)
  â€¢ change_type (text)
  â€¢ direction (text)
  ğŸ”‘ [p] pending_changes_pkey: PRIMARY KEY (id)
  ğŸ”‘ [f] fk_pending_changes_booking_id: FOREIGN KEY (booking_id) REFERENCES bookings(id) ON DELETE CASCADE

ğŸ“ Tabell: contact
  â€¢ updated_at (timestamp with time zone)
  â€¢ created_at (timestamp with time zone)
  â€¢ id (uuid)
  â€¢ metadata (jsonb)
  â€¢ booking_email (text)
  â€¢ email (text)
  â€¢ apple_uid (text)
  ğŸ”‘ [p] contact_pkey: PRIMARY KEY (id)

